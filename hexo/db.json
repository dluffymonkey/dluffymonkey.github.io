{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"source/uploads/avatar.png","path":"uploads/avatar.png","modified":1,"renderable":0},{"_id":"source/uploads/favicon.jpg","path":"uploads/favicon.jpg","modified":1,"renderable":0},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"7eaf814e01760a09bafb9c657953218f5c44377c","modified":1512124951690},{"_id":"source/.DS_Store","hash":"088b502584592d446fbc67a16ce4f89bcae4fc3f","modified":1512704122632},{"_id":"themes/next/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1512012962594},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1512014242392},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1512014242392},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1512014242392},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1512014242394},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1512014242394},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1512014242395},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1512014242395},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1512014242395},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1512014242395},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1512014242395},{"_id":"themes/next/README.cn.md","hash":"02713071ef9e260b3fe77f4403942189d55a00e9","modified":1512014242396},{"_id":"themes/next/README.md","hash":"529d53dfa97678f8ce4c95620b26e61154162a29","modified":1512014242396},{"_id":"themes/next/_config.yml","hash":"52cc270c6362c5e1572c3e23ebbdfdf3a872a25c","modified":1512726595877},{"_id":"themes/next/bower.json","hash":"6d6ae7531cf3fedc97c58cdad664f5793eb3cc88","modified":1512014242397},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1512014242397},{"_id":"themes/next/package.json","hash":"93a74dbc0fe3a1208a02e9cec3c15c2375339cc1","modified":1512014242421},{"_id":"source/about/index.md","hash":"25573887e66b2bd7390e3e15794298e498da5e2a","modified":1512014242338},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1512721997956},{"_id":"source/_posts/AndroidStudio-gradle.md","hash":"ba36e2b9771916492e24ed2a47b3d2a479818fe9","modified":1512470332959},{"_id":"source/_posts/GCD 块操作.md","hash":"91128cc1dd00ac71c61aa70645f8c7b92618d834","modified":1512724256780},{"_id":"source/_posts/GCD方法注释.md","hash":"cf047996d16fc059dece5b6c88376f7d57d1801c","modified":1512701348543},{"_id":"source/_posts/GCD学习.md","hash":"d4665566a7085a300c174970230f86437e0a198b","modified":1512725055307},{"_id":"source/_posts/GCD深入学习.md","hash":"9d78095d93b08455d3e4c2a8e93810aa9686a167","modified":1512725360351},{"_id":"source/_posts/MarkDown-Test.md","hash":"a7bf2bf629e639374eef0a8d1c00f5e075fb3f67","modified":1512527110916},{"_id":"source/_posts/Modify-The-KeyWord-Of-iOS.md","hash":"2a523fbc5073d3a501a5f28295b60b16f1f05885","modified":1512470313082},{"_id":"source/_posts/MyFirst-Hexo.md","hash":"14a9feaab6db83117a4e9f35a39d09d1896b31a2","modified":1512470330247},{"_id":"source/_posts/NSOperation简介.md","hash":"8c0f73d7ead73cf0a79ac80924a616e623d22e33","modified":1512723823434},{"_id":"source/_posts/NSRunLoop简介.md","hash":"ef52df894600d65578b6401281f17093b2388043","modified":1512723767877},{"_id":"source/_posts/NSThread简介.md","hash":"c74f60e43ecf9e0b88b86631c4055172844c43ae","modified":1512725229831},{"_id":"source/_posts/Seven.md","hash":"b4c2441ca865677882432be8668b4bca4657610c","modified":1512542664329},{"_id":"source/_posts/UITextFeild-cursor.md","hash":"6c0313ac79a589f9681cff84a87141d1d527c777","modified":1512470304276},{"_id":"source/_posts/iOS崩溃日志.md","hash":"a921ddf57e559ed85469a38b4815364035a76614","modified":1512641435277},{"_id":"source/_posts/带块的Button.md","hash":"fec317162a85983b38f8ff7532b57fe682d0b207","modified":1512548356682},{"_id":"source/_posts/面试.md","hash":"bef1f7f2a6699f9cfd742e38da207b9ea72381da","modified":1512542711279},{"_id":"source/categories/index.md","hash":"11731ed57cb2a205a8ddde2ad8c6464c9002e9ee","modified":1512014242338},{"_id":"source/tags/index.md","hash":"e90a801c3e8e36f7ce638da688db7b033c6cf801","modified":1512014242339},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1512014242393},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"352093a1b210c72136687fd2eee649244cee402c","modified":1512014242393},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1512014242393},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1512014242394},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1512014242397},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1512014242397},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1512014242398},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1512014242398},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1512014242398},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1512014242399},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1512014242399},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1512014242399},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1512014242399},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1512014242399},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1512014242400},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1512014242400},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1512014242400},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1512014242401},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1512014242401},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1512014242402},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1512014242419},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1512014242420},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1512014242420},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1512014242420},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1512014242420},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1512014242421},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1512014242421},{"_id":"themes/next/scripts/merge-configs.js","hash":"cb617ddf692f56e6b6129564d52e302f50b28243","modified":1512014242421},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1512014242422},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1512014242538},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1512014242538},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1512014242539},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512014242447},{"_id":"source/_posts/NSRunLoop简介/2017_12_08RunLoop_1.jpg","hash":"e8c9ad38b9a65e76e38b457ebe8cd52ec8e82786","modified":1512721997858},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1512014242401},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1512014242402},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1512014242401},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1512014242402},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1512014242403},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1512014242403},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"9efc455894921a66bbc074055d3b39c8a34a48a4","modified":1512014242404},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1512014242404},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1512014242404},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1512014242404},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1512014242405},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1512014242405},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1512014242406},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1512014242406},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1512014242406},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1512014242408},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1512014242408},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1512014242410},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1512014242416},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1512014242416},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1512014242416},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1512014242417},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1512014242417},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1512014242417},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1512014242418},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1512014242422},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1512014242423},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1512014242423},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1512014242423},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1512014242423},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1512014242423},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1512014242424},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1512014242424},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1512014242424},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1512014242447},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1512014242447},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1512014242447},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1512014242448},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1512014242448},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1512014242448},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1512014242449},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1512014242449},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1512014242449},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1512014242449},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1512014242449},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1512014242449},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1512014242449},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1512014242450},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1512014242450},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1512014242450},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1512014242450},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1512014242451},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1512014242451},{"_id":"source/_posts/NSRunLoop简介/2017_12_08RunLoop_2.png","hash":"1bf61e90d6cea0bcc37e448b795d407d48f8d2d3","modified":1512722002838},{"_id":"source/_posts/NSRunLoop简介/2017_12_08RunLoop_4.png","hash":"2fde3297e1697927ef714ebc4f3933da18c727aa","modified":1512722051962},{"_id":"source/_posts/NSRunLoop简介/2017_12_08RunLoop_5.png","hash":"55df6bd65e1db9f50800a145d5af2d4b21e308f2","modified":1512722055620},{"_id":"source/_posts/NSRunLoop简介/2017_12_08RunLoop_3.png","hash":"5813064e4d0f7b47005ad97f6bc5d4b268079ee5","modified":1512722047678},{"_id":"source/_posts/NSThread简介/2017_12_08_thread_four.png","hash":"e8b3a3238126f54d4297d4c78584984d722e1ab5","modified":1512703157709},{"_id":"source/_posts/NSThread简介/2017_12_08_thread_three.png","hash":"4dc1b9be7566b7c93e3d0b480572e71bf1f0cefb","modified":1512703153377},{"_id":"source/uploads/avatar.png","hash":"e7657caf545dbe59a0a0191e0af2a08cb17dcbe0","modified":1512014242341},{"_id":"source/uploads/favicon.jpg","hash":"d95f89c45b98fd862b42e576613f969812751c66","modified":1512014242343},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512014242409},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512014242409},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512014242440},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512014242440},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512014242440},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512014242446},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512014242447},{"_id":"source/_posts/NSRunLoop简介/2017_12_08RunLoop_7.png","hash":"4a359684780b079605e0875c92b40f3e0d770726","modified":1512722159086},{"_id":"source/_posts/NSThread简介/2017_12_08_thread_two.png","hash":"d9f5678a64a571fc89752c9e5632e90aff0bf71b","modified":1512703148935},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1512014242405},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1512014242405},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1512014242406},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1512014242407},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1512014242407},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1512014242407},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1512014242407},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1512014242407},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1512014242408},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1512014242409},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1512014242409},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1512014242409},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1512014242410},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1512014242410},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1512014242411},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1512014242411},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1512014242411},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1512014242411},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1512014242412},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1512014242412},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1512014242412},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1512014242412},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1512014242413},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1512014242413},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1512014242413},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1512014242413},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1512014242414},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1512014242414},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1512014242414},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1512014242415},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1512014242415},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1512014242415},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1512014242416},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1512014242416},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1512014242418},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1512014242419},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1512014242419},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1512014242419},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1512014242440},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1512014242440},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1512014242440},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1512014242440},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1512014242446},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1512014242446},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1512014242446},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1512014242447},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1512014242451},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1512014242453},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1512014242453},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1512014242454},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1512014242455},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1512014242455},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1512014242455},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1512014242455},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1512014242456},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1512014242457},{"_id":"themes/next/source/js/src/utils.js","hash":"dbdc3d1300eec7da9632608ebc0e5b697779dad7","modified":1512014242457},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1512014242464},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1512014242469},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1512014242469},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1512005931427},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1512005931427},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1512014242476},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1512014242476},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1512014242477},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1512014242478},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1512014242479},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1512014242480},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1512014242480},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1512014242483},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1512014242483},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1512014242519},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1512014242521},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1512014242521},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1512014242522},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1512014242522},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1512014242522},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1512014242523},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1512014242524},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1512014242524},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1512014242524},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1512014242525},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1512014242525},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1512014242526},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1512014242526},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1512014242526},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1512014242526},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1512014242527},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1512014242527},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1512014242527},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1512014242527},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1512014242527},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1512014242528},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1512014242528},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1512014242528},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1512014242529},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1512014242529},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1512014242529},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1512014242534},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1512014242535},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1512014242537},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1512014242537},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1512014242537},{"_id":"source/_posts/NSThread简介/2017_12_08_thread_one.png","hash":"bea6bab9e8ca06f37ba0666f6436fe41a3dc7d8e","modified":1512703144477},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1512014242520},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1512014242418},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1512014242418},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1512014242425},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1512014242425},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1512014242425},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1512014242425},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1512014242426},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1512014242429},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1512014242434},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1512014242439},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1512014242439},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1512014242439},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1512014242439},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1512014242439},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1512014242439},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1512014242440},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1512014242441},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1512014242441},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1512014242441},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1512014242441},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1512014242442},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1512014242442},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1512014242442},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1512014242442},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1512014242443},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1512014242443},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"02fb8fa6b6c252b6bed469539cd057716606a787","modified":1512014242444},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1512014242444},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1512014242444},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1512014242445},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1512014242445},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1512014242445},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1512014242445},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"bcf52192942c0afc410c74a0fb458e7936ddc3d5","modified":1512014242445},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1512014242446},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1512014242456},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1512014242462},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1512014242464},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1512014242464},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1512014242469},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1512014242469},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1512014242470},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1512014242470},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1512014242470},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1512014242471},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1512014242473},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1512014242474},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1512014242474},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1512014242478},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1512014242479},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1512014242495},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1512014242511},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1512014242512},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1512014242534},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1512014242534},{"_id":"source/_posts/NSRunLoop简介/2017_12_08RunLoop_6.png","hash":"3ea3119b46dd19e52afb487c93728c770d13eebe","modified":1512722154904},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1512014242463},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1512014242519},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1512014242518},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1512014242536},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1512014242426},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1512014242426},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1512014242426},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1512014242427},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1512014242427},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1512014242427},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1512014242427},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1512014242428},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1512014242427},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1512014242428},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1512014242428},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1512014242428},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1512014242428},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1512014242429},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1512014242429},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1512014242429},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1512014242430},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1512014242430},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1512014242430},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1512014242430},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1512014242430},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1512014242430},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1512014242431},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1512014242431},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1512014242431},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1512014242431},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1512014242431},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1512014242432},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1512014242432},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1512014242432},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1512014242432},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1512014242433},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1512014242433},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1512014242433},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1512014242433},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"77c92a449ce84d558d26d052681f2e0dd77c70c9","modified":1512014242433},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1512014242433},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1512014242434},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1512014242434},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1512014242434},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1512014242434},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1512014242435},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1512014242435},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1512014242435},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1512014242435},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1512014242435},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1512014242436},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1512014242436},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1512014242436},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1512014242436},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1512014242436},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1512014242437},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1512014242437},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1512014242438},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1512014242438},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1512014242438},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1512014242438},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1512014242438},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1512014242443},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1512014242443},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1512014242444},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1512014242458},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1512014242459},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1512014242459},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1512014242459},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1512014242460},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1512014242472},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1512014242472},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1512014242472},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1512014242472},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1512014242473},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1512014242473},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1512014242512},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1512014242515},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1512014242517},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1512014242468},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1512014242533},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1512014242517}],"Category":[{"name":"iOS Tips","_id":"cjb1u1v7l00041us0kd158ja7"},{"name":"初识Android","_id":"cjb1u1v7t000a1us0r4wqo59l"},{"name":"Hexo","_id":"cjb1u1v82000q1us0j783pc4v"},{"name":"Music","_id":"cjb1u1v8800141us0yjfuxfgt"}],"Data":[],"Page":[{"title":"不正经的boy","date":"2016-11-29T07:54:39.000Z","_content":"\n  关于我么    ------\n  \n  一只学习iOS的小菜鸟， 一天学一点，积少成多咯！\n  \n  虽然没有一张帅气的脸庞，但我可以多读书！\n  \n  我真的是个好孩子！ From Leo\n  \n  QQ：1427694267\n  Email：itachi_invincible@163.com\n  ","source":"about/index.md","raw":"---\ntitle: 不正经的boy\ndate: 2016-11-29 15:54:39\n---\n\n  关于我么    ------\n  \n  一只学习iOS的小菜鸟， 一天学一点，积少成多咯！\n  \n  虽然没有一张帅气的脸庞，但我可以多读书！\n  \n  我真的是个好孩子！ From Leo\n  \n  QQ：1427694267\n  Email：itachi_invincible@163.com\n  ","updated":"2017-11-30T03:57:22.338Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjb1u1v7e00001us06dtgeavb","content":"<p>  关于我么    ——</p>\n<p>  一只学习iOS的小菜鸟， 一天学一点，积少成多咯！</p>\n<p>  虽然没有一张帅气的脸庞，但我可以多读书！</p>\n<p>  我真的是个好孩子！ From Leo</p>\n<p>  QQ：1427694267<br>  Email：itachi_invincible@163.com</p>\n","site":{"data":{}},"excerpt":"","more":"<p>  关于我么    ——</p>\n<p>  一只学习iOS的小菜鸟， 一天学一点，积少成多咯！</p>\n<p>  虽然没有一张帅气的脸庞，但我可以多读书！</p>\n<p>  我真的是个好孩子！ From Leo</p>\n<p>  QQ：1427694267<br>  Email：itachi_invincible@163.com</p>\n"},{"title":"categories","date":"2016-11-29T07:53:45.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-11-29 15:53:45\ntype: \"categories\"\n---\n","updated":"2017-11-30T03:57:22.338Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjb1u1v7i00021us072k22lab","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2016-11-29T07:50:33.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-11-29 15:50:33\ntype: \"tags\"\n---\n","updated":"2017-11-30T03:57:22.339Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjb1u1v7n00061us07muunx1l","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"GCD学习 —— 三","date":"2017-12-08T11:32:00.000Z","_content":"\n​\t学习学习dispatch_block，在向队列中添加任务时，可以直接在对应的函数中添加 `block`。但是如果想对任务进行操作，比如监听任务、取消任务，就需要获取对应的 `block`。\n\n#### 1 创建Block\n\n- 第一种方式如下：\n\n  ```objective-c\n  dispatch_block_t dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block);\n  ```\n\n  ​\t在该函数中，`flags` 参数用来设置 `block` 的标记，`block` 参数用来设置具体的任务。`flags` 的类型为 `dispatch_block_flags_t` 的枚举，用于设置 `block` 的标记，定义如下：\n\n  ```objective-c\n  DISPATCH_ENUM(dispatch_block_flags, unsigned long,\n      DISPATCH_BLOCK_BARRIER = 0x1,\n      DISPATCH_BLOCK_DETACHED = 0x2,\n      DISPATCH_BLOCK_ASSIGN_CURRENT = 0x4,\n      DISPATCH_BLOCK_NO_QOS_CLASS = 0x8,\n      DISPATCH_BLOCK_INHERIT_QOS_CLASS = 0x10,\n      DISPATCH_BLOCK_ENFORCE_QOS_CLASS = 0x20,\n  );\n  ```\n  <!-- more -->\n- 第二种方式如下：\n\n  ```objective-c\n  dispatch_block_t dispatch_block_create_with_qos_class(dispatch_block_flags_t flags,\n      dispatch_qos_class_t qos_class, int relative_priority,\n      dispatch_block_t block);\n  ```\n\n  ​\t相比于 `dispatch_block_create` 函数，这种方式在创建 `block` 的同时可以指定了相应的优先级。`dispatch_qos_class_t` 是 `qos_class_t` 的别名，定义如下：\n\n  ```objective-c\n  #if __has_include(<sys/qos.h>)\n  typedef qos_class_t dispatch_qos_class_t;\n  #else\n  typedef unsigned int dispatch_qos_class_t;\n  #endif\n  ```\n\n  `qos_class_t` 是一种枚举，有以下类型：\n\n  - QOS_CLASS_USER_INTERACTIVE：`user interactive` 等级表示任务需要被立即执行，用来在响应事件之后更新 UI，来提供好的用户体验。这个等级最好保持小规模。\n  - QOS_CLASS_USER_INITIATED：`user initiated` 等级表示任务由 UI 发起异步执行。适用场景是需要及时，结果同时又可以继续交互的时候。\n  - QOS_CLASS_DEFAULT：`default` 默认优先级\n  - QOS_CLASS_UTILITY：`utility` 等级表示需要长时间运行的任务，伴有用户可见进度指示器。经常会用来做计算，I/O，网络，持续的数据填充等任务。这个任务节能。\n  - QOS_CLASS_BACKGROUND：`background` 等级表示用户不会察觉的任务，使用它来处理预加载，或者不需要用户交互和对时间不敏感的任务。\n  - QOS_CLASS_UNSPECIFIED：`unspecified` 未指明\n\n  egg：\n\n  ```objective-c\n  dispatch_queue_t concurrentQuene = dispatch_queue_create(\"concurrentQuene\", DISPATCH_QUEUE_CONCURRENT);\n\n  dispatch_block_t block = dispatch_block_create(0, ^{\n      NSLog(@\"normal do some thing...\");\n  });\n  dispatch_async(concurrentQuene, block);\n\n  dispatch_block_t qosBlock = dispatch_block_create_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, 0, ^{\n      NSLog(@\"qos do some thing...\");\n  });\n  dispatch_async(concurrentQuene, qosBlock);\n  ```\n\n  ```objective-c\n  LQHelper[1528:112987] qos do some thing...\n  LQHelper[1528:112985] normal do some thing...\n  ```\n\n\n\n\n#### 2 监听 block 执行结束\n\n​\t有时我们需要等待特定的 `block` 执行完成之后，再去执行其他任务。有两种方法可以获取到指定 `block` 执行结束的时机。\n\n- 第一种方式如下：\n\n  ```objective-c\n  long dispatch_block_wait(dispatch_block_t block, dispatch_time_t timeout);\n  ```\n\n  ​\t该函数会阻塞当前线程进行等待。传入需要设置的 block 和等待时间 timeout。timeout 参数表示函数在等待 block 执行完毕时，应该等待多久。如果执行 block 所需的时间小于 timeout，则返回 0，否则返回非 0 值。此参数也可以取常量 `DISPATCH_TIME_FOREVER`，这表示函数会一直等待 block 执行完，而不会超时。可以使用 dispatch_time 函数和 `DISPATCH_TIME_NOW` 常量来方便的设置具体的超时时间。\n\n  ​\t如果 block 执行完成，`dispatch_block_wait` 就会立即返回。不能使用 `dispatch_block_wait` 来等待同一个 block 的多次执行全部结束；这种情况可以考虑使用 `dispatch_group_wait` 来解决。也不能在多个线程中，同时等待同一个 block 的结束。同一个 block 只能执行一次，被等待一次。\n\n  **注意：**因为 `dispatch_block_wait` 会阻塞当前线程，所以不应该放在主线程中调用。\n\n  egg：\n\n  ```objective-c\n  dispatch_queue_t concurrentQuene = dispatch_queue_create(\"concurrentQuene\", DISPATCH_QUEUE_CONCURRENT);\n\n  dispatch_async(concurrentQuene, ^{\n      dispatch_queue_t allTasksQueue = dispatch_queue_create(\"allTasksQueue\", DISPATCH_QUEUE_CONCURRENT);\n\n      dispatch_block_t block = dispatch_block_create(0, ^{\n          NSLog(@\"开始执行\");\n          [NSThread sleepForTimeInterval:3];\n          NSLog(@\"结束执行\");\n      });\n\n      dispatch_async(allTasksQueue, block);\n      // 等待时长，10s 之后超时\n      dispatch_time_t timeout = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10 * NSEC_PER_SEC));\n      long resutl = dispatch_block_wait(block, timeout);\n      if (resutl == 0) {\n          NSLog(@\"执行成功\");\n      } else {\n          NSLog(@\"执行超时\");\n      }\n  });\n  ```\n\n  ```objective-c\n  执行结果：(把上面的sleepForTimeInterval:时间设置成3s)\n  LQHelper[1582:121193] 开始执行\n  LQHelper[1582:121194] 结束执行\n  LQHelper[1582:121193] 执行成功\n  执行结果：(把上面的sleepForTimeInterval:时间设置成12s)\n  LQHelper[1582:121193] 开始执行\n  LQHelper[1582:121194] 执行超时\n  LQHelper[1582:121193] 结束执行\n  ```\n\n- 第二种方法如下：\n\n  ```objective-c\n  void dispatch_block_notify(dispatch_block_t block, dispatch_queue_t queue, dispatch_block_t notification_block);\n  ```\n\n  ​\t该函数接收三个参数，第一个参数是需要监视的 block，第二个参数是监听的 block 执行结束之后要提交执行的队列 queue，第三个参数是待加入到队列中的 block。 和 `dispatch_block_wait` 的不同之处在于：`dispatch_block_notify` 函数不会阻塞当前线程。\n\n  egg：\n\n  ```objective-c\n  NSLog(@\"---- 开始设置任务 ----\");\n  dispatch_queue_t serialQueue =   dispatch_queue_create(\"com.itachi.serialqueue\",   DISPATCH_QUEUE_SERIAL);\n\n  // 耗时任务\n  dispatch_block_t taskBlock = dispatch_block_create(0, ^{\n      NSLog(@\"开始耗时任务\");\n      [NSThread sleepForTimeInterval:2.f];\n      NSLog(@\"完成耗时任务\");\n  });\n\n  dispatch_async(serialQueue, taskBlock);\n\n  // 更新 UI\n  dispatch_block_t refreshUI = dispatch_block_create(0, ^{\n      NSLog(@\"更新 UI\");\n  });\n\n  // 设置监听\n  dispatch_block_notify(taskBlock, dispatch_get_main_queue(), refreshUI);\n  NSLog(@\"---- 完成设置任务 ----\");\n  ```\n\n  ```objective-c\n  执行结果：\n  LQHelper[1615:127135] ---- 开始设置任务 ----\n  LQHelper[1615:127135] ---- 完成设置任务 ----\n  LQHelper[1615:127227] 开始耗时任务\n  LQHelper[1615:127227] 完成耗时任务\n  LQHelper[1615:127135] 更新 UI\n  ```\n\n  ​\n\n#### 3 任务的取消\n\niOS8 后 GCD 支持对 `dispatch block` 的取消。方法如下：\n\n```objective-c\nvoid dispatch_block_cancel(dispatch_block_t block);\n```\n\n​\t这个函数用异步的方式取消指定的 block。取消操作使将来执行 `dispatch block` 立即返回，但是对已经在执行的 `dispatch block` 没有任何影响。当一个 block 被取消时，它会立即释放捕获的资源。如果要在一个 block 中对某些对象进行释放操作，在取消这个 block 的时候，需要确保内存不会泄漏。\n\n```objective-c\ndispatch_queue_t serialQueue = dispatch_queue_create(\"com.itachi.serialqueue\", DISPATCH_QUEUE_SERIAL);\n// 耗时任务\ndispatch_block_t firstTaskBlock = dispatch_block_create(0, ^{\n    NSLog(@\"开始第一个任务\");\n    [NSThread sleepForTimeInterval:1.5f];\n    NSLog(@\"结束第一个任务\");\n});\n\n// 耗时任务\ndispatch_block_t secTaskBlock = dispatch_block_create(0, ^{\n    NSLog(@\"开始第二个任务\");\n    [NSThread sleepForTimeInterval:2.f];\n    NSLog(@\"结束第二个任务\");\n});\n\ndispatch_async(serialQueue, firstTaskBlock);\ndispatch_async(serialQueue, secTaskBlock);\n\n// 等待1s，让第一个任务开始运行\n[NSThread sleepForTimeInterval:1];\n\ndispatch_block_cancel(firstTaskBlock);\nNSLog(@\"尝试过取消第一个任务\");\n\ndispatch_block_cancel(secTaskBlock);\nNSLog(@\"尝试过取消第二个任务\");\n```\n\n```objective-c\n执行结果：\nLQHelper[1645:130881] 开始第一个任务\nLQHelper[1645:130771] 尝试过取消第一个任务\nLQHelper[1645:130771] 尝试过取消第二个任务\nLQHelper[1645:130881] 结束第一个任务\n```\n\n可见 `dispatch_block_cancel` 对已经在执行的任务不起作用，只能取消尚未执行的任务。\n\n转载自[GCD 之任务操作](http://www.jianshu.com/p/5a16dfd36fad)","source":"_posts/GCD 块操作.md","raw":"---\ntitle: GCD学习 —— 三\ndate: 2017-12-08 19:32\ntags: iOS\ncategories: iOS Tips\n---\n\n​\t学习学习dispatch_block，在向队列中添加任务时，可以直接在对应的函数中添加 `block`。但是如果想对任务进行操作，比如监听任务、取消任务，就需要获取对应的 `block`。\n\n#### 1 创建Block\n\n- 第一种方式如下：\n\n  ```objective-c\n  dispatch_block_t dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block);\n  ```\n\n  ​\t在该函数中，`flags` 参数用来设置 `block` 的标记，`block` 参数用来设置具体的任务。`flags` 的类型为 `dispatch_block_flags_t` 的枚举，用于设置 `block` 的标记，定义如下：\n\n  ```objective-c\n  DISPATCH_ENUM(dispatch_block_flags, unsigned long,\n      DISPATCH_BLOCK_BARRIER = 0x1,\n      DISPATCH_BLOCK_DETACHED = 0x2,\n      DISPATCH_BLOCK_ASSIGN_CURRENT = 0x4,\n      DISPATCH_BLOCK_NO_QOS_CLASS = 0x8,\n      DISPATCH_BLOCK_INHERIT_QOS_CLASS = 0x10,\n      DISPATCH_BLOCK_ENFORCE_QOS_CLASS = 0x20,\n  );\n  ```\n  <!-- more -->\n- 第二种方式如下：\n\n  ```objective-c\n  dispatch_block_t dispatch_block_create_with_qos_class(dispatch_block_flags_t flags,\n      dispatch_qos_class_t qos_class, int relative_priority,\n      dispatch_block_t block);\n  ```\n\n  ​\t相比于 `dispatch_block_create` 函数，这种方式在创建 `block` 的同时可以指定了相应的优先级。`dispatch_qos_class_t` 是 `qos_class_t` 的别名，定义如下：\n\n  ```objective-c\n  #if __has_include(<sys/qos.h>)\n  typedef qos_class_t dispatch_qos_class_t;\n  #else\n  typedef unsigned int dispatch_qos_class_t;\n  #endif\n  ```\n\n  `qos_class_t` 是一种枚举，有以下类型：\n\n  - QOS_CLASS_USER_INTERACTIVE：`user interactive` 等级表示任务需要被立即执行，用来在响应事件之后更新 UI，来提供好的用户体验。这个等级最好保持小规模。\n  - QOS_CLASS_USER_INITIATED：`user initiated` 等级表示任务由 UI 发起异步执行。适用场景是需要及时，结果同时又可以继续交互的时候。\n  - QOS_CLASS_DEFAULT：`default` 默认优先级\n  - QOS_CLASS_UTILITY：`utility` 等级表示需要长时间运行的任务，伴有用户可见进度指示器。经常会用来做计算，I/O，网络，持续的数据填充等任务。这个任务节能。\n  - QOS_CLASS_BACKGROUND：`background` 等级表示用户不会察觉的任务，使用它来处理预加载，或者不需要用户交互和对时间不敏感的任务。\n  - QOS_CLASS_UNSPECIFIED：`unspecified` 未指明\n\n  egg：\n\n  ```objective-c\n  dispatch_queue_t concurrentQuene = dispatch_queue_create(\"concurrentQuene\", DISPATCH_QUEUE_CONCURRENT);\n\n  dispatch_block_t block = dispatch_block_create(0, ^{\n      NSLog(@\"normal do some thing...\");\n  });\n  dispatch_async(concurrentQuene, block);\n\n  dispatch_block_t qosBlock = dispatch_block_create_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, 0, ^{\n      NSLog(@\"qos do some thing...\");\n  });\n  dispatch_async(concurrentQuene, qosBlock);\n  ```\n\n  ```objective-c\n  LQHelper[1528:112987] qos do some thing...\n  LQHelper[1528:112985] normal do some thing...\n  ```\n\n\n\n\n#### 2 监听 block 执行结束\n\n​\t有时我们需要等待特定的 `block` 执行完成之后，再去执行其他任务。有两种方法可以获取到指定 `block` 执行结束的时机。\n\n- 第一种方式如下：\n\n  ```objective-c\n  long dispatch_block_wait(dispatch_block_t block, dispatch_time_t timeout);\n  ```\n\n  ​\t该函数会阻塞当前线程进行等待。传入需要设置的 block 和等待时间 timeout。timeout 参数表示函数在等待 block 执行完毕时，应该等待多久。如果执行 block 所需的时间小于 timeout，则返回 0，否则返回非 0 值。此参数也可以取常量 `DISPATCH_TIME_FOREVER`，这表示函数会一直等待 block 执行完，而不会超时。可以使用 dispatch_time 函数和 `DISPATCH_TIME_NOW` 常量来方便的设置具体的超时时间。\n\n  ​\t如果 block 执行完成，`dispatch_block_wait` 就会立即返回。不能使用 `dispatch_block_wait` 来等待同一个 block 的多次执行全部结束；这种情况可以考虑使用 `dispatch_group_wait` 来解决。也不能在多个线程中，同时等待同一个 block 的结束。同一个 block 只能执行一次，被等待一次。\n\n  **注意：**因为 `dispatch_block_wait` 会阻塞当前线程，所以不应该放在主线程中调用。\n\n  egg：\n\n  ```objective-c\n  dispatch_queue_t concurrentQuene = dispatch_queue_create(\"concurrentQuene\", DISPATCH_QUEUE_CONCURRENT);\n\n  dispatch_async(concurrentQuene, ^{\n      dispatch_queue_t allTasksQueue = dispatch_queue_create(\"allTasksQueue\", DISPATCH_QUEUE_CONCURRENT);\n\n      dispatch_block_t block = dispatch_block_create(0, ^{\n          NSLog(@\"开始执行\");\n          [NSThread sleepForTimeInterval:3];\n          NSLog(@\"结束执行\");\n      });\n\n      dispatch_async(allTasksQueue, block);\n      // 等待时长，10s 之后超时\n      dispatch_time_t timeout = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10 * NSEC_PER_SEC));\n      long resutl = dispatch_block_wait(block, timeout);\n      if (resutl == 0) {\n          NSLog(@\"执行成功\");\n      } else {\n          NSLog(@\"执行超时\");\n      }\n  });\n  ```\n\n  ```objective-c\n  执行结果：(把上面的sleepForTimeInterval:时间设置成3s)\n  LQHelper[1582:121193] 开始执行\n  LQHelper[1582:121194] 结束执行\n  LQHelper[1582:121193] 执行成功\n  执行结果：(把上面的sleepForTimeInterval:时间设置成12s)\n  LQHelper[1582:121193] 开始执行\n  LQHelper[1582:121194] 执行超时\n  LQHelper[1582:121193] 结束执行\n  ```\n\n- 第二种方法如下：\n\n  ```objective-c\n  void dispatch_block_notify(dispatch_block_t block, dispatch_queue_t queue, dispatch_block_t notification_block);\n  ```\n\n  ​\t该函数接收三个参数，第一个参数是需要监视的 block，第二个参数是监听的 block 执行结束之后要提交执行的队列 queue，第三个参数是待加入到队列中的 block。 和 `dispatch_block_wait` 的不同之处在于：`dispatch_block_notify` 函数不会阻塞当前线程。\n\n  egg：\n\n  ```objective-c\n  NSLog(@\"---- 开始设置任务 ----\");\n  dispatch_queue_t serialQueue =   dispatch_queue_create(\"com.itachi.serialqueue\",   DISPATCH_QUEUE_SERIAL);\n\n  // 耗时任务\n  dispatch_block_t taskBlock = dispatch_block_create(0, ^{\n      NSLog(@\"开始耗时任务\");\n      [NSThread sleepForTimeInterval:2.f];\n      NSLog(@\"完成耗时任务\");\n  });\n\n  dispatch_async(serialQueue, taskBlock);\n\n  // 更新 UI\n  dispatch_block_t refreshUI = dispatch_block_create(0, ^{\n      NSLog(@\"更新 UI\");\n  });\n\n  // 设置监听\n  dispatch_block_notify(taskBlock, dispatch_get_main_queue(), refreshUI);\n  NSLog(@\"---- 完成设置任务 ----\");\n  ```\n\n  ```objective-c\n  执行结果：\n  LQHelper[1615:127135] ---- 开始设置任务 ----\n  LQHelper[1615:127135] ---- 完成设置任务 ----\n  LQHelper[1615:127227] 开始耗时任务\n  LQHelper[1615:127227] 完成耗时任务\n  LQHelper[1615:127135] 更新 UI\n  ```\n\n  ​\n\n#### 3 任务的取消\n\niOS8 后 GCD 支持对 `dispatch block` 的取消。方法如下：\n\n```objective-c\nvoid dispatch_block_cancel(dispatch_block_t block);\n```\n\n​\t这个函数用异步的方式取消指定的 block。取消操作使将来执行 `dispatch block` 立即返回，但是对已经在执行的 `dispatch block` 没有任何影响。当一个 block 被取消时，它会立即释放捕获的资源。如果要在一个 block 中对某些对象进行释放操作，在取消这个 block 的时候，需要确保内存不会泄漏。\n\n```objective-c\ndispatch_queue_t serialQueue = dispatch_queue_create(\"com.itachi.serialqueue\", DISPATCH_QUEUE_SERIAL);\n// 耗时任务\ndispatch_block_t firstTaskBlock = dispatch_block_create(0, ^{\n    NSLog(@\"开始第一个任务\");\n    [NSThread sleepForTimeInterval:1.5f];\n    NSLog(@\"结束第一个任务\");\n});\n\n// 耗时任务\ndispatch_block_t secTaskBlock = dispatch_block_create(0, ^{\n    NSLog(@\"开始第二个任务\");\n    [NSThread sleepForTimeInterval:2.f];\n    NSLog(@\"结束第二个任务\");\n});\n\ndispatch_async(serialQueue, firstTaskBlock);\ndispatch_async(serialQueue, secTaskBlock);\n\n// 等待1s，让第一个任务开始运行\n[NSThread sleepForTimeInterval:1];\n\ndispatch_block_cancel(firstTaskBlock);\nNSLog(@\"尝试过取消第一个任务\");\n\ndispatch_block_cancel(secTaskBlock);\nNSLog(@\"尝试过取消第二个任务\");\n```\n\n```objective-c\n执行结果：\nLQHelper[1645:130881] 开始第一个任务\nLQHelper[1645:130771] 尝试过取消第一个任务\nLQHelper[1645:130771] 尝试过取消第二个任务\nLQHelper[1645:130881] 结束第一个任务\n```\n\n可见 `dispatch_block_cancel` 对已经在执行的任务不起作用，只能取消尚未执行的任务。\n\n转载自[GCD 之任务操作](http://www.jianshu.com/p/5a16dfd36fad)","slug":"GCD 块操作","published":1,"updated":"2017-12-08T09:10:56.780Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb1u1v7g00011us0geytvzmx","content":"<p>​    学习学习dispatch_block，在向队列中添加任务时，可以直接在对应的函数中添加 <code>block</code>。但是如果想对任务进行操作，比如监听任务、取消任务，就需要获取对应的 <code>block</code>。</p>\n<h4 id=\"1-创建Block\"><a href=\"#1-创建Block\" class=\"headerlink\" title=\"1 创建Block\"></a>1 创建Block</h4><ul>\n<li><p>第一种方式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_block_t dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block);</span><br></pre></td></tr></table></figure>\n<p>​    在该函数中，<code>flags</code> 参数用来设置 <code>block</code> 的标记，<code>block</code> 参数用来设置具体的任务。<code>flags</code> 的类型为 <code>dispatch_block_flags_t</code> 的枚举，用于设置 <code>block</code> 的标记，定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DISPATCH_ENUM(dispatch_block_flags, unsigned long,</span><br><span class=\"line\">    DISPATCH_BLOCK_BARRIER = 0x1,</span><br><span class=\"line\">    DISPATCH_BLOCK_DETACHED = 0x2,</span><br><span class=\"line\">    DISPATCH_BLOCK_ASSIGN_CURRENT = 0x4,</span><br><span class=\"line\">    DISPATCH_BLOCK_NO_QOS_CLASS = 0x8,</span><br><span class=\"line\">    DISPATCH_BLOCK_INHERIT_QOS_CLASS = 0x10,</span><br><span class=\"line\">    DISPATCH_BLOCK_ENFORCE_QOS_CLASS = 0x20,</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a></li>\n<li><p>第二种方式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_block_t dispatch_block_create_with_qos_class(dispatch_block_flags_t flags,</span><br><span class=\"line\">    dispatch_qos_class_t qos_class, int relative_priority,</span><br><span class=\"line\">    dispatch_block_t block);</span><br></pre></td></tr></table></figure>\n<p>​    相比于 <code>dispatch_block_create</code> 函数，这种方式在创建 <code>block</code> 的同时可以指定了相应的优先级。<code>dispatch_qos_class_t</code> 是 <code>qos_class_t</code> 的别名，定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#if __has_include(&lt;sys/qos.h&gt;)</span><br><span class=\"line\">typedef qos_class_t dispatch_qos_class_t;</span><br><span class=\"line\">#else</span><br><span class=\"line\">typedef unsigned int dispatch_qos_class_t;</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n<p><code>qos_class_t</code> 是一种枚举，有以下类型：</p>\n<ul>\n<li>QOS_CLASS_USER_INTERACTIVE：<code>user interactive</code> 等级表示任务需要被立即执行，用来在响应事件之后更新 UI，来提供好的用户体验。这个等级最好保持小规模。</li>\n<li>QOS_CLASS_USER_INITIATED：<code>user initiated</code> 等级表示任务由 UI 发起异步执行。适用场景是需要及时，结果同时又可以继续交互的时候。</li>\n<li>QOS_CLASS_DEFAULT：<code>default</code> 默认优先级</li>\n<li>QOS_CLASS_UTILITY：<code>utility</code> 等级表示需要长时间运行的任务，伴有用户可见进度指示器。经常会用来做计算，I/O，网络，持续的数据填充等任务。这个任务节能。</li>\n<li>QOS_CLASS_BACKGROUND：<code>background</code> 等级表示用户不会察觉的任务，使用它来处理预加载，或者不需要用户交互和对时间不敏感的任务。</li>\n<li>QOS_CLASS_UNSPECIFIED：<code>unspecified</code> 未指明</li>\n</ul>\n<p>egg：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t concurrentQuene = dispatch_queue_create(&quot;concurrentQuene&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_block_t block = dispatch_block_create(0, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;normal do some thing...&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_async(concurrentQuene, block);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_block_t qosBlock = dispatch_block_create_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, 0, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;qos do some thing...&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_async(concurrentQuene, qosBlock);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LQHelper[1528:112987] qos do some thing...</span><br><span class=\"line\">LQHelper[1528:112985] normal do some thing...</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2-监听-block-执行结束\"><a href=\"#2-监听-block-执行结束\" class=\"headerlink\" title=\"2 监听 block 执行结束\"></a>2 监听 block 执行结束</h4><p>​    有时我们需要等待特定的 <code>block</code> 执行完成之后，再去执行其他任务。有两种方法可以获取到指定 <code>block</code> 执行结束的时机。</p>\n<ul>\n<li><p>第一种方式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long dispatch_block_wait(dispatch_block_t block, dispatch_time_t timeout);</span><br></pre></td></tr></table></figure>\n<p>​    该函数会阻塞当前线程进行等待。传入需要设置的 block 和等待时间 timeout。timeout 参数表示函数在等待 block 执行完毕时，应该等待多久。如果执行 block 所需的时间小于 timeout，则返回 0，否则返回非 0 值。此参数也可以取常量 <code>DISPATCH_TIME_FOREVER</code>，这表示函数会一直等待 block 执行完，而不会超时。可以使用 dispatch_time 函数和 <code>DISPATCH_TIME_NOW</code> 常量来方便的设置具体的超时时间。</p>\n<p>​    如果 block 执行完成，<code>dispatch_block_wait</code> 就会立即返回。不能使用 <code>dispatch_block_wait</code> 来等待同一个 block 的多次执行全部结束；这种情况可以考虑使用 <code>dispatch_group_wait</code> 来解决。也不能在多个线程中，同时等待同一个 block 的结束。同一个 block 只能执行一次，被等待一次。</p>\n<p><strong>注意：</strong>因为 <code>dispatch_block_wait</code> 会阻塞当前线程，所以不应该放在主线程中调用。</p>\n<p>egg：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t concurrentQuene = dispatch_queue_create(&quot;concurrentQuene&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(concurrentQuene, ^&#123;</span><br><span class=\"line\">    dispatch_queue_t allTasksQueue = dispatch_queue_create(&quot;allTasksQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_block_t block = dispatch_block_create(0, ^&#123;</span><br><span class=\"line\">        NSLog(@&quot;开始执行&quot;);</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:3];</span><br><span class=\"line\">        NSLog(@&quot;结束执行&quot;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_async(allTasksQueue, block);</span><br><span class=\"line\">    // 等待时长，10s 之后超时</span><br><span class=\"line\">    dispatch_time_t timeout = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10 * NSEC_PER_SEC));</span><br><span class=\"line\">    long resutl = dispatch_block_wait(block, timeout);</span><br><span class=\"line\">    if (resutl == 0) &#123;</span><br><span class=\"line\">        NSLog(@&quot;执行成功&quot;);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        NSLog(@&quot;执行超时&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">执行结果：(把上面的sleepForTimeInterval:时间设置成3s)</span><br><span class=\"line\">LQHelper[1582:121193] 开始执行</span><br><span class=\"line\">LQHelper[1582:121194] 结束执行</span><br><span class=\"line\">LQHelper[1582:121193] 执行成功</span><br><span class=\"line\">执行结果：(把上面的sleepForTimeInterval:时间设置成12s)</span><br><span class=\"line\">LQHelper[1582:121193] 开始执行</span><br><span class=\"line\">LQHelper[1582:121194] 执行超时</span><br><span class=\"line\">LQHelper[1582:121193] 结束执行</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第二种方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void dispatch_block_notify(dispatch_block_t block, dispatch_queue_t queue, dispatch_block_t notification_block);</span><br></pre></td></tr></table></figure>\n<p>​    该函数接收三个参数，第一个参数是需要监视的 block，第二个参数是监听的 block 执行结束之后要提交执行的队列 queue，第三个参数是待加入到队列中的 block。 和 <code>dispatch_block_wait</code> 的不同之处在于：<code>dispatch_block_notify</code> 函数不会阻塞当前线程。</p>\n<p>egg：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSLog(@&quot;---- 开始设置任务 ----&quot;);</span><br><span class=\"line\">dispatch_queue_t serialQueue =   dispatch_queue_create(&quot;com.itachi.serialqueue&quot;,   DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">// 耗时任务</span><br><span class=\"line\">dispatch_block_t taskBlock = dispatch_block_create(0, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;开始耗时任务&quot;);</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:2.f];</span><br><span class=\"line\">    NSLog(@&quot;完成耗时任务&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(serialQueue, taskBlock);</span><br><span class=\"line\"></span><br><span class=\"line\">// 更新 UI</span><br><span class=\"line\">dispatch_block_t refreshUI = dispatch_block_create(0, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;更新 UI&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 设置监听</span><br><span class=\"line\">dispatch_block_notify(taskBlock, dispatch_get_main_queue(), refreshUI);</span><br><span class=\"line\">NSLog(@&quot;---- 完成设置任务 ----&quot;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">执行结果：</span><br><span class=\"line\">LQHelper[1615:127135] ---- 开始设置任务 ----</span><br><span class=\"line\">LQHelper[1615:127135] ---- 完成设置任务 ----</span><br><span class=\"line\">LQHelper[1615:127227] 开始耗时任务</span><br><span class=\"line\">LQHelper[1615:127227] 完成耗时任务</span><br><span class=\"line\">LQHelper[1615:127135] 更新 UI</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n<h4 id=\"3-任务的取消\"><a href=\"#3-任务的取消\" class=\"headerlink\" title=\"3 任务的取消\"></a>3 任务的取消</h4><p>iOS8 后 GCD 支持对 <code>dispatch block</code> 的取消。方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void dispatch_block_cancel(dispatch_block_t block);</span><br></pre></td></tr></table></figure>\n<p>​    这个函数用异步的方式取消指定的 block。取消操作使将来执行 <code>dispatch block</code> 立即返回，但是对已经在执行的 <code>dispatch block</code> 没有任何影响。当一个 block 被取消时，它会立即释放捕获的资源。如果要在一个 block 中对某些对象进行释放操作，在取消这个 block 的时候，需要确保内存不会泄漏。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.itachi.serialqueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\">// 耗时任务</span><br><span class=\"line\">dispatch_block_t firstTaskBlock = dispatch_block_create(0, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;开始第一个任务&quot;);</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1.5f];</span><br><span class=\"line\">    NSLog(@&quot;结束第一个任务&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 耗时任务</span><br><span class=\"line\">dispatch_block_t secTaskBlock = dispatch_block_create(0, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;开始第二个任务&quot;);</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:2.f];</span><br><span class=\"line\">    NSLog(@&quot;结束第二个任务&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(serialQueue, firstTaskBlock);</span><br><span class=\"line\">dispatch_async(serialQueue, secTaskBlock);</span><br><span class=\"line\"></span><br><span class=\"line\">// 等待1s，让第一个任务开始运行</span><br><span class=\"line\">[NSThread sleepForTimeInterval:1];</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_block_cancel(firstTaskBlock);</span><br><span class=\"line\">NSLog(@&quot;尝试过取消第一个任务&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_block_cancel(secTaskBlock);</span><br><span class=\"line\">NSLog(@&quot;尝试过取消第二个任务&quot;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">执行结果：</span><br><span class=\"line\">LQHelper[1645:130881] 开始第一个任务</span><br><span class=\"line\">LQHelper[1645:130771] 尝试过取消第一个任务</span><br><span class=\"line\">LQHelper[1645:130771] 尝试过取消第二个任务</span><br><span class=\"line\">LQHelper[1645:130881] 结束第一个任务</span><br></pre></td></tr></table></figure>\n<p>可见 <code>dispatch_block_cancel</code> 对已经在执行的任务不起作用，只能取消尚未执行的任务。</p>\n<p>转载自<a href=\"http://www.jianshu.com/p/5a16dfd36fad\" target=\"_blank\" rel=\"noopener\">GCD 之任务操作</a></p>\n","site":{"data":{}},"excerpt":"<p>​    学习学习dispatch_block，在向队列中添加任务时，可以直接在对应的函数中添加 <code>block</code>。但是如果想对任务进行操作，比如监听任务、取消任务，就需要获取对应的 <code>block</code>。</p>\n<h4 id=\"1-创建Block\"><a href=\"#1-创建Block\" class=\"headerlink\" title=\"1 创建Block\"></a>1 创建Block</h4><ul>\n<li><p>第一种方式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_block_t dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block);</span><br></pre></td></tr></table></figure>\n<p>​    在该函数中，<code>flags</code> 参数用来设置 <code>block</code> 的标记，<code>block</code> 参数用来设置具体的任务。<code>flags</code> 的类型为 <code>dispatch_block_flags_t</code> 的枚举，用于设置 <code>block</code> 的标记，定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DISPATCH_ENUM(dispatch_block_flags, unsigned long,</span><br><span class=\"line\">    DISPATCH_BLOCK_BARRIER = 0x1,</span><br><span class=\"line\">    DISPATCH_BLOCK_DETACHED = 0x2,</span><br><span class=\"line\">    DISPATCH_BLOCK_ASSIGN_CURRENT = 0x4,</span><br><span class=\"line\">    DISPATCH_BLOCK_NO_QOS_CLASS = 0x8,</span><br><span class=\"line\">    DISPATCH_BLOCK_INHERIT_QOS_CLASS = 0x10,</span><br><span class=\"line\">    DISPATCH_BLOCK_ENFORCE_QOS_CLASS = 0x20,</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></li></ul>","more":"\n<li><p>第二种方式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_block_t dispatch_block_create_with_qos_class(dispatch_block_flags_t flags,</span><br><span class=\"line\">    dispatch_qos_class_t qos_class, int relative_priority,</span><br><span class=\"line\">    dispatch_block_t block);</span><br></pre></td></tr></table></figure>\n<p>​    相比于 <code>dispatch_block_create</code> 函数，这种方式在创建 <code>block</code> 的同时可以指定了相应的优先级。<code>dispatch_qos_class_t</code> 是 <code>qos_class_t</code> 的别名，定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#if __has_include(&lt;sys/qos.h&gt;)</span><br><span class=\"line\">typedef qos_class_t dispatch_qos_class_t;</span><br><span class=\"line\">#else</span><br><span class=\"line\">typedef unsigned int dispatch_qos_class_t;</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n<p><code>qos_class_t</code> 是一种枚举，有以下类型：</p>\n<ul>\n<li>QOS_CLASS_USER_INTERACTIVE：<code>user interactive</code> 等级表示任务需要被立即执行，用来在响应事件之后更新 UI，来提供好的用户体验。这个等级最好保持小规模。</li>\n<li>QOS_CLASS_USER_INITIATED：<code>user initiated</code> 等级表示任务由 UI 发起异步执行。适用场景是需要及时，结果同时又可以继续交互的时候。</li>\n<li>QOS_CLASS_DEFAULT：<code>default</code> 默认优先级</li>\n<li>QOS_CLASS_UTILITY：<code>utility</code> 等级表示需要长时间运行的任务，伴有用户可见进度指示器。经常会用来做计算，I/O，网络，持续的数据填充等任务。这个任务节能。</li>\n<li>QOS_CLASS_BACKGROUND：<code>background</code> 等级表示用户不会察觉的任务，使用它来处理预加载，或者不需要用户交互和对时间不敏感的任务。</li>\n<li>QOS_CLASS_UNSPECIFIED：<code>unspecified</code> 未指明</li>\n</ul>\n<p>egg：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t concurrentQuene = dispatch_queue_create(&quot;concurrentQuene&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_block_t block = dispatch_block_create(0, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;normal do some thing...&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_async(concurrentQuene, block);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_block_t qosBlock = dispatch_block_create_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, 0, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;qos do some thing...&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_async(concurrentQuene, qosBlock);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LQHelper[1528:112987] qos do some thing...</span><br><span class=\"line\">LQHelper[1528:112985] normal do some thing...</span><br></pre></td></tr></table></figure>\n</li>\n\n<h4 id=\"2-监听-block-执行结束\"><a href=\"#2-监听-block-执行结束\" class=\"headerlink\" title=\"2 监听 block 执行结束\"></a>2 监听 block 执行结束</h4><p>​    有时我们需要等待特定的 <code>block</code> 执行完成之后，再去执行其他任务。有两种方法可以获取到指定 <code>block</code> 执行结束的时机。</p>\n<ul>\n<li><p>第一种方式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long dispatch_block_wait(dispatch_block_t block, dispatch_time_t timeout);</span><br></pre></td></tr></table></figure>\n<p>​    该函数会阻塞当前线程进行等待。传入需要设置的 block 和等待时间 timeout。timeout 参数表示函数在等待 block 执行完毕时，应该等待多久。如果执行 block 所需的时间小于 timeout，则返回 0，否则返回非 0 值。此参数也可以取常量 <code>DISPATCH_TIME_FOREVER</code>，这表示函数会一直等待 block 执行完，而不会超时。可以使用 dispatch_time 函数和 <code>DISPATCH_TIME_NOW</code> 常量来方便的设置具体的超时时间。</p>\n<p>​    如果 block 执行完成，<code>dispatch_block_wait</code> 就会立即返回。不能使用 <code>dispatch_block_wait</code> 来等待同一个 block 的多次执行全部结束；这种情况可以考虑使用 <code>dispatch_group_wait</code> 来解决。也不能在多个线程中，同时等待同一个 block 的结束。同一个 block 只能执行一次，被等待一次。</p>\n<p><strong>注意：</strong>因为 <code>dispatch_block_wait</code> 会阻塞当前线程，所以不应该放在主线程中调用。</p>\n<p>egg：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t concurrentQuene = dispatch_queue_create(&quot;concurrentQuene&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(concurrentQuene, ^&#123;</span><br><span class=\"line\">    dispatch_queue_t allTasksQueue = dispatch_queue_create(&quot;allTasksQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_block_t block = dispatch_block_create(0, ^&#123;</span><br><span class=\"line\">        NSLog(@&quot;开始执行&quot;);</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:3];</span><br><span class=\"line\">        NSLog(@&quot;结束执行&quot;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_async(allTasksQueue, block);</span><br><span class=\"line\">    // 等待时长，10s 之后超时</span><br><span class=\"line\">    dispatch_time_t timeout = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(10 * NSEC_PER_SEC));</span><br><span class=\"line\">    long resutl = dispatch_block_wait(block, timeout);</span><br><span class=\"line\">    if (resutl == 0) &#123;</span><br><span class=\"line\">        NSLog(@&quot;执行成功&quot;);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        NSLog(@&quot;执行超时&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">执行结果：(把上面的sleepForTimeInterval:时间设置成3s)</span><br><span class=\"line\">LQHelper[1582:121193] 开始执行</span><br><span class=\"line\">LQHelper[1582:121194] 结束执行</span><br><span class=\"line\">LQHelper[1582:121193] 执行成功</span><br><span class=\"line\">执行结果：(把上面的sleepForTimeInterval:时间设置成12s)</span><br><span class=\"line\">LQHelper[1582:121193] 开始执行</span><br><span class=\"line\">LQHelper[1582:121194] 执行超时</span><br><span class=\"line\">LQHelper[1582:121193] 结束执行</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第二种方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void dispatch_block_notify(dispatch_block_t block, dispatch_queue_t queue, dispatch_block_t notification_block);</span><br></pre></td></tr></table></figure>\n<p>​    该函数接收三个参数，第一个参数是需要监视的 block，第二个参数是监听的 block 执行结束之后要提交执行的队列 queue，第三个参数是待加入到队列中的 block。 和 <code>dispatch_block_wait</code> 的不同之处在于：<code>dispatch_block_notify</code> 函数不会阻塞当前线程。</p>\n<p>egg：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSLog(@&quot;---- 开始设置任务 ----&quot;);</span><br><span class=\"line\">dispatch_queue_t serialQueue =   dispatch_queue_create(&quot;com.itachi.serialqueue&quot;,   DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">// 耗时任务</span><br><span class=\"line\">dispatch_block_t taskBlock = dispatch_block_create(0, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;开始耗时任务&quot;);</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:2.f];</span><br><span class=\"line\">    NSLog(@&quot;完成耗时任务&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(serialQueue, taskBlock);</span><br><span class=\"line\"></span><br><span class=\"line\">// 更新 UI</span><br><span class=\"line\">dispatch_block_t refreshUI = dispatch_block_create(0, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;更新 UI&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 设置监听</span><br><span class=\"line\">dispatch_block_notify(taskBlock, dispatch_get_main_queue(), refreshUI);</span><br><span class=\"line\">NSLog(@&quot;---- 完成设置任务 ----&quot;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">执行结果：</span><br><span class=\"line\">LQHelper[1615:127135] ---- 开始设置任务 ----</span><br><span class=\"line\">LQHelper[1615:127135] ---- 完成设置任务 ----</span><br><span class=\"line\">LQHelper[1615:127227] 开始耗时任务</span><br><span class=\"line\">LQHelper[1615:127227] 完成耗时任务</span><br><span class=\"line\">LQHelper[1615:127135] 更新 UI</span><br></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n<h4 id=\"3-任务的取消\"><a href=\"#3-任务的取消\" class=\"headerlink\" title=\"3 任务的取消\"></a>3 任务的取消</h4><p>iOS8 后 GCD 支持对 <code>dispatch block</code> 的取消。方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void dispatch_block_cancel(dispatch_block_t block);</span><br></pre></td></tr></table></figure>\n<p>​    这个函数用异步的方式取消指定的 block。取消操作使将来执行 <code>dispatch block</code> 立即返回，但是对已经在执行的 <code>dispatch block</code> 没有任何影响。当一个 block 被取消时，它会立即释放捕获的资源。如果要在一个 block 中对某些对象进行释放操作，在取消这个 block 的时候，需要确保内存不会泄漏。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.itachi.serialqueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\">// 耗时任务</span><br><span class=\"line\">dispatch_block_t firstTaskBlock = dispatch_block_create(0, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;开始第一个任务&quot;);</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1.5f];</span><br><span class=\"line\">    NSLog(@&quot;结束第一个任务&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 耗时任务</span><br><span class=\"line\">dispatch_block_t secTaskBlock = dispatch_block_create(0, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;开始第二个任务&quot;);</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:2.f];</span><br><span class=\"line\">    NSLog(@&quot;结束第二个任务&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(serialQueue, firstTaskBlock);</span><br><span class=\"line\">dispatch_async(serialQueue, secTaskBlock);</span><br><span class=\"line\"></span><br><span class=\"line\">// 等待1s，让第一个任务开始运行</span><br><span class=\"line\">[NSThread sleepForTimeInterval:1];</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_block_cancel(firstTaskBlock);</span><br><span class=\"line\">NSLog(@&quot;尝试过取消第一个任务&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_block_cancel(secTaskBlock);</span><br><span class=\"line\">NSLog(@&quot;尝试过取消第二个任务&quot;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">执行结果：</span><br><span class=\"line\">LQHelper[1645:130881] 开始第一个任务</span><br><span class=\"line\">LQHelper[1645:130771] 尝试过取消第一个任务</span><br><span class=\"line\">LQHelper[1645:130771] 尝试过取消第二个任务</span><br><span class=\"line\">LQHelper[1645:130881] 结束第一个任务</span><br></pre></td></tr></table></figure>\n<p>可见 <code>dispatch_block_cancel</code> 对已经在执行的任务不起作用，只能取消尚未执行的任务。</p>\n<p>转载自<a href=\"http://www.jianshu.com/p/5a16dfd36fad\" target=\"_blank\" rel=\"noopener\">GCD 之任务操作</a></p>"},{"title":"Android Studio gradle","date":"2017-11-30T12:06:00.000Z","_content":"\n#### Android Studio gradle离线包gradle-x.x-all.zip离线配置路径问题详细解决步骤\n\n升级AndroidStudio 到3.0以后新建项目突然一直卡在了building… ，网上说的路径也不清晰，经过各种尝试，终于找到解决办法\n\n一、找到gradle文件夹路径：\n\nWindows系统在 C:\\Users\\Administrator\\.gradle\nMac OS是在：用户/(当前用户目录)/.gradle\n\n**注意**：Mac OS下默认以点开头的目录都不显示，显示方法：\n\n```objective-c\ndefaults write com.apple.finder AppleShowAllFiles -bool true;\nKillAll Finder\n```\n\n下载本地gradle文件：[gradle-4.1-all.zip][a](密码: wxrb)、[gradle-4.1-all.zip][b](密码: k5gc)。\n\n[a]: https://pan.baidu.com/s/1pLIDhAr  \"Optional Title Here\"\n[b]: https://pan.baidu.com/s/1mixK0YG  \"Optional Title Here\"\n\n<!--more -->\n\n二、下载之后，打开一个Android项目\n\n​\t找到项目下面的gradle/wrapper/gradle-wrapper.properties，打开，修改distributionUrl后面的gradle版本为下载好的本地的gradle版本，比如http\\://services.gradle.org/distributions/gradle-4.1-all.zip，\n\n​\t把刚才下载的包放到：用户/(当前用户目录)/.gradle/wrapper/dists/gradle-x.x-all/5wdhop0rtjyqx8wdt9x1nljp5(此处为文件夹名，可能不一样，一长串字母数字的文件夹)\n\n​\t然后将你下载的离线的gradle-x.x-all.zip放在这个数字字母组合的目录下即可（不需要解压！！！），重启Android Studio后，新建项目即可，嗖嗖嗖的就构建好了。\n\n​\t**注意**：x.x为你下载的gradle版本，在终端弄了以后要注意！可能需要强制退出Finder后重新启动才可以生效！！！\n\n\n\n","source":"_posts/AndroidStudio-gradle.md","raw":"---\ntitle: Android Studio gradle \ndate: 2017-11-30 20:06\ntags: Android\ncategories: 初识Android\n---\n\n#### Android Studio gradle离线包gradle-x.x-all.zip离线配置路径问题详细解决步骤\n\n升级AndroidStudio 到3.0以后新建项目突然一直卡在了building… ，网上说的路径也不清晰，经过各种尝试，终于找到解决办法\n\n一、找到gradle文件夹路径：\n\nWindows系统在 C:\\Users\\Administrator\\.gradle\nMac OS是在：用户/(当前用户目录)/.gradle\n\n**注意**：Mac OS下默认以点开头的目录都不显示，显示方法：\n\n```objective-c\ndefaults write com.apple.finder AppleShowAllFiles -bool true;\nKillAll Finder\n```\n\n下载本地gradle文件：[gradle-4.1-all.zip][a](密码: wxrb)、[gradle-4.1-all.zip][b](密码: k5gc)。\n\n[a]: https://pan.baidu.com/s/1pLIDhAr  \"Optional Title Here\"\n[b]: https://pan.baidu.com/s/1mixK0YG  \"Optional Title Here\"\n\n<!--more -->\n\n二、下载之后，打开一个Android项目\n\n​\t找到项目下面的gradle/wrapper/gradle-wrapper.properties，打开，修改distributionUrl后面的gradle版本为下载好的本地的gradle版本，比如http\\://services.gradle.org/distributions/gradle-4.1-all.zip，\n\n​\t把刚才下载的包放到：用户/(当前用户目录)/.gradle/wrapper/dists/gradle-x.x-all/5wdhop0rtjyqx8wdt9x1nljp5(此处为文件夹名，可能不一样，一长串字母数字的文件夹)\n\n​\t然后将你下载的离线的gradle-x.x-all.zip放在这个数字字母组合的目录下即可（不需要解压！！！），重启Android Studio后，新建项目即可，嗖嗖嗖的就构建好了。\n\n​\t**注意**：x.x为你下载的gradle版本，在终端弄了以后要注意！可能需要强制退出Finder后重新启动才可以生效！！！\n\n\n\n","slug":"AndroidStudio-gradle","published":1,"updated":"2017-12-05T10:38:52.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb1u1v7j00031us0iwff964o","content":"<h4 id=\"Android-Studio-gradle离线包gradle-x-x-all-zip离线配置路径问题详细解决步骤\"><a href=\"#Android-Studio-gradle离线包gradle-x-x-all-zip离线配置路径问题详细解决步骤\" class=\"headerlink\" title=\"Android Studio gradle离线包gradle-x.x-all.zip离线配置路径问题详细解决步骤\"></a>Android Studio gradle离线包gradle-x.x-all.zip离线配置路径问题详细解决步骤</h4><p>升级AndroidStudio 到3.0以后新建项目突然一直卡在了building… ，网上说的路径也不清晰，经过各种尝试，终于找到解决办法</p>\n<p>一、找到gradle文件夹路径：</p>\n<p>Windows系统在 C:\\Users\\Administrator.gradle<br>Mac OS是在：用户/(当前用户目录)/.gradle</p>\n<p><strong>注意</strong>：Mac OS下默认以点开头的目录都不显示，显示方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">defaults write com.apple.finder AppleShowAllFiles -bool true;</span><br><span class=\"line\">KillAll Finder</span><br></pre></td></tr></table></figure>\n<p>下载本地gradle文件：<a href=\"https://pan.baidu.com/s/1pLIDhAr\" title=\"Optional Title Here\" target=\"_blank\" rel=\"noopener\">gradle-4.1-all.zip</a>(密码: wxrb)、<a href=\"https://pan.baidu.com/s/1mixK0YG\" title=\"Optional Title Here\" target=\"_blank\" rel=\"noopener\">gradle-4.1-all.zip</a>(密码: k5gc)。</p>\n<a id=\"more\"></a>\n<p>二、下载之后，打开一个Android项目</p>\n<p>​    找到项目下面的gradle/wrapper/gradle-wrapper.properties，打开，修改distributionUrl后面的gradle版本为下载好的本地的gradle版本，比如http\\://services.gradle.org/distributions/gradle-4.1-all.zip，</p>\n<p>​    把刚才下载的包放到：用户/(当前用户目录)/.gradle/wrapper/dists/gradle-x.x-all/5wdhop0rtjyqx8wdt9x1nljp5(此处为文件夹名，可能不一样，一长串字母数字的文件夹)</p>\n<p>​    然后将你下载的离线的gradle-x.x-all.zip放在这个数字字母组合的目录下即可（不需要解压！！！），重启Android Studio后，新建项目即可，嗖嗖嗖的就构建好了。</p>\n<p>​    <strong>注意</strong>：x.x为你下载的gradle版本，在终端弄了以后要注意！可能需要强制退出Finder后重新启动才可以生效！！！</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"Android-Studio-gradle离线包gradle-x-x-all-zip离线配置路径问题详细解决步骤\"><a href=\"#Android-Studio-gradle离线包gradle-x-x-all-zip离线配置路径问题详细解决步骤\" class=\"headerlink\" title=\"Android Studio gradle离线包gradle-x.x-all.zip离线配置路径问题详细解决步骤\"></a>Android Studio gradle离线包gradle-x.x-all.zip离线配置路径问题详细解决步骤</h4><p>升级AndroidStudio 到3.0以后新建项目突然一直卡在了building… ，网上说的路径也不清晰，经过各种尝试，终于找到解决办法</p>\n<p>一、找到gradle文件夹路径：</p>\n<p>Windows系统在 C:\\Users\\Administrator.gradle<br>Mac OS是在：用户/(当前用户目录)/.gradle</p>\n<p><strong>注意</strong>：Mac OS下默认以点开头的目录都不显示，显示方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">defaults write com.apple.finder AppleShowAllFiles -bool true;</span><br><span class=\"line\">KillAll Finder</span><br></pre></td></tr></table></figure>\n<p>下载本地gradle文件：<a href=\"https://pan.baidu.com/s/1pLIDhAr\" title=\"Optional Title Here\" target=\"_blank\" rel=\"noopener\">gradle-4.1-all.zip</a>(密码: wxrb)、<a href=\"https://pan.baidu.com/s/1mixK0YG\" title=\"Optional Title Here\" target=\"_blank\" rel=\"noopener\">gradle-4.1-all.zip</a>(密码: k5gc)。</p>","more":"<p>二、下载之后，打开一个Android项目</p>\n<p>​    找到项目下面的gradle/wrapper/gradle-wrapper.properties，打开，修改distributionUrl后面的gradle版本为下载好的本地的gradle版本，比如http\\://services.gradle.org/distributions/gradle-4.1-all.zip，</p>\n<p>​    把刚才下载的包放到：用户/(当前用户目录)/.gradle/wrapper/dists/gradle-x.x-all/5wdhop0rtjyqx8wdt9x1nljp5(此处为文件夹名，可能不一样，一长串字母数字的文件夹)</p>\n<p>​    然后将你下载的离线的gradle-x.x-all.zip放在这个数字字母组合的目录下即可（不需要解压！！！），重启Android Studio后，新建项目即可，嗖嗖嗖的就构建好了。</p>\n<p>​    <strong>注意</strong>：x.x为你下载的gradle版本，在终端弄了以后要注意！可能需要强制退出Finder后重新启动才可以生效！！！</p>"},{"title":"GCD学习 —— 一","date":"2017-12-06T11:06:00.000Z","_content":"\n####  1、什么是GCD\n\n>Grand Central Dispatch (GCD) 是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并行任务。在Mac OS X 10.6雪豹中首次推出，也可在iOS 4及以上版本使用。(百度百科)\n\nGCD的好处：\n- GCD可用于多核的并行运算\n- GCD会自动利用更多的CPU内核（比如双核、四核）\n- GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）\n- 只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码\n  <!-- more -->\n\n####  2、任务和队列\n学习GCD之前，先来了解GCD中两个核心概念：任务和队列。\n\n**任务：**就是执行操作的意思，换句话说就是需要在线程中执行的那段代码。\n\n执行任务有两种方式：**同步执行和异步执行**。两者的主要区别是：**是否具备开启新线程的能力**。\n\n- 同步执行(sync)：只能在当前线程中执行任务，不具备开启新线程的能力。\n- 异步执行(async)：可以在新的线程中执行任务，具备开启新线程的能力。\n\n**队列：**这里的队列指任务队列，即用来存放任务的队列。队列是一种特殊的线性表，采用FIFO(先进先出)的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。在GCD中有两种队列：**串行队列和并行队列**。\n\n- 串行队列(Serial Dispatch Queue)：让任务一个接一个的执行(一个任务执行完毕，再执行下一个任务)。\n- 并行队列(Concurrent Dispatch Queue)：可以让多个任务并行(同时)执行(自动开启多个线程同时执行任务)。\n\n\n####  3、GCD的使用步骤\n\n​\t1、创建一个队列(串行或者并行队列)\n\n​\t2、将任务添加到队列中，然后系统就会根据任务类型执行任务(同步执行或者异步执行)\n\n#####  3.1 队列的创建方法\n\n​\t可以使用`dispatch_queue_create`来创建对象，需要传入两个参数，第一个参数表示队列的唯一标识符，用于DEBUG，可以为空；第二个参数是用来识别是串行队列还是并行队列。`DISPATCH_QUEUE_SERIAL`表示串行队列，`DISPATCH_QUEUE_CONCURRENT`表示并行队列。\n\n```objective-c\n// 串行队列的创建方法\ndispatch_queue_t queue = dispatch_queue_create(\"test.queue\", DISPATCH_QUEUE_SERIAL);\n// 并行队列的创建方法\ndispatch_queue_t queue = dispatch_queue_create(\"test.queue\", DISPATCH_QUEUE_CONCURRENT);\n```\n\n​\t对于并行队列，还可以使用   `dispatch_get_global_queue`来创建**全局并行队列**。GCD默认提供了全局的并行队列，需要传入两个参数。第一个参数表示队列优先级，一般用`DISPATCH_QUEUE_PRIORITY_DEFAULT`。第二个参数暂时没用，用`0`即可。\n\n\n\n##### 3.2 任务的创建方法\n\n```objective-c\n// 同步执行任务创建方法\ndispatch_sync(queue, ^{\n    NSLog(@\"%@\",[NSThread currentThread]);    // 这里放任务代码\n});\n// 异步执行任务创建方法\ndispatch_async(queue, ^{\n    NSLog(@\"%@\",[NSThread currentThread]);    // 这里放任务代码\n});\n```\n\n虽然使用GCD只需两步，但是既然我们有两种队列，两种任务执行方式，那么我们就有了四种不同的组合方式。这四种不同的组合方式是：\n\n>1. 并行队列 + 同步执行\n>2. 并行队列 + 异步执行\n>3. 串行队列 + 同步执行\n>4. 串行队列 + 异步执行\n\n实际上，我们还有一种特殊队列是主队列，那样就有六种不同的组合方式了。\n\n>5. 主队列 + 同步执行\n>6. 主队列 + 异步执行\n\n那么这几种不同组合方式各有什么区别呢，这里为了方便，先上结果，再来讲解。直接查看表格结果。\n\n|           |      并行队列      |       串行队列        |      主队列       |\n| :-------: | :------------: | :---------------: | :------------: |\n| 同步(sync)  | 没有开启新线程，串行执行任务 |  没有开启新线程，串行执行任务   | 没有开启新线程，串行执行任务 |\n| 异步(async) | 有开启新线程，并行执行任务  | 有开启新线程(1条)，并行执行任务 | 没有开启新线程，串行执行任务 |\n\n下边我们来分别讲讲这几种不同的组合方式的使用方法。\n\n\n\n####  4、GCD的基本使用\n\n#####  4.1 并行队列的两种使用方法\n\n######  4.1.1 并行队列 + 同步执行\n\n- 不会开启新线程，执行完一个任务，再执行下一个任务\n    ```objective-c\n    - (void) syncConcurrent\n    {\n        NSLog(@\"syncConcurrent---begin\");\n\n        dispatch_queue_t queue= dispatch_queue_create(\"test.queue\", DISPATCH_QUEUE_CONCURRENT);\n\n        dispatch_sync(queue, ^{\n            for (int i = 0; i < 2; ++i) {\n                NSLog(@\"1------%@\",[NSThread currentThread]);\n            }\n        });\n        dispatch_sync(queue, ^{\n            for (int i = 0; i < 2; ++i) {\n                NSLog(@\"2------%@\",[NSThread currentThread]);\n            }\n        });\n        dispatch_sync(queue, ^{\n            for (int i = 0; i < 2; ++i) {\n                NSLog(@\"3------%@\",[NSThread currentThread]);\n            }\n        });\n        \n        NSLog(@\"syncConcurrent---end\");\n    }\n    ```\n\n    ```objective-c\n    输出结果：\n    GCD[11557:1897538] syncConcurrent---begin\n    GCD[11557:1897538] 1------<NSThread: 0x7f82a1d058b0>{number = 1, name = main}\n    GCD[11557:1897538] 1------<NSThread: 0x7f82a1d058b0>{number = 1, name = main}\n    GCD[11557:1897538] 2------<NSThread: 0x7f82a1d058b0>{number = 1, name = main}\n    GCD[11557:1897538] 2------<NSThread: 0x7f82a1d058b0>{number = 1, name = main}\n    GCD[11557:1897538] 3------<NSThread: 0x7f82a1d058b0>{number = 1, name = main}\n    GCD[11557:1897538] 3------<NSThread: 0x7f82a1d058b0>{number = 1, name = main}\n    GCD[11557:1897538] syncConcurrent---end\n    ```\n\n- 从`并行队列 + 同步执行`中可以看到，所有任务都是在主线程中执行的。由于只有一个线程，所以任务只能一个一个执行。\n- 同时我们还可以看到，所有任务都在打印的`syncConcurrent---begin`和`syncConcurrent---end`之间，这说明任务是添加到队列中马上执行的。\n\n\n\n######  4.1.2 并行队列 + 异步步执行\n\n- 可同时开启多线程，任务交替执行\n\n    ```objective-c\n    - (void) asyncConcurrent\n      {\n        NSLog(@\"asyncConcurrent---begin\");\n\n        dispatch_queue_t queue= dispatch_queue_create(\"test.queue\", DISPATCH_QUEUE_CONCURRENT);\n\n        dispatch_async(queue, ^{\n            for (int i = 0; i < 2; ++i) {\n                NSLog(@\"1------%@\",[NSThread currentThread]);\n            }\n        });\n        dispatch_async(queue, ^{\n            for (int i = 0; i < 2; ++i) {\n                NSLog(@\"2------%@\",[NSThread currentThread]);\n            }\n        });\n        dispatch_async(queue, ^{\n            for (int i = 0; i < 2; ++i) {\n                NSLog(@\"3------%@\",[NSThread currentThread]);\n            }\n        });\n\n        NSLog(@\"asyncConcurrent---end\");\n      }\n    ```\n\n    ```objective-c\n    输出结果：\n    GCD[11595:1901548] asyncConcurrent---begin\n    GCD[11595:1901548] asyncConcurrent---end\n    GCD[11595:1901626] 1------<NSThread: 0x7f8309c22080>{number = 2, name = (null)}\n    GCD[11595:1901625] 2------<NSThread: 0x7f8309f0b790>{number = 4, name = (null)}\n    GCD[11595:1901855] 3------<NSThread: 0x7f8309e1a950>{number = 3, name = (null)}\n    GCD[11595:1901626] 1------<NSThread: 0x7f8309c22080>{number = 2, name = (null)}\n    GCD[11595:1901625] 2------<NSThread: 0x7f8309f0b790>{number = 4, name = (null)}\n    GCD[11595:1901855] 3------<NSThread: 0x7f8309e1a950>{number = 3, name = (null)}\n    ```\n- 在`并行队列 + 异步执行`中可以看出，除了主线程，又开启了3个线程，并且任务是交替着同时执行的。\n- 另一方面可以看出，所有任务是在打印的`syncConcurrent—begin`和`syncConcurrent—end`之后才开始执行的。说明任务不是马上执行，而是将所有任务添加到队列之后才开始异步执行。\n\n#####  4.2 串行队列的两种使用方法\n\n######  4.2.1 串行队列 + 同步执行\n\n- 不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务\n\n  ```objective-c\n  - (void) syncSerial\n  {\n      NSLog(@\"syncSerial---begin\");\n\n      dispatch_queue_t queue = dispatch_queue_create(\"test.queue\", DISPATCH_QUEUE_SERIAL);\n\n      dispatch_sync(queue, ^{\n          for (int i = 0; i < 2; ++i) {\n              NSLog(@\"1------%@\",[NSThread currentThread]);\n          }\n      });    \n      dispatch_sync(queue, ^{\n          for (int i = 0; i < 2; ++i) {\n              NSLog(@\"2------%@\",[NSThread currentThread]);\n          }\n      });\n      dispatch_sync(queue, ^{\n          for (int i = 0; i < 2; ++i) {\n              NSLog(@\"3------%@\",[NSThread currentThread]);\n          }\n      });\n\n      NSLog(@\"syncSerial---end\");\n  }\n  ```\n\n  ```objective-c\n  输出结果为：\n  GCD[11622:1903904] syncSerial---begin\n  GCD[11622:1903904] 1------<NSThread: 0x7fa2e9f00980>{number = 1, name = main}\n  GCD[11622:1903904] 1------<NSThread: 0x7fa2e9f00980>{number = 1, name = main}\n  GCD[11622:1903904] 2------<NSThread: 0x7fa2e9f00980>{number = 1, name = main}\n  GCD[11622:1903904] 2------<NSThread: 0x7fa2e9f00980>{number = 1, name = main}\n  GCD[11622:1903904] 3------<NSThread: 0x7fa2e9f00980>{number = 1, name = main}\n  GCD[11622:1903904] 3------<NSThread: 0x7fa2e9f00980>{number = 1, name = main}\n  GCD[11622:1903904] syncSerial---end\n  ```\n\n\n  - 在`串行队列 + 同步执行`可以看到，所有任务都是在主线程中执行的，并没有开启新的线程。而且由于串行队列，所以按顺序一个一个执行。\n  - 同时我们还可以看到，所有任务都在打印的`syncConcurrent—begin`和`syncConcurrent—end`之间，这说明任务是添加到队列中马上执行的。\n\n######  4.2.2 串行队列 + 异步执行\n\n- 会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务\n\n  ```objective-c\n  - (void) asyncSerial\n  {\n      NSLog(@\"asyncSerial---begin\");\n\n      dispatch_queue_t queue = dispatch_queue_create(\"test.queue\", DISPATCH_QUEUE_SERIAL);\n\n      dispatch_async(queue, ^{\n          for (int i = 0; i < 2; ++i) {\n              NSLog(@\"1------%@\",[NSThread currentThread]);\n          }\n      });    \n      dispatch_async(queue, ^{\n          for (int i = 0; i < 2; ++i) {\n              NSLog(@\"2------%@\",[NSThread currentThread]);\n          }\n      });\n      dispatch_async(queue, ^{\n          for (int i = 0; i < 2; ++i) {\n              NSLog(@\"3------%@\",[NSThread currentThread]);\n          }\n      });\n\n      NSLog(@\"asyncSerial---end\");\n  }\n  ```\n\n  ```objective-c\n  输出结果为：\n  GCD[11648:1905817] asyncSerial---begin\n  GCD[11648:1905817] asyncSerial---end\n  GCD[11648:1905895] 1------<NSThread: 0x7fb548c0e390>{number = 2, name = (null)}\n  GCD[11648:1905895] 1------<NSThread: 0x7fb548c0e390>{number = 2, name = (null)}\n  GCD[11648:1905895] 2------<NSThread: 0x7fb548c0e390>{number = 2, name = (null)}\n  GCD[11648:1905895] 2------<NSThread: 0x7fb548c0e390>{number = 2, name = (null)}\n  GCD[11648:1905895] 3------<NSThread: 0x7fb548c0e390>{number = 2, name = (null)}\n  GCD[11648:1905895] 3------<NSThread: 0x7fb548c0e390>{number = 2, name = (null)}\n  ```\n\n\n- 在`串行队列 + 异步执行`可以看到，开启了一条新线程，但是任务还是串行，所以任务是一个一个执行。\n- 另一方面可以看出，所有任务是在打印的`syncConcurrent---begin`和`syncConcurrent---end`之后才开始执行的。说明任务不是马上执行，而是将所有任务添加到队列之后才开始同步执行。\n\n\n##### 4.3 主队列\n\n- 主队列：GCD自带的一种特殊的**串行队列**\n  - 所有放在主队列中的任务，都会放到主线程中执行\n  - 可使用`dispatch_get_main_queue()`获得主队列\n\n###### 4.3.1 主队列 + 同步执行\n\n- 互等卡住不可行(在主线程中调用)\n    ```objective-c\n    - (void)syncMain\n    {\n        NSLog(@\"syncMain---begin\");\n\n        dispatch_queue_t queue = dispatch_get_main_queue();\n\n        dispatch_sync(queue, ^{\n            for (int i = 0; i < 2; ++i) {\n                NSLog(@\"1------%@\",[NSThread currentThread]);\n            }\n        });\n        dispatch_sync(queue, ^{\n            for (int i = 0; i < 2; ++i) {\n                NSLog(@\"2------%@\",[NSThread currentThread]);\n            }\n        });\n        dispatch_sync(queue, ^{\n            for (int i = 0; i < 2; ++i) {\n                NSLog(@\"3------%@\",[NSThread currentThread]);\n            }\n        });   \n\n        NSLog(@\"syncMain---end\");\n    }\n    ```\n    ```objective-c\n    输出结果\n    2016-09-03 19:32:15.356 GCD[11670:1908306] syncMain---begin\n    ```\n\n- 这时候，我们惊奇的发现，在主线程中使用主队列 + 同步执行，任务不再执行了，而且syncMain---end也没有打印。这是为什么呢？\n\n- 这是因为我们在主线程中执行这段代码。我们把任务放到了主队列中，也就是放到了主线程的队列中。而同步执行有个特点，就是对于任务是立马执行的。那么当我们把第一个任务放进主队列中，它就会立马执行。但是主线程现在正在处理syncMain方法，所以任务需要等syncMain执行完才能执行。而syncMain执行到第一个任务的时候，又要等第一个任务执行完才能往下执行第二个和第三个任务。\n\n- 那么，现在的情况就是`syncMain`方法和第一个任务都在等对方执行完毕。这样大家互相等待，所以就卡住了，所以我们的任务执行不了，而且`syncMain---end`也没有打印。\n\n    **要是如果不再主线程中调用，而在其他线程中调用会如何呢？**\n\n- 不会开启新线程，执行完一个任务，再执行下一个任务（在其他线程中调用）\n\n    ```objective-c\n    dispatch_queue_t queue = dispatch_queue_create(\"test.queue\", DISPATCH_QUEUE_CONCURRENT);\n\n    dispatch_async(queue, ^{\n        [self syncMain];\n    });\n    ```\n\n    ```objective-c\n    输出结果：\n    GCD[11686:1909617] syncMain---begin\n    GCD[11686:1909374] 1------<NSThread: 0x7faef2f01600>{number = 1, name = main}\n    GCD[11686:1909374] 1------<NSThread: 0x7faef2f01600>{number = 1, name = main}\n    GCD[11686:1909374] 2------<NSThread: 0x7faef2f01600>{number = 1, name = main}\n    GCD[11686:1909374] 2------<NSThread: 0x7faef2f01600>{number = 1, name = main}\n    GCD[11686:1909374] 3------<NSThread: 0x7faef2f01600>{number = 1, name = main}\n    GCD[11686:1909374] 3------<NSThread: 0x7faef2f01600>{number = 1, name = main}\n    GCD[11686:1909617] syncMain---end\n    ```\n\n- 在其他线程中使用`主队列 + 同步执行`可看到：所有任务都是在主线程中执行的，并没有开启新的线程。而且由于主队列是串行队列，所以按顺序一个一个执行。\n\n\n- 同时我们还可以看到，所有任务都在打印的syncConcurrent---begin和syncConcurrent---end之间，这说明任务是添加到队列中马上执行的。\n\n###### 4.3.2 主队列 + 异步执行\n\n- 只在主线程中执行任务，执行完一个任务，再执行下一个任务\n\n  ```objective-c\n  - (void)asyncMain\n  {\n      NSLog(@\"asyncMain---begin\");\n\n      dispatch_queue_t queue = dispatch_get_main_queue();\n      \n      dispatch_async(queue, ^{\n          for (int i = 0; i < 2; ++i) {\n              NSLog(@\"1------%@\",[NSThread currentThread]);\n          }\n      });    \n      dispatch_async(queue, ^{\n          for (int i = 0; i < 2; ++i) {\n              NSLog(@\"2------%@\",[NSThread currentThread]);\n          }\n      });\n      dispatch_async(queue, ^{\n          for (int i = 0; i < 2; ++i) {\n              NSLog(@\"3------%@\",[NSThread currentThread]);\n          }\n      });  \n\n      NSLog(@\"asyncMain---end\");\n  }\n  ```\n\n  ```objective-c\n  输出结果：\n  GCD[11706:1911313] asyncMain---begin\n  GCD[11706:1911313] asyncMain---end\n  GCD[11706:1911313] 1------<NSThread: 0x7fb623d015e0>{number = 1, name = main}\n  GCD[11706:1911313] 1------<NSThread: 0x7fb623d015e0>{number = 1, name = main}\n  GCD[11706:1911313] 2------<NSThread: 0x7fb623d015e0>{number = 1, name = main}\n  GCD[11706:1911313] 2------<NSThread: 0x7fb623d015e0>{number = 1, name = main}\n  GCD[11706:1911313] 3------<NSThread: 0x7fb623d015e0>{number = 1, name = main}\n  GCD[11706:1911313] 3------<NSThread: 0x7fb623d015e0>{number = 1, name = main}\n  ```\n\n\n- 我们发现所有任务都在主线程中，虽然是异步执行，具备开启线程的能力，但因为是主队列，所以所有任务都在主线程中，并且一个接一个执行。\n- 另一方面可以看出，所有任务是在打印的`syncConcurrent---begin`和`syncConcurrent---end`之后才开始执行的。说明任务不是马上执行，而是将所有任务添加到队列之后才开始同步执行。\n\n\n\n#### 5. GCD线程之间的通讯\n\n​\t在iOS开发过程中，我们一般在主线程里边进行UI刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。\n\n```objective-c\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    for (int i = 0; i < 2; ++i) {\n        NSLog(@\"1------%@\",[NSThread currentThread]);\n    }\n\n    // 回到主线程\n    dispatch_async(dispatch_get_main_queue(), ^{\n        NSLog(@\"2------%@\",[NSThread currentThread]);\n    });\n});\n```\n\n```objective-c\n输出结果：\nGCD[11728:1913039] 1------<NSThread: 0x7f8319c06820>{number = 2, name = (null)}\nGCD[11728:1913039] 1------<NSThread: 0x7f8319c06820>{number = 2, name = (null)}\nGCD[11728:1912961] 2------<NSThread: 0x7f8319e00560>{number = 1, name = main}\n```\n- 可以看到在其他线程中先执行操作，执行完了之后回到主线程执行主线程的相应操作。\n\n\n#### 6. GCD的其他方法\n\n##### 6.1 GCD的栅栏方法 `dispatch_barrier_async`\n\n- 我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于栅栏一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到dispatch_barrier_async方法在两个操作组间形成栅栏。\n\n  ```objective-c\n  - (void)barrier\n  {\n      dispatch_queue_t queue = dispatch_queue_create(\"12312312\", DISPATCH_QUEUE_CONCURRENT);\n\n      dispatch_async(queue, ^{\n          NSLog(@\"----1-----%@\", [NSThread currentThread]);\n      });\n      dispatch_async(queue, ^{\n          NSLog(@\"----2-----%@\", [NSThread currentThread]);\n      });\n\n      dispatch_barrier_async(queue, ^{\n          NSLog(@\"---barrier%@\", [NSThread currentThread]);\n      });\n\n      dispatch_async(queue, ^{\n          NSLog(@\"----3-----%@\", [NSThread currentThread]);\n      });\n      dispatch_async(queue, ^{\n          NSLog(@\"----4-----%@\", [NSThread currentThread]);\n      });\n  }\n  ```\n\n  ```objective-c\n  输出结果：\n  GCD[11750:1914724] ----1-----<NSThread: 0x7fb1826047b0>{number = 2, name = (null)}\n  GCD[11750:1914722] ----2-----<NSThread: 0x7fb182423fd0>{number = 3, name = (null)}\n  GCD[11750:1914722] ---barrier<NSThread: 0x7fb182423fd0>{number = 3, name = (null)}\n  GCD[11750:1914722] ----3-----<NSThread: 0x7fb182423fd0>{number = 3, name = (null)}\n  GCD[11750:1914724] ----4-----<NSThread: 0x7fb1826047b0>{number = 2, name = (null)}\n  ```\n\n- 可以看出在执行完栅栏前面的操作之后，才执行栅栏操作，最后再执行栅栏后边的操作。\n\n##### 6.2 GCD的延时执行方法 `dispatch_after`\n\n- 当我们需要延迟执行一段代码时，就需要用到GCD的`dispatch_after`方法。\n\n- `dispatch_after`能让我们添加进队列的任务延时执行，比如想让一个Block在2秒后执行：\n\n  ```objective-c\n  dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC));\n  dispatch_after(time, dispatch_get_main_queue(), ^{\n      // 2秒后异步执行这里的代码...\n     NSLog(@\"run-----\");\n  });\n  ```\n\n  `NSEC_PER_SEC`表示的是秒数，它还提供了`NSEC_PER_MSEC`表示毫秒。\n\n  上面这句`dispatch_after`的真正含义是在2秒后把任务添加进队列中，并不是表示在2秒后执行，大部分情况该函数能达到我们的预期，只有在对时间要求非常精准的情况下才可能会出现问题。\n\n  获取一个`dispatch_time_t`类型的值可以通过两种方式来获取，以上是第一种方式，即通过`dispatch_time`函数，另一种是通过`dispatch_walltime`函数来获取，`dispatch_walltime`需要使用一个timespec的结构体来得到`dispatch_time_t`。通常`dispatch_time`用于计算相对时间，`dispatch_walltime`用于计算绝对时间\n\n##### 6.3 GCD的一次性代码(只执行一次) `dispatch_once`\n\n- 我们在创建单例、或者有整个程序运行过程中只执行一次的代码时，我们就用到了GCD的`dispatch_once`方法。使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次。\n\n  ```objective-c\n  static dispatch_once_t onceToken;\n  dispatch_once(&onceToken, ^{\n      // 只执行1次的代码(这里面默认是线程安全的)\n  });\n  ```\n\n##### 6.4 GCD的快速迭代方法 `dispatch_apply`\n\n- 通常我们会用for循环遍历，但是GCD给我们提供了快速迭代的方法`dispatch_apply`，使我们可以同时遍历。比如说遍历0~5这6个数字，for循环的做法是每次取出一个元素，逐个遍历。`dispatch_apply`可以同时遍历多个数字。\n\n  ```objective-c\n  dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n\n  dispatch_apply(6, queue, ^(size_t index) {\n      NSLog(@\"%zd------%@\",index, [NSThread currentThread]);\n  });\n  ```\n\n  ```objective-c\n  输出结果：\n  GCD[11764:1915764] 1------<NSThread: 0x7fac9a7029e0>{number = 1, name = main}\n  GCD[11764:1915885] 0------<NSThread: 0x7fac9a614bd0>{number = 2, name = (null)}\n  GCD[11764:1915886] 2------<NSThread: 0x7fac9a542b20>{number = 3, name = (null)}\n  GCD[11764:1915764] 4------<NSThread: 0x7fac9a7029e0>{number = 1, name = main}\n  GCD[11764:1915884] 3------<NSThread: 0x7fac9a76ca10>{number = 4, name = (null)}\n  GCD[11764:1915885] 5------<NSThread: 0x7fac9a614bd0>{number = 2, name = (null)}\n  ```\n\n- 从输出结果中前边的时间中可以看出，几乎是同时遍历的。\n\n##### 6.5 GCD的队列组 `dispatch_group`\n\n- 有时候我们会有这样的需求：分别异步执行2个耗时操作，然后当2个耗时操作都执行完毕后再回到主线程执行操作。这时候我们可以用到GCD的队列组。\n\n  - 我们可以先把任务放到队列中，然后将队列放入队列组中。()\n  - 调用队列组的`dispatch_group_notify`回到主线程执行操作。\n\n  ```objective-c\n  dispatch_group_t group =  dispatch_group_create();\n\n  dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n      // 执行1个耗时的异步操作\n  });\n\n  dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n      // 执行1个耗时的异步操作\n  });\n\n  dispatch_group_notify(group, dispatch_get_main_queue(), ^{\n      // 等前面的异步操作都执行完毕后，回到主线程...\n  });\n  ```\n\n- （`dispatch_group_enter` <—>`dispatch_group_leave`) `enter<—>leave`会阻塞当前线程执行`enter<—>leave`对之前的**blocks**会和`enter<—>leave`对之内的操作同时执行，当`enter<—>leave`对之间的任务执行完毕当前线程继续执行。\n\n\n- `dispatch_group_wait`阻塞当前线程，当`dispatch_group`的blocks全部执行完毕之后执行`dispatch_group_wait`之后的操作。\n\n**注意**：不建议在主线程使用， **enter**<-->**leave**一定要成对存在否则可能崩溃\n\n##### 6.6 信号量控制并发`dispatch_semaphore`\n\n我们知道多线程开发最难的就是执行顺序的控制，苹果已经给我们封装好了一些流控制的东西，像dispatch_group，等但是有时候某些场景还是需要我们自己实现对代码执行的控制，毕竟我们不希望自己写的代码自己都不知道执行顺序，`dispatch_semaphore`就是为了这个目的而存在的，我们可以设置一个cout来控制程序按照我们的意愿来执行。\n\n- dispatch_semaphore_create　　创建一个semaphore\n\n- dispatch_semaphore_signal　　发送一个信号\n\n- dispatch_semaphore_wait　　　等待信号\n  > 简单的介绍一下这三个函数，第一个函数有一个整形的参数，我们可以理解为信号的总量，dispatch_semaphore_signal是发送一个信号，自然会让信号总量加1，dispatch_semaphore_wait等待信号，当信号总量少于0的时候就会一直等待，否则就可以正常的执行，并让信号总量-1，根据这样的原理，我们便可以快速的创建一个并发控制来同步任务和有限资源访问控制。\n\n```objective-c\ndispatch_queue_t serQueue = dispatch_queue_create(\"test.queue\", DISPATCH_QUEUE_CONCURRENT);\n    dispatch_queue_t conQueue = dispatch_queue_create(\"test.queue\", DISPATCH_QUEUE_CONCURRENT);\n    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);\n    dispatch_async(conQueue, ^{\n        dispatch_sync(serQueue, ^{\n            NSLog(@\"发送信息\");\n        });\n    });\n    NSLog(@\"---A---\");\n    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_NOW);\n    NSLog(@\"---B---\");\n```\n\n```objective-c\n输出结果\nLQHelper[1389:56036] ---A---\nLQHelper[1389:56139] 发送信息\nLQHelper[1389:56036] ---B---\n```\n\n**注意：**对于这样的阻塞线程的操作，最好不要放在主线程，除非特殊要求。我觉得这应该是我们用多线程开发的共识了。\n\n\n\n转载自[iOS多线程--彻底学会多线程](http://www.jianshu.com/p/2d57c72016c6)","source":"_posts/GCD学习.md","raw":"---\ntitle: GCD学习 —— 一\ndate: 2017-12-06 19:06\ntags: iOS\ncategories: iOS Tips\n---\n\n####  1、什么是GCD\n\n>Grand Central Dispatch (GCD) 是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并行任务。在Mac OS X 10.6雪豹中首次推出，也可在iOS 4及以上版本使用。(百度百科)\n\nGCD的好处：\n- GCD可用于多核的并行运算\n- GCD会自动利用更多的CPU内核（比如双核、四核）\n- GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）\n- 只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码\n  <!-- more -->\n\n####  2、任务和队列\n学习GCD之前，先来了解GCD中两个核心概念：任务和队列。\n\n**任务：**就是执行操作的意思，换句话说就是需要在线程中执行的那段代码。\n\n执行任务有两种方式：**同步执行和异步执行**。两者的主要区别是：**是否具备开启新线程的能力**。\n\n- 同步执行(sync)：只能在当前线程中执行任务，不具备开启新线程的能力。\n- 异步执行(async)：可以在新的线程中执行任务，具备开启新线程的能力。\n\n**队列：**这里的队列指任务队列，即用来存放任务的队列。队列是一种特殊的线性表，采用FIFO(先进先出)的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。在GCD中有两种队列：**串行队列和并行队列**。\n\n- 串行队列(Serial Dispatch Queue)：让任务一个接一个的执行(一个任务执行完毕，再执行下一个任务)。\n- 并行队列(Concurrent Dispatch Queue)：可以让多个任务并行(同时)执行(自动开启多个线程同时执行任务)。\n\n\n####  3、GCD的使用步骤\n\n​\t1、创建一个队列(串行或者并行队列)\n\n​\t2、将任务添加到队列中，然后系统就会根据任务类型执行任务(同步执行或者异步执行)\n\n#####  3.1 队列的创建方法\n\n​\t可以使用`dispatch_queue_create`来创建对象，需要传入两个参数，第一个参数表示队列的唯一标识符，用于DEBUG，可以为空；第二个参数是用来识别是串行队列还是并行队列。`DISPATCH_QUEUE_SERIAL`表示串行队列，`DISPATCH_QUEUE_CONCURRENT`表示并行队列。\n\n```objective-c\n// 串行队列的创建方法\ndispatch_queue_t queue = dispatch_queue_create(\"test.queue\", DISPATCH_QUEUE_SERIAL);\n// 并行队列的创建方法\ndispatch_queue_t queue = dispatch_queue_create(\"test.queue\", DISPATCH_QUEUE_CONCURRENT);\n```\n\n​\t对于并行队列，还可以使用   `dispatch_get_global_queue`来创建**全局并行队列**。GCD默认提供了全局的并行队列，需要传入两个参数。第一个参数表示队列优先级，一般用`DISPATCH_QUEUE_PRIORITY_DEFAULT`。第二个参数暂时没用，用`0`即可。\n\n\n\n##### 3.2 任务的创建方法\n\n```objective-c\n// 同步执行任务创建方法\ndispatch_sync(queue, ^{\n    NSLog(@\"%@\",[NSThread currentThread]);    // 这里放任务代码\n});\n// 异步执行任务创建方法\ndispatch_async(queue, ^{\n    NSLog(@\"%@\",[NSThread currentThread]);    // 这里放任务代码\n});\n```\n\n虽然使用GCD只需两步，但是既然我们有两种队列，两种任务执行方式，那么我们就有了四种不同的组合方式。这四种不同的组合方式是：\n\n>1. 并行队列 + 同步执行\n>2. 并行队列 + 异步执行\n>3. 串行队列 + 同步执行\n>4. 串行队列 + 异步执行\n\n实际上，我们还有一种特殊队列是主队列，那样就有六种不同的组合方式了。\n\n>5. 主队列 + 同步执行\n>6. 主队列 + 异步执行\n\n那么这几种不同组合方式各有什么区别呢，这里为了方便，先上结果，再来讲解。直接查看表格结果。\n\n|           |      并行队列      |       串行队列        |      主队列       |\n| :-------: | :------------: | :---------------: | :------------: |\n| 同步(sync)  | 没有开启新线程，串行执行任务 |  没有开启新线程，串行执行任务   | 没有开启新线程，串行执行任务 |\n| 异步(async) | 有开启新线程，并行执行任务  | 有开启新线程(1条)，并行执行任务 | 没有开启新线程，串行执行任务 |\n\n下边我们来分别讲讲这几种不同的组合方式的使用方法。\n\n\n\n####  4、GCD的基本使用\n\n#####  4.1 并行队列的两种使用方法\n\n######  4.1.1 并行队列 + 同步执行\n\n- 不会开启新线程，执行完一个任务，再执行下一个任务\n    ```objective-c\n    - (void) syncConcurrent\n    {\n        NSLog(@\"syncConcurrent---begin\");\n\n        dispatch_queue_t queue= dispatch_queue_create(\"test.queue\", DISPATCH_QUEUE_CONCURRENT);\n\n        dispatch_sync(queue, ^{\n            for (int i = 0; i < 2; ++i) {\n                NSLog(@\"1------%@\",[NSThread currentThread]);\n            }\n        });\n        dispatch_sync(queue, ^{\n            for (int i = 0; i < 2; ++i) {\n                NSLog(@\"2------%@\",[NSThread currentThread]);\n            }\n        });\n        dispatch_sync(queue, ^{\n            for (int i = 0; i < 2; ++i) {\n                NSLog(@\"3------%@\",[NSThread currentThread]);\n            }\n        });\n        \n        NSLog(@\"syncConcurrent---end\");\n    }\n    ```\n\n    ```objective-c\n    输出结果：\n    GCD[11557:1897538] syncConcurrent---begin\n    GCD[11557:1897538] 1------<NSThread: 0x7f82a1d058b0>{number = 1, name = main}\n    GCD[11557:1897538] 1------<NSThread: 0x7f82a1d058b0>{number = 1, name = main}\n    GCD[11557:1897538] 2------<NSThread: 0x7f82a1d058b0>{number = 1, name = main}\n    GCD[11557:1897538] 2------<NSThread: 0x7f82a1d058b0>{number = 1, name = main}\n    GCD[11557:1897538] 3------<NSThread: 0x7f82a1d058b0>{number = 1, name = main}\n    GCD[11557:1897538] 3------<NSThread: 0x7f82a1d058b0>{number = 1, name = main}\n    GCD[11557:1897538] syncConcurrent---end\n    ```\n\n- 从`并行队列 + 同步执行`中可以看到，所有任务都是在主线程中执行的。由于只有一个线程，所以任务只能一个一个执行。\n- 同时我们还可以看到，所有任务都在打印的`syncConcurrent---begin`和`syncConcurrent---end`之间，这说明任务是添加到队列中马上执行的。\n\n\n\n######  4.1.2 并行队列 + 异步步执行\n\n- 可同时开启多线程，任务交替执行\n\n    ```objective-c\n    - (void) asyncConcurrent\n      {\n        NSLog(@\"asyncConcurrent---begin\");\n\n        dispatch_queue_t queue= dispatch_queue_create(\"test.queue\", DISPATCH_QUEUE_CONCURRENT);\n\n        dispatch_async(queue, ^{\n            for (int i = 0; i < 2; ++i) {\n                NSLog(@\"1------%@\",[NSThread currentThread]);\n            }\n        });\n        dispatch_async(queue, ^{\n            for (int i = 0; i < 2; ++i) {\n                NSLog(@\"2------%@\",[NSThread currentThread]);\n            }\n        });\n        dispatch_async(queue, ^{\n            for (int i = 0; i < 2; ++i) {\n                NSLog(@\"3------%@\",[NSThread currentThread]);\n            }\n        });\n\n        NSLog(@\"asyncConcurrent---end\");\n      }\n    ```\n\n    ```objective-c\n    输出结果：\n    GCD[11595:1901548] asyncConcurrent---begin\n    GCD[11595:1901548] asyncConcurrent---end\n    GCD[11595:1901626] 1------<NSThread: 0x7f8309c22080>{number = 2, name = (null)}\n    GCD[11595:1901625] 2------<NSThread: 0x7f8309f0b790>{number = 4, name = (null)}\n    GCD[11595:1901855] 3------<NSThread: 0x7f8309e1a950>{number = 3, name = (null)}\n    GCD[11595:1901626] 1------<NSThread: 0x7f8309c22080>{number = 2, name = (null)}\n    GCD[11595:1901625] 2------<NSThread: 0x7f8309f0b790>{number = 4, name = (null)}\n    GCD[11595:1901855] 3------<NSThread: 0x7f8309e1a950>{number = 3, name = (null)}\n    ```\n- 在`并行队列 + 异步执行`中可以看出，除了主线程，又开启了3个线程，并且任务是交替着同时执行的。\n- 另一方面可以看出，所有任务是在打印的`syncConcurrent—begin`和`syncConcurrent—end`之后才开始执行的。说明任务不是马上执行，而是将所有任务添加到队列之后才开始异步执行。\n\n#####  4.2 串行队列的两种使用方法\n\n######  4.2.1 串行队列 + 同步执行\n\n- 不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务\n\n  ```objective-c\n  - (void) syncSerial\n  {\n      NSLog(@\"syncSerial---begin\");\n\n      dispatch_queue_t queue = dispatch_queue_create(\"test.queue\", DISPATCH_QUEUE_SERIAL);\n\n      dispatch_sync(queue, ^{\n          for (int i = 0; i < 2; ++i) {\n              NSLog(@\"1------%@\",[NSThread currentThread]);\n          }\n      });    \n      dispatch_sync(queue, ^{\n          for (int i = 0; i < 2; ++i) {\n              NSLog(@\"2------%@\",[NSThread currentThread]);\n          }\n      });\n      dispatch_sync(queue, ^{\n          for (int i = 0; i < 2; ++i) {\n              NSLog(@\"3------%@\",[NSThread currentThread]);\n          }\n      });\n\n      NSLog(@\"syncSerial---end\");\n  }\n  ```\n\n  ```objective-c\n  输出结果为：\n  GCD[11622:1903904] syncSerial---begin\n  GCD[11622:1903904] 1------<NSThread: 0x7fa2e9f00980>{number = 1, name = main}\n  GCD[11622:1903904] 1------<NSThread: 0x7fa2e9f00980>{number = 1, name = main}\n  GCD[11622:1903904] 2------<NSThread: 0x7fa2e9f00980>{number = 1, name = main}\n  GCD[11622:1903904] 2------<NSThread: 0x7fa2e9f00980>{number = 1, name = main}\n  GCD[11622:1903904] 3------<NSThread: 0x7fa2e9f00980>{number = 1, name = main}\n  GCD[11622:1903904] 3------<NSThread: 0x7fa2e9f00980>{number = 1, name = main}\n  GCD[11622:1903904] syncSerial---end\n  ```\n\n\n  - 在`串行队列 + 同步执行`可以看到，所有任务都是在主线程中执行的，并没有开启新的线程。而且由于串行队列，所以按顺序一个一个执行。\n  - 同时我们还可以看到，所有任务都在打印的`syncConcurrent—begin`和`syncConcurrent—end`之间，这说明任务是添加到队列中马上执行的。\n\n######  4.2.2 串行队列 + 异步执行\n\n- 会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务\n\n  ```objective-c\n  - (void) asyncSerial\n  {\n      NSLog(@\"asyncSerial---begin\");\n\n      dispatch_queue_t queue = dispatch_queue_create(\"test.queue\", DISPATCH_QUEUE_SERIAL);\n\n      dispatch_async(queue, ^{\n          for (int i = 0; i < 2; ++i) {\n              NSLog(@\"1------%@\",[NSThread currentThread]);\n          }\n      });    \n      dispatch_async(queue, ^{\n          for (int i = 0; i < 2; ++i) {\n              NSLog(@\"2------%@\",[NSThread currentThread]);\n          }\n      });\n      dispatch_async(queue, ^{\n          for (int i = 0; i < 2; ++i) {\n              NSLog(@\"3------%@\",[NSThread currentThread]);\n          }\n      });\n\n      NSLog(@\"asyncSerial---end\");\n  }\n  ```\n\n  ```objective-c\n  输出结果为：\n  GCD[11648:1905817] asyncSerial---begin\n  GCD[11648:1905817] asyncSerial---end\n  GCD[11648:1905895] 1------<NSThread: 0x7fb548c0e390>{number = 2, name = (null)}\n  GCD[11648:1905895] 1------<NSThread: 0x7fb548c0e390>{number = 2, name = (null)}\n  GCD[11648:1905895] 2------<NSThread: 0x7fb548c0e390>{number = 2, name = (null)}\n  GCD[11648:1905895] 2------<NSThread: 0x7fb548c0e390>{number = 2, name = (null)}\n  GCD[11648:1905895] 3------<NSThread: 0x7fb548c0e390>{number = 2, name = (null)}\n  GCD[11648:1905895] 3------<NSThread: 0x7fb548c0e390>{number = 2, name = (null)}\n  ```\n\n\n- 在`串行队列 + 异步执行`可以看到，开启了一条新线程，但是任务还是串行，所以任务是一个一个执行。\n- 另一方面可以看出，所有任务是在打印的`syncConcurrent---begin`和`syncConcurrent---end`之后才开始执行的。说明任务不是马上执行，而是将所有任务添加到队列之后才开始同步执行。\n\n\n##### 4.3 主队列\n\n- 主队列：GCD自带的一种特殊的**串行队列**\n  - 所有放在主队列中的任务，都会放到主线程中执行\n  - 可使用`dispatch_get_main_queue()`获得主队列\n\n###### 4.3.1 主队列 + 同步执行\n\n- 互等卡住不可行(在主线程中调用)\n    ```objective-c\n    - (void)syncMain\n    {\n        NSLog(@\"syncMain---begin\");\n\n        dispatch_queue_t queue = dispatch_get_main_queue();\n\n        dispatch_sync(queue, ^{\n            for (int i = 0; i < 2; ++i) {\n                NSLog(@\"1------%@\",[NSThread currentThread]);\n            }\n        });\n        dispatch_sync(queue, ^{\n            for (int i = 0; i < 2; ++i) {\n                NSLog(@\"2------%@\",[NSThread currentThread]);\n            }\n        });\n        dispatch_sync(queue, ^{\n            for (int i = 0; i < 2; ++i) {\n                NSLog(@\"3------%@\",[NSThread currentThread]);\n            }\n        });   \n\n        NSLog(@\"syncMain---end\");\n    }\n    ```\n    ```objective-c\n    输出结果\n    2016-09-03 19:32:15.356 GCD[11670:1908306] syncMain---begin\n    ```\n\n- 这时候，我们惊奇的发现，在主线程中使用主队列 + 同步执行，任务不再执行了，而且syncMain---end也没有打印。这是为什么呢？\n\n- 这是因为我们在主线程中执行这段代码。我们把任务放到了主队列中，也就是放到了主线程的队列中。而同步执行有个特点，就是对于任务是立马执行的。那么当我们把第一个任务放进主队列中，它就会立马执行。但是主线程现在正在处理syncMain方法，所以任务需要等syncMain执行完才能执行。而syncMain执行到第一个任务的时候，又要等第一个任务执行完才能往下执行第二个和第三个任务。\n\n- 那么，现在的情况就是`syncMain`方法和第一个任务都在等对方执行完毕。这样大家互相等待，所以就卡住了，所以我们的任务执行不了，而且`syncMain---end`也没有打印。\n\n    **要是如果不再主线程中调用，而在其他线程中调用会如何呢？**\n\n- 不会开启新线程，执行完一个任务，再执行下一个任务（在其他线程中调用）\n\n    ```objective-c\n    dispatch_queue_t queue = dispatch_queue_create(\"test.queue\", DISPATCH_QUEUE_CONCURRENT);\n\n    dispatch_async(queue, ^{\n        [self syncMain];\n    });\n    ```\n\n    ```objective-c\n    输出结果：\n    GCD[11686:1909617] syncMain---begin\n    GCD[11686:1909374] 1------<NSThread: 0x7faef2f01600>{number = 1, name = main}\n    GCD[11686:1909374] 1------<NSThread: 0x7faef2f01600>{number = 1, name = main}\n    GCD[11686:1909374] 2------<NSThread: 0x7faef2f01600>{number = 1, name = main}\n    GCD[11686:1909374] 2------<NSThread: 0x7faef2f01600>{number = 1, name = main}\n    GCD[11686:1909374] 3------<NSThread: 0x7faef2f01600>{number = 1, name = main}\n    GCD[11686:1909374] 3------<NSThread: 0x7faef2f01600>{number = 1, name = main}\n    GCD[11686:1909617] syncMain---end\n    ```\n\n- 在其他线程中使用`主队列 + 同步执行`可看到：所有任务都是在主线程中执行的，并没有开启新的线程。而且由于主队列是串行队列，所以按顺序一个一个执行。\n\n\n- 同时我们还可以看到，所有任务都在打印的syncConcurrent---begin和syncConcurrent---end之间，这说明任务是添加到队列中马上执行的。\n\n###### 4.3.2 主队列 + 异步执行\n\n- 只在主线程中执行任务，执行完一个任务，再执行下一个任务\n\n  ```objective-c\n  - (void)asyncMain\n  {\n      NSLog(@\"asyncMain---begin\");\n\n      dispatch_queue_t queue = dispatch_get_main_queue();\n      \n      dispatch_async(queue, ^{\n          for (int i = 0; i < 2; ++i) {\n              NSLog(@\"1------%@\",[NSThread currentThread]);\n          }\n      });    \n      dispatch_async(queue, ^{\n          for (int i = 0; i < 2; ++i) {\n              NSLog(@\"2------%@\",[NSThread currentThread]);\n          }\n      });\n      dispatch_async(queue, ^{\n          for (int i = 0; i < 2; ++i) {\n              NSLog(@\"3------%@\",[NSThread currentThread]);\n          }\n      });  \n\n      NSLog(@\"asyncMain---end\");\n  }\n  ```\n\n  ```objective-c\n  输出结果：\n  GCD[11706:1911313] asyncMain---begin\n  GCD[11706:1911313] asyncMain---end\n  GCD[11706:1911313] 1------<NSThread: 0x7fb623d015e0>{number = 1, name = main}\n  GCD[11706:1911313] 1------<NSThread: 0x7fb623d015e0>{number = 1, name = main}\n  GCD[11706:1911313] 2------<NSThread: 0x7fb623d015e0>{number = 1, name = main}\n  GCD[11706:1911313] 2------<NSThread: 0x7fb623d015e0>{number = 1, name = main}\n  GCD[11706:1911313] 3------<NSThread: 0x7fb623d015e0>{number = 1, name = main}\n  GCD[11706:1911313] 3------<NSThread: 0x7fb623d015e0>{number = 1, name = main}\n  ```\n\n\n- 我们发现所有任务都在主线程中，虽然是异步执行，具备开启线程的能力，但因为是主队列，所以所有任务都在主线程中，并且一个接一个执行。\n- 另一方面可以看出，所有任务是在打印的`syncConcurrent---begin`和`syncConcurrent---end`之后才开始执行的。说明任务不是马上执行，而是将所有任务添加到队列之后才开始同步执行。\n\n\n\n#### 5. GCD线程之间的通讯\n\n​\t在iOS开发过程中，我们一般在主线程里边进行UI刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。\n\n```objective-c\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    for (int i = 0; i < 2; ++i) {\n        NSLog(@\"1------%@\",[NSThread currentThread]);\n    }\n\n    // 回到主线程\n    dispatch_async(dispatch_get_main_queue(), ^{\n        NSLog(@\"2------%@\",[NSThread currentThread]);\n    });\n});\n```\n\n```objective-c\n输出结果：\nGCD[11728:1913039] 1------<NSThread: 0x7f8319c06820>{number = 2, name = (null)}\nGCD[11728:1913039] 1------<NSThread: 0x7f8319c06820>{number = 2, name = (null)}\nGCD[11728:1912961] 2------<NSThread: 0x7f8319e00560>{number = 1, name = main}\n```\n- 可以看到在其他线程中先执行操作，执行完了之后回到主线程执行主线程的相应操作。\n\n\n#### 6. GCD的其他方法\n\n##### 6.1 GCD的栅栏方法 `dispatch_barrier_async`\n\n- 我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于栅栏一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到dispatch_barrier_async方法在两个操作组间形成栅栏。\n\n  ```objective-c\n  - (void)barrier\n  {\n      dispatch_queue_t queue = dispatch_queue_create(\"12312312\", DISPATCH_QUEUE_CONCURRENT);\n\n      dispatch_async(queue, ^{\n          NSLog(@\"----1-----%@\", [NSThread currentThread]);\n      });\n      dispatch_async(queue, ^{\n          NSLog(@\"----2-----%@\", [NSThread currentThread]);\n      });\n\n      dispatch_barrier_async(queue, ^{\n          NSLog(@\"---barrier%@\", [NSThread currentThread]);\n      });\n\n      dispatch_async(queue, ^{\n          NSLog(@\"----3-----%@\", [NSThread currentThread]);\n      });\n      dispatch_async(queue, ^{\n          NSLog(@\"----4-----%@\", [NSThread currentThread]);\n      });\n  }\n  ```\n\n  ```objective-c\n  输出结果：\n  GCD[11750:1914724] ----1-----<NSThread: 0x7fb1826047b0>{number = 2, name = (null)}\n  GCD[11750:1914722] ----2-----<NSThread: 0x7fb182423fd0>{number = 3, name = (null)}\n  GCD[11750:1914722] ---barrier<NSThread: 0x7fb182423fd0>{number = 3, name = (null)}\n  GCD[11750:1914722] ----3-----<NSThread: 0x7fb182423fd0>{number = 3, name = (null)}\n  GCD[11750:1914724] ----4-----<NSThread: 0x7fb1826047b0>{number = 2, name = (null)}\n  ```\n\n- 可以看出在执行完栅栏前面的操作之后，才执行栅栏操作，最后再执行栅栏后边的操作。\n\n##### 6.2 GCD的延时执行方法 `dispatch_after`\n\n- 当我们需要延迟执行一段代码时，就需要用到GCD的`dispatch_after`方法。\n\n- `dispatch_after`能让我们添加进队列的任务延时执行，比如想让一个Block在2秒后执行：\n\n  ```objective-c\n  dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC));\n  dispatch_after(time, dispatch_get_main_queue(), ^{\n      // 2秒后异步执行这里的代码...\n     NSLog(@\"run-----\");\n  });\n  ```\n\n  `NSEC_PER_SEC`表示的是秒数，它还提供了`NSEC_PER_MSEC`表示毫秒。\n\n  上面这句`dispatch_after`的真正含义是在2秒后把任务添加进队列中，并不是表示在2秒后执行，大部分情况该函数能达到我们的预期，只有在对时间要求非常精准的情况下才可能会出现问题。\n\n  获取一个`dispatch_time_t`类型的值可以通过两种方式来获取，以上是第一种方式，即通过`dispatch_time`函数，另一种是通过`dispatch_walltime`函数来获取，`dispatch_walltime`需要使用一个timespec的结构体来得到`dispatch_time_t`。通常`dispatch_time`用于计算相对时间，`dispatch_walltime`用于计算绝对时间\n\n##### 6.3 GCD的一次性代码(只执行一次) `dispatch_once`\n\n- 我们在创建单例、或者有整个程序运行过程中只执行一次的代码时，我们就用到了GCD的`dispatch_once`方法。使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次。\n\n  ```objective-c\n  static dispatch_once_t onceToken;\n  dispatch_once(&onceToken, ^{\n      // 只执行1次的代码(这里面默认是线程安全的)\n  });\n  ```\n\n##### 6.4 GCD的快速迭代方法 `dispatch_apply`\n\n- 通常我们会用for循环遍历，但是GCD给我们提供了快速迭代的方法`dispatch_apply`，使我们可以同时遍历。比如说遍历0~5这6个数字，for循环的做法是每次取出一个元素，逐个遍历。`dispatch_apply`可以同时遍历多个数字。\n\n  ```objective-c\n  dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n\n  dispatch_apply(6, queue, ^(size_t index) {\n      NSLog(@\"%zd------%@\",index, [NSThread currentThread]);\n  });\n  ```\n\n  ```objective-c\n  输出结果：\n  GCD[11764:1915764] 1------<NSThread: 0x7fac9a7029e0>{number = 1, name = main}\n  GCD[11764:1915885] 0------<NSThread: 0x7fac9a614bd0>{number = 2, name = (null)}\n  GCD[11764:1915886] 2------<NSThread: 0x7fac9a542b20>{number = 3, name = (null)}\n  GCD[11764:1915764] 4------<NSThread: 0x7fac9a7029e0>{number = 1, name = main}\n  GCD[11764:1915884] 3------<NSThread: 0x7fac9a76ca10>{number = 4, name = (null)}\n  GCD[11764:1915885] 5------<NSThread: 0x7fac9a614bd0>{number = 2, name = (null)}\n  ```\n\n- 从输出结果中前边的时间中可以看出，几乎是同时遍历的。\n\n##### 6.5 GCD的队列组 `dispatch_group`\n\n- 有时候我们会有这样的需求：分别异步执行2个耗时操作，然后当2个耗时操作都执行完毕后再回到主线程执行操作。这时候我们可以用到GCD的队列组。\n\n  - 我们可以先把任务放到队列中，然后将队列放入队列组中。()\n  - 调用队列组的`dispatch_group_notify`回到主线程执行操作。\n\n  ```objective-c\n  dispatch_group_t group =  dispatch_group_create();\n\n  dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n      // 执行1个耗时的异步操作\n  });\n\n  dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n      // 执行1个耗时的异步操作\n  });\n\n  dispatch_group_notify(group, dispatch_get_main_queue(), ^{\n      // 等前面的异步操作都执行完毕后，回到主线程...\n  });\n  ```\n\n- （`dispatch_group_enter` <—>`dispatch_group_leave`) `enter<—>leave`会阻塞当前线程执行`enter<—>leave`对之前的**blocks**会和`enter<—>leave`对之内的操作同时执行，当`enter<—>leave`对之间的任务执行完毕当前线程继续执行。\n\n\n- `dispatch_group_wait`阻塞当前线程，当`dispatch_group`的blocks全部执行完毕之后执行`dispatch_group_wait`之后的操作。\n\n**注意**：不建议在主线程使用， **enter**<-->**leave**一定要成对存在否则可能崩溃\n\n##### 6.6 信号量控制并发`dispatch_semaphore`\n\n我们知道多线程开发最难的就是执行顺序的控制，苹果已经给我们封装好了一些流控制的东西，像dispatch_group，等但是有时候某些场景还是需要我们自己实现对代码执行的控制，毕竟我们不希望自己写的代码自己都不知道执行顺序，`dispatch_semaphore`就是为了这个目的而存在的，我们可以设置一个cout来控制程序按照我们的意愿来执行。\n\n- dispatch_semaphore_create　　创建一个semaphore\n\n- dispatch_semaphore_signal　　发送一个信号\n\n- dispatch_semaphore_wait　　　等待信号\n  > 简单的介绍一下这三个函数，第一个函数有一个整形的参数，我们可以理解为信号的总量，dispatch_semaphore_signal是发送一个信号，自然会让信号总量加1，dispatch_semaphore_wait等待信号，当信号总量少于0的时候就会一直等待，否则就可以正常的执行，并让信号总量-1，根据这样的原理，我们便可以快速的创建一个并发控制来同步任务和有限资源访问控制。\n\n```objective-c\ndispatch_queue_t serQueue = dispatch_queue_create(\"test.queue\", DISPATCH_QUEUE_CONCURRENT);\n    dispatch_queue_t conQueue = dispatch_queue_create(\"test.queue\", DISPATCH_QUEUE_CONCURRENT);\n    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);\n    dispatch_async(conQueue, ^{\n        dispatch_sync(serQueue, ^{\n            NSLog(@\"发送信息\");\n        });\n    });\n    NSLog(@\"---A---\");\n    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_NOW);\n    NSLog(@\"---B---\");\n```\n\n```objective-c\n输出结果\nLQHelper[1389:56036] ---A---\nLQHelper[1389:56139] 发送信息\nLQHelper[1389:56036] ---B---\n```\n\n**注意：**对于这样的阻塞线程的操作，最好不要放在主线程，除非特殊要求。我觉得这应该是我们用多线程开发的共识了。\n\n\n\n转载自[iOS多线程--彻底学会多线程](http://www.jianshu.com/p/2d57c72016c6)","slug":"GCD学习","published":1,"updated":"2017-12-08T09:24:15.307Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb1u1v7n00071us0m6xeyvj1","content":"<h4 id=\"1、什么是GCD\"><a href=\"#1、什么是GCD\" class=\"headerlink\" title=\"1、什么是GCD\"></a>1、什么是GCD</h4><blockquote>\n<p>Grand Central Dispatch (GCD) 是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并行任务。在Mac OS X 10.6雪豹中首次推出，也可在iOS 4及以上版本使用。(百度百科)</p>\n</blockquote>\n<p>GCD的好处：</p>\n<ul>\n<li>GCD可用于多核的并行运算</li>\n<li>GCD会自动利用更多的CPU内核（比如双核、四核）</li>\n<li>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li>\n<li>只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码<a id=\"more\"></a>\n</li>\n</ul>\n<h4 id=\"2、任务和队列\"><a href=\"#2、任务和队列\" class=\"headerlink\" title=\"2、任务和队列\"></a>2、任务和队列</h4><p>学习GCD之前，先来了解GCD中两个核心概念：任务和队列。</p>\n<p><strong>任务：</strong>就是执行操作的意思，换句话说就是需要在线程中执行的那段代码。</p>\n<p>执行任务有两种方式：<strong>同步执行和异步执行</strong>。两者的主要区别是：<strong>是否具备开启新线程的能力</strong>。</p>\n<ul>\n<li>同步执行(sync)：只能在当前线程中执行任务，不具备开启新线程的能力。</li>\n<li>异步执行(async)：可以在新的线程中执行任务，具备开启新线程的能力。</li>\n</ul>\n<p><strong>队列：</strong>这里的队列指任务队列，即用来存放任务的队列。队列是一种特殊的线性表，采用FIFO(先进先出)的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。在GCD中有两种队列：<strong>串行队列和并行队列</strong>。</p>\n<ul>\n<li>串行队列(Serial Dispatch Queue)：让任务一个接一个的执行(一个任务执行完毕，再执行下一个任务)。</li>\n<li>并行队列(Concurrent Dispatch Queue)：可以让多个任务并行(同时)执行(自动开启多个线程同时执行任务)。</li>\n</ul>\n<h4 id=\"3、GCD的使用步骤\"><a href=\"#3、GCD的使用步骤\" class=\"headerlink\" title=\"3、GCD的使用步骤\"></a>3、GCD的使用步骤</h4><p>​    1、创建一个队列(串行或者并行队列)</p>\n<p>​    2、将任务添加到队列中，然后系统就会根据任务类型执行任务(同步执行或者异步执行)</p>\n<h5 id=\"3-1-队列的创建方法\"><a href=\"#3-1-队列的创建方法\" class=\"headerlink\" title=\"3.1 队列的创建方法\"></a>3.1 队列的创建方法</h5><p>​    可以使用<code>dispatch_queue_create</code>来创建对象，需要传入两个参数，第一个参数表示队列的唯一标识符，用于DEBUG，可以为空；第二个参数是用来识别是串行队列还是并行队列。<code>DISPATCH_QUEUE_SERIAL</code>表示串行队列，<code>DISPATCH_QUEUE_CONCURRENT</code>表示并行队列。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 串行队列的创建方法</span><br><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\">// 并行队列的创建方法</span><br><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>\n<p>​    对于并行队列，还可以使用   <code>dispatch_get_global_queue</code>来创建<strong>全局并行队列</strong>。GCD默认提供了全局的并行队列，需要传入两个参数。第一个参数表示队列优先级，一般用<code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code>。第二个参数暂时没用，用<code>0</code>即可。</p>\n<h5 id=\"3-2-任务的创建方法\"><a href=\"#3-2-任务的创建方法\" class=\"headerlink\" title=\"3.2 任务的创建方法\"></a>3.2 任务的创建方法</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 同步执行任务创建方法</span><br><span class=\"line\">dispatch_sync(queue, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);    // 这里放任务代码</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 异步执行任务创建方法</span><br><span class=\"line\">dispatch_async(queue, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);    // 这里放任务代码</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>虽然使用GCD只需两步，但是既然我们有两种队列，两种任务执行方式，那么我们就有了四种不同的组合方式。这四种不同的组合方式是：</p>\n<blockquote>\n<ol>\n<li>并行队列 + 同步执行</li>\n<li>并行队列 + 异步执行</li>\n<li>串行队列 + 同步执行</li>\n<li>串行队列 + 异步执行</li>\n</ol>\n</blockquote>\n<p>实际上，我们还有一种特殊队列是主队列，那样就有六种不同的组合方式了。</p>\n<blockquote>\n<ol>\n<li>主队列 + 同步执行</li>\n<li>主队列 + 异步执行</li>\n</ol>\n</blockquote>\n<p>那么这几种不同组合方式各有什么区别呢，这里为了方便，先上结果，再来讲解。直接查看表格结果。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">并行队列</th>\n<th style=\"text-align:center\">串行队列</th>\n<th style=\"text-align:center\">主队列</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">同步(sync)</td>\n<td style=\"text-align:center\">没有开启新线程，串行执行任务</td>\n<td style=\"text-align:center\">没有开启新线程，串行执行任务</td>\n<td style=\"text-align:center\">没有开启新线程，串行执行任务</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">异步(async)</td>\n<td style=\"text-align:center\">有开启新线程，并行执行任务</td>\n<td style=\"text-align:center\">有开启新线程(1条)，并行执行任务</td>\n<td style=\"text-align:center\">没有开启新线程，串行执行任务</td>\n</tr>\n</tbody>\n</table>\n<p>下边我们来分别讲讲这几种不同的组合方式的使用方法。</p>\n<h4 id=\"4、GCD的基本使用\"><a href=\"#4、GCD的基本使用\" class=\"headerlink\" title=\"4、GCD的基本使用\"></a>4、GCD的基本使用</h4><h5 id=\"4-1-并行队列的两种使用方法\"><a href=\"#4-1-并行队列的两种使用方法\" class=\"headerlink\" title=\"4.1 并行队列的两种使用方法\"></a>4.1 并行队列的两种使用方法</h5><h6 id=\"4-1-1-并行队列-同步执行\"><a href=\"#4-1-1-并行队列-同步执行\" class=\"headerlink\" title=\"4.1.1 并行队列 + 同步执行\"></a>4.1.1 并行队列 + 同步执行</h6><ul>\n<li><p>不会开启新线程，执行完一个任务，再执行下一个任务</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void) syncConcurrent</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;syncConcurrent---begin&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_queue_t queue= dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_sync(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;1------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    dispatch_sync(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;2------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    dispatch_sync(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;3------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;syncConcurrent---end&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果：</span><br><span class=\"line\">GCD[11557:1897538] syncConcurrent---begin</span><br><span class=\"line\">GCD[11557:1897538] 1------&lt;NSThread: 0x7f82a1d058b0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11557:1897538] 1------&lt;NSThread: 0x7f82a1d058b0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11557:1897538] 2------&lt;NSThread: 0x7f82a1d058b0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11557:1897538] 2------&lt;NSThread: 0x7f82a1d058b0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11557:1897538] 3------&lt;NSThread: 0x7f82a1d058b0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11557:1897538] 3------&lt;NSThread: 0x7f82a1d058b0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11557:1897538] syncConcurrent---end</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>从<code>并行队列 + 同步执行</code>中可以看到，所有任务都是在主线程中执行的。由于只有一个线程，所以任务只能一个一个执行。</p>\n</li>\n<li>同时我们还可以看到，所有任务都在打印的<code>syncConcurrent---begin</code>和<code>syncConcurrent---end</code>之间，这说明任务是添加到队列中马上执行的。</li>\n</ul>\n<h6 id=\"4-1-2-并行队列-异步步执行\"><a href=\"#4-1-2-并行队列-异步步执行\" class=\"headerlink\" title=\"4.1.2 并行队列 + 异步步执行\"></a>4.1.2 并行队列 + 异步步执行</h6><ul>\n<li><p>可同时开启多线程，任务交替执行</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void) asyncConcurrent</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    NSLog(@&quot;asyncConcurrent---begin&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_queue_t queue= dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;1------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;2------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;3------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;asyncConcurrent---end&quot;);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果：</span><br><span class=\"line\">GCD[11595:1901548] asyncConcurrent---begin</span><br><span class=\"line\">GCD[11595:1901548] asyncConcurrent---end</span><br><span class=\"line\">GCD[11595:1901626] 1------&lt;NSThread: 0x7f8309c22080&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">GCD[11595:1901625] 2------&lt;NSThread: 0x7f8309f0b790&gt;&#123;number = 4, name = (null)&#125;</span><br><span class=\"line\">GCD[11595:1901855] 3------&lt;NSThread: 0x7f8309e1a950&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">GCD[11595:1901626] 1------&lt;NSThread: 0x7f8309c22080&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">GCD[11595:1901625] 2------&lt;NSThread: 0x7f8309f0b790&gt;&#123;number = 4, name = (null)&#125;</span><br><span class=\"line\">GCD[11595:1901855] 3------&lt;NSThread: 0x7f8309e1a950&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在<code>并行队列 + 异步执行</code>中可以看出，除了主线程，又开启了3个线程，并且任务是交替着同时执行的。</p>\n</li>\n<li>另一方面可以看出，所有任务是在打印的<code>syncConcurrent—begin</code>和<code>syncConcurrent—end</code>之后才开始执行的。说明任务不是马上执行，而是将所有任务添加到队列之后才开始异步执行。</li>\n</ul>\n<h5 id=\"4-2-串行队列的两种使用方法\"><a href=\"#4-2-串行队列的两种使用方法\" class=\"headerlink\" title=\"4.2 串行队列的两种使用方法\"></a>4.2 串行队列的两种使用方法</h5><h6 id=\"4-2-1-串行队列-同步执行\"><a href=\"#4-2-1-串行队列-同步执行\" class=\"headerlink\" title=\"4.2.1 串行队列 + 同步执行\"></a>4.2.1 串行队列 + 同步执行</h6><ul>\n<li><p>不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void) syncSerial</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;syncSerial---begin&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_queue_t queue = dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_sync(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;1------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);    </span><br><span class=\"line\">    dispatch_sync(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;2------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    dispatch_sync(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;3------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;syncSerial---end&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果为：</span><br><span class=\"line\">GCD[11622:1903904] syncSerial---begin</span><br><span class=\"line\">GCD[11622:1903904] 1------&lt;NSThread: 0x7fa2e9f00980&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11622:1903904] 1------&lt;NSThread: 0x7fa2e9f00980&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11622:1903904] 2------&lt;NSThread: 0x7fa2e9f00980&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11622:1903904] 2------&lt;NSThread: 0x7fa2e9f00980&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11622:1903904] 3------&lt;NSThread: 0x7fa2e9f00980&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11622:1903904] 3------&lt;NSThread: 0x7fa2e9f00980&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11622:1903904] syncSerial---end</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在<code>串行队列 + 同步执行</code>可以看到，所有任务都是在主线程中执行的，并没有开启新的线程。而且由于串行队列，所以按顺序一个一个执行。</li>\n<li>同时我们还可以看到，所有任务都在打印的<code>syncConcurrent—begin</code>和<code>syncConcurrent—end</code>之间，这说明任务是添加到队列中马上执行的。</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"4-2-2-串行队列-异步执行\"><a href=\"#4-2-2-串行队列-异步执行\" class=\"headerlink\" title=\"4.2.2 串行队列 + 异步执行\"></a>4.2.2 串行队列 + 异步执行</h6><ul>\n<li><p>会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void) asyncSerial</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;asyncSerial---begin&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_queue_t queue = dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;1------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);    </span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;2------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;3------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;asyncSerial---end&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果为：</span><br><span class=\"line\">GCD[11648:1905817] asyncSerial---begin</span><br><span class=\"line\">GCD[11648:1905817] asyncSerial---end</span><br><span class=\"line\">GCD[11648:1905895] 1------&lt;NSThread: 0x7fb548c0e390&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">GCD[11648:1905895] 1------&lt;NSThread: 0x7fb548c0e390&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">GCD[11648:1905895] 2------&lt;NSThread: 0x7fb548c0e390&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">GCD[11648:1905895] 2------&lt;NSThread: 0x7fb548c0e390&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">GCD[11648:1905895] 3------&lt;NSThread: 0x7fb548c0e390&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">GCD[11648:1905895] 3------&lt;NSThread: 0x7fb548c0e390&gt;&#123;number = 2, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在<code>串行队列 + 异步执行</code>可以看到，开启了一条新线程，但是任务还是串行，所以任务是一个一个执行。</p>\n</li>\n<li>另一方面可以看出，所有任务是在打印的<code>syncConcurrent---begin</code>和<code>syncConcurrent---end</code>之后才开始执行的。说明任务不是马上执行，而是将所有任务添加到队列之后才开始同步执行。</li>\n</ul>\n<h5 id=\"4-3-主队列\"><a href=\"#4-3-主队列\" class=\"headerlink\" title=\"4.3 主队列\"></a>4.3 主队列</h5><ul>\n<li>主队列：GCD自带的一种特殊的<strong>串行队列</strong><ul>\n<li>所有放在主队列中的任务，都会放到主线程中执行</li>\n<li>可使用<code>dispatch_get_main_queue()</code>获得主队列</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"4-3-1-主队列-同步执行\"><a href=\"#4-3-1-主队列-同步执行\" class=\"headerlink\" title=\"4.3.1 主队列 + 同步执行\"></a>4.3.1 主队列 + 同步执行</h6><ul>\n<li><p>互等卡住不可行(在主线程中调用)</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)syncMain</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;syncMain---begin&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_sync(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;1------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    dispatch_sync(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;2------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    dispatch_sync(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;3------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);   </span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;syncMain---end&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果</span><br><span class=\"line\">2016-09-03 19:32:15.356 GCD[11670:1908306] syncMain---begin</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这时候，我们惊奇的发现，在主线程中使用主队列 + 同步执行，任务不再执行了，而且syncMain—end也没有打印。这是为什么呢？</p>\n</li>\n<li><p>这是因为我们在主线程中执行这段代码。我们把任务放到了主队列中，也就是放到了主线程的队列中。而同步执行有个特点，就是对于任务是立马执行的。那么当我们把第一个任务放进主队列中，它就会立马执行。但是主线程现在正在处理syncMain方法，所以任务需要等syncMain执行完才能执行。而syncMain执行到第一个任务的时候，又要等第一个任务执行完才能往下执行第二个和第三个任务。</p>\n</li>\n<li><p>那么，现在的情况就是<code>syncMain</code>方法和第一个任务都在等对方执行完毕。这样大家互相等待，所以就卡住了，所以我们的任务执行不了，而且<code>syncMain---end</code>也没有打印。</p>\n<p>  <strong>要是如果不再主线程中调用，而在其他线程中调用会如何呢？</strong></p>\n</li>\n<li><p>不会开启新线程，执行完一个任务，再执行下一个任务（在其他线程中调用）</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(queue, ^&#123;</span><br><span class=\"line\">    [self syncMain];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果：</span><br><span class=\"line\">GCD[11686:1909617] syncMain---begin</span><br><span class=\"line\">GCD[11686:1909374] 1------&lt;NSThread: 0x7faef2f01600&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11686:1909374] 1------&lt;NSThread: 0x7faef2f01600&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11686:1909374] 2------&lt;NSThread: 0x7faef2f01600&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11686:1909374] 2------&lt;NSThread: 0x7faef2f01600&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11686:1909374] 3------&lt;NSThread: 0x7faef2f01600&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11686:1909374] 3------&lt;NSThread: 0x7faef2f01600&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11686:1909617] syncMain---end</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在其他线程中使用<code>主队列 + 同步执行</code>可看到：所有任务都是在主线程中执行的，并没有开启新的线程。而且由于主队列是串行队列，所以按顺序一个一个执行。</p>\n</li>\n</ul>\n<ul>\n<li>同时我们还可以看到，所有任务都在打印的syncConcurrent—begin和syncConcurrent—end之间，这说明任务是添加到队列中马上执行的。</li>\n</ul>\n<h6 id=\"4-3-2-主队列-异步执行\"><a href=\"#4-3-2-主队列-异步执行\" class=\"headerlink\" title=\"4.3.2 主队列 + 异步执行\"></a>4.3.2 主队列 + 异步执行</h6><ul>\n<li><p>只在主线程中执行任务，执行完一个任务，再执行下一个任务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)asyncMain</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;asyncMain---begin&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class=\"line\">    </span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;1------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);    </span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;2------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;3------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);  </span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;asyncMain---end&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果：</span><br><span class=\"line\">GCD[11706:1911313] asyncMain---begin</span><br><span class=\"line\">GCD[11706:1911313] asyncMain---end</span><br><span class=\"line\">GCD[11706:1911313] 1------&lt;NSThread: 0x7fb623d015e0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11706:1911313] 1------&lt;NSThread: 0x7fb623d015e0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11706:1911313] 2------&lt;NSThread: 0x7fb623d015e0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11706:1911313] 2------&lt;NSThread: 0x7fb623d015e0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11706:1911313] 3------&lt;NSThread: 0x7fb623d015e0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11706:1911313] 3------&lt;NSThread: 0x7fb623d015e0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>我们发现所有任务都在主线程中，虽然是异步执行，具备开启线程的能力，但因为是主队列，所以所有任务都在主线程中，并且一个接一个执行。</p>\n</li>\n<li>另一方面可以看出，所有任务是在打印的<code>syncConcurrent---begin</code>和<code>syncConcurrent---end</code>之后才开始执行的。说明任务不是马上执行，而是将所有任务添加到队列之后才开始同步执行。</li>\n</ul>\n<h4 id=\"5-GCD线程之间的通讯\"><a href=\"#5-GCD线程之间的通讯\" class=\"headerlink\" title=\"5. GCD线程之间的通讯\"></a>5. GCD线程之间的通讯</h4><p>​    在iOS开发过程中，我们一般在主线程里边进行UI刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\">    for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">        NSLog(@&quot;1------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 回到主线程</span><br><span class=\"line\">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        NSLog(@&quot;2------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果：</span><br><span class=\"line\">GCD[11728:1913039] 1------&lt;NSThread: 0x7f8319c06820&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">GCD[11728:1913039] 1------&lt;NSThread: 0x7f8319c06820&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">GCD[11728:1912961] 2------&lt;NSThread: 0x7f8319e00560&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>可以看到在其他线程中先执行操作，执行完了之后回到主线程执行主线程的相应操作。</li>\n</ul>\n<h4 id=\"6-GCD的其他方法\"><a href=\"#6-GCD的其他方法\" class=\"headerlink\" title=\"6. GCD的其他方法\"></a>6. GCD的其他方法</h4><h5 id=\"6-1-GCD的栅栏方法-dispatch-barrier-async\"><a href=\"#6-1-GCD的栅栏方法-dispatch-barrier-async\" class=\"headerlink\" title=\"6.1 GCD的栅栏方法 dispatch_barrier_async\"></a>6.1 GCD的栅栏方法 <code>dispatch_barrier_async</code></h5><ul>\n<li><p>我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于栅栏一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到dispatch_barrier_async方法在两个操作组间形成栅栏。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)barrier</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    dispatch_queue_t queue = dispatch_queue_create(&quot;12312312&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        NSLog(@&quot;----1-----%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        NSLog(@&quot;----2-----%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_barrier_async(queue, ^&#123;</span><br><span class=\"line\">        NSLog(@&quot;---barrier%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        NSLog(@&quot;----3-----%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        NSLog(@&quot;----4-----%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果：</span><br><span class=\"line\">GCD[11750:1914724] ----1-----&lt;NSThread: 0x7fb1826047b0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">GCD[11750:1914722] ----2-----&lt;NSThread: 0x7fb182423fd0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">GCD[11750:1914722] ---barrier&lt;NSThread: 0x7fb182423fd0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">GCD[11750:1914722] ----3-----&lt;NSThread: 0x7fb182423fd0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">GCD[11750:1914724] ----4-----&lt;NSThread: 0x7fb1826047b0&gt;&#123;number = 2, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以看出在执行完栅栏前面的操作之后，才执行栅栏操作，最后再执行栅栏后边的操作。</p>\n</li>\n</ul>\n<h5 id=\"6-2-GCD的延时执行方法-dispatch-after\"><a href=\"#6-2-GCD的延时执行方法-dispatch-after\" class=\"headerlink\" title=\"6.2 GCD的延时执行方法 dispatch_after\"></a>6.2 GCD的延时执行方法 <code>dispatch_after</code></h5><ul>\n<li><p>当我们需要延迟执行一段代码时，就需要用到GCD的<code>dispatch_after</code>方法。</p>\n</li>\n<li><p><code>dispatch_after</code>能让我们添加进队列的任务延时执行，比如想让一个Block在2秒后执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC));</span><br><span class=\"line\">dispatch_after(time, dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    // 2秒后异步执行这里的代码...</span><br><span class=\"line\">   NSLog(@&quot;run-----&quot;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>NSEC_PER_SEC</code>表示的是秒数，它还提供了<code>NSEC_PER_MSEC</code>表示毫秒。</p>\n<p>上面这句<code>dispatch_after</code>的真正含义是在2秒后把任务添加进队列中，并不是表示在2秒后执行，大部分情况该函数能达到我们的预期，只有在对时间要求非常精准的情况下才可能会出现问题。</p>\n<p>获取一个<code>dispatch_time_t</code>类型的值可以通过两种方式来获取，以上是第一种方式，即通过<code>dispatch_time</code>函数，另一种是通过<code>dispatch_walltime</code>函数来获取，<code>dispatch_walltime</code>需要使用一个timespec的结构体来得到<code>dispatch_time_t</code>。通常<code>dispatch_time</code>用于计算相对时间，<code>dispatch_walltime</code>用于计算绝对时间</p>\n</li>\n</ul>\n<h5 id=\"6-3-GCD的一次性代码-只执行一次-dispatch-once\"><a href=\"#6-3-GCD的一次性代码-只执行一次-dispatch-once\" class=\"headerlink\" title=\"6.3 GCD的一次性代码(只执行一次) dispatch_once\"></a>6.3 GCD的一次性代码(只执行一次) <code>dispatch_once</code></h5><ul>\n<li><p>我们在创建单例、或者有整个程序运行过程中只执行一次的代码时，我们就用到了GCD的<code>dispatch_once</code>方法。使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static dispatch_once_t onceToken;</span><br><span class=\"line\">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">    // 只执行1次的代码(这里面默认是线程安全的)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"6-4-GCD的快速迭代方法-dispatch-apply\"><a href=\"#6-4-GCD的快速迭代方法-dispatch-apply\" class=\"headerlink\" title=\"6.4 GCD的快速迭代方法 dispatch_apply\"></a>6.4 GCD的快速迭代方法 <code>dispatch_apply</code></h5><ul>\n<li><p>通常我们会用for循环遍历，但是GCD给我们提供了快速迭代的方法<code>dispatch_apply</code>，使我们可以同时遍历。比如说遍历0~5这6个数字，for循环的做法是每次取出一个元素，逐个遍历。<code>dispatch_apply</code>可以同时遍历多个数字。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_apply(6, queue, ^(size_t index) &#123;</span><br><span class=\"line\">    NSLog(@&quot;%zd------%@&quot;,index, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果：</span><br><span class=\"line\">GCD[11764:1915764] 1------&lt;NSThread: 0x7fac9a7029e0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11764:1915885] 0------&lt;NSThread: 0x7fac9a614bd0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">GCD[11764:1915886] 2------&lt;NSThread: 0x7fac9a542b20&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">GCD[11764:1915764] 4------&lt;NSThread: 0x7fac9a7029e0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11764:1915884] 3------&lt;NSThread: 0x7fac9a76ca10&gt;&#123;number = 4, name = (null)&#125;</span><br><span class=\"line\">GCD[11764:1915885] 5------&lt;NSThread: 0x7fac9a614bd0&gt;&#123;number = 2, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>从输出结果中前边的时间中可以看出，几乎是同时遍历的。</p>\n</li>\n</ul>\n<h5 id=\"6-5-GCD的队列组-dispatch-group\"><a href=\"#6-5-GCD的队列组-dispatch-group\" class=\"headerlink\" title=\"6.5 GCD的队列组 dispatch_group\"></a>6.5 GCD的队列组 <code>dispatch_group</code></h5><ul>\n<li><p>有时候我们会有这样的需求：分别异步执行2个耗时操作，然后当2个耗时操作都执行完毕后再回到主线程执行操作。这时候我们可以用到GCD的队列组。</p>\n<ul>\n<li>我们可以先把任务放到队列中，然后将队列放入队列组中。()</li>\n<li>调用队列组的<code>dispatch_group_notify</code>回到主线程执行操作。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_group_t group =  dispatch_group_create();</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\">    // 执行1个耗时的异步操作</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\">    // 执行1个耗时的异步操作</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    // 等前面的异步操作都执行完毕后，回到主线程...</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>（<code>dispatch_group_enter</code> &lt;—&gt;<code>dispatch_group_leave</code>) <code>enter&lt;—&gt;leave</code>会阻塞当前线程执行<code>enter&lt;—&gt;leave</code>对之前的<strong>blocks</strong>会和<code>enter&lt;—&gt;leave</code>对之内的操作同时执行，当<code>enter&lt;—&gt;leave</code>对之间的任务执行完毕当前线程继续执行。</p>\n</li>\n</ul>\n<ul>\n<li><code>dispatch_group_wait</code>阻塞当前线程，当<code>dispatch_group</code>的blocks全部执行完毕之后执行<code>dispatch_group_wait</code>之后的操作。</li>\n</ul>\n<p><strong>注意</strong>：不建议在主线程使用， <strong>enter</strong>&lt;–&gt;<strong>leave</strong>一定要成对存在否则可能崩溃</p>\n<h5 id=\"6-6-信号量控制并发dispatch-semaphore\"><a href=\"#6-6-信号量控制并发dispatch-semaphore\" class=\"headerlink\" title=\"6.6 信号量控制并发dispatch_semaphore\"></a>6.6 信号量控制并发<code>dispatch_semaphore</code></h5><p>我们知道多线程开发最难的就是执行顺序的控制，苹果已经给我们封装好了一些流控制的东西，像dispatch_group，等但是有时候某些场景还是需要我们自己实现对代码执行的控制，毕竟我们不希望自己写的代码自己都不知道执行顺序，<code>dispatch_semaphore</code>就是为了这个目的而存在的，我们可以设置一个cout来控制程序按照我们的意愿来执行。</p>\n<ul>\n<li><p>dispatch_semaphore_create　　创建一个semaphore</p>\n</li>\n<li><p>dispatch_semaphore_signal　　发送一个信号</p>\n</li>\n<li><p>dispatch_semaphore_wait　　　等待信号</p>\n<blockquote>\n<p>简单的介绍一下这三个函数，第一个函数有一个整形的参数，我们可以理解为信号的总量，dispatch_semaphore_signal是发送一个信号，自然会让信号总量加1，dispatch_semaphore_wait等待信号，当信号总量少于0的时候就会一直等待，否则就可以正常的执行，并让信号总量-1，根据这样的原理，我们便可以快速的创建一个并发控制来同步任务和有限资源访问控制。</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t serQueue = dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\">    dispatch_queue_t conQueue = dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class=\"line\">    dispatch_async(conQueue, ^&#123;</span><br><span class=\"line\">        dispatch_sync(serQueue, ^&#123;</span><br><span class=\"line\">            NSLog(@&quot;发送信息&quot;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    NSLog(@&quot;---A---&quot;);</span><br><span class=\"line\">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_NOW);</span><br><span class=\"line\">    NSLog(@&quot;---B---&quot;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果</span><br><span class=\"line\">LQHelper[1389:56036] ---A---</span><br><span class=\"line\">LQHelper[1389:56139] 发送信息</span><br><span class=\"line\">LQHelper[1389:56036] ---B---</span><br></pre></td></tr></table></figure>\n<p><strong>注意：</strong>对于这样的阻塞线程的操作，最好不要放在主线程，除非特殊要求。我觉得这应该是我们用多线程开发的共识了。</p>\n<p>转载自<a href=\"http://www.jianshu.com/p/2d57c72016c6\" target=\"_blank\" rel=\"noopener\">iOS多线程–彻底学会多线程</a></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"1、什么是GCD\"><a href=\"#1、什么是GCD\" class=\"headerlink\" title=\"1、什么是GCD\"></a>1、什么是GCD</h4><blockquote>\n<p>Grand Central Dispatch (GCD) 是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并行任务。在Mac OS X 10.6雪豹中首次推出，也可在iOS 4及以上版本使用。(百度百科)</p>\n</blockquote>\n<p>GCD的好处：</p>\n<ul>\n<li>GCD可用于多核的并行运算</li>\n<li>GCD会自动利用更多的CPU内核（比如双核、四核）</li>\n<li>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li>\n<li>只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码</li></ul>","more":"\n\n<h4 id=\"2、任务和队列\"><a href=\"#2、任务和队列\" class=\"headerlink\" title=\"2、任务和队列\"></a>2、任务和队列</h4><p>学习GCD之前，先来了解GCD中两个核心概念：任务和队列。</p>\n<p><strong>任务：</strong>就是执行操作的意思，换句话说就是需要在线程中执行的那段代码。</p>\n<p>执行任务有两种方式：<strong>同步执行和异步执行</strong>。两者的主要区别是：<strong>是否具备开启新线程的能力</strong>。</p>\n<ul>\n<li>同步执行(sync)：只能在当前线程中执行任务，不具备开启新线程的能力。</li>\n<li>异步执行(async)：可以在新的线程中执行任务，具备开启新线程的能力。</li>\n</ul>\n<p><strong>队列：</strong>这里的队列指任务队列，即用来存放任务的队列。队列是一种特殊的线性表，采用FIFO(先进先出)的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。在GCD中有两种队列：<strong>串行队列和并行队列</strong>。</p>\n<ul>\n<li>串行队列(Serial Dispatch Queue)：让任务一个接一个的执行(一个任务执行完毕，再执行下一个任务)。</li>\n<li>并行队列(Concurrent Dispatch Queue)：可以让多个任务并行(同时)执行(自动开启多个线程同时执行任务)。</li>\n</ul>\n<h4 id=\"3、GCD的使用步骤\"><a href=\"#3、GCD的使用步骤\" class=\"headerlink\" title=\"3、GCD的使用步骤\"></a>3、GCD的使用步骤</h4><p>​    1、创建一个队列(串行或者并行队列)</p>\n<p>​    2、将任务添加到队列中，然后系统就会根据任务类型执行任务(同步执行或者异步执行)</p>\n<h5 id=\"3-1-队列的创建方法\"><a href=\"#3-1-队列的创建方法\" class=\"headerlink\" title=\"3.1 队列的创建方法\"></a>3.1 队列的创建方法</h5><p>​    可以使用<code>dispatch_queue_create</code>来创建对象，需要传入两个参数，第一个参数表示队列的唯一标识符，用于DEBUG，可以为空；第二个参数是用来识别是串行队列还是并行队列。<code>DISPATCH_QUEUE_SERIAL</code>表示串行队列，<code>DISPATCH_QUEUE_CONCURRENT</code>表示并行队列。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 串行队列的创建方法</span><br><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\">// 并行队列的创建方法</span><br><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>\n<p>​    对于并行队列，还可以使用   <code>dispatch_get_global_queue</code>来创建<strong>全局并行队列</strong>。GCD默认提供了全局的并行队列，需要传入两个参数。第一个参数表示队列优先级，一般用<code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code>。第二个参数暂时没用，用<code>0</code>即可。</p>\n<h5 id=\"3-2-任务的创建方法\"><a href=\"#3-2-任务的创建方法\" class=\"headerlink\" title=\"3.2 任务的创建方法\"></a>3.2 任务的创建方法</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 同步执行任务创建方法</span><br><span class=\"line\">dispatch_sync(queue, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);    // 这里放任务代码</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// 异步执行任务创建方法</span><br><span class=\"line\">dispatch_async(queue, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);    // 这里放任务代码</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>虽然使用GCD只需两步，但是既然我们有两种队列，两种任务执行方式，那么我们就有了四种不同的组合方式。这四种不同的组合方式是：</p>\n<blockquote>\n<ol>\n<li>并行队列 + 同步执行</li>\n<li>并行队列 + 异步执行</li>\n<li>串行队列 + 同步执行</li>\n<li>串行队列 + 异步执行</li>\n</ol>\n</blockquote>\n<p>实际上，我们还有一种特殊队列是主队列，那样就有六种不同的组合方式了。</p>\n<blockquote>\n<ol>\n<li>主队列 + 同步执行</li>\n<li>主队列 + 异步执行</li>\n</ol>\n</blockquote>\n<p>那么这几种不同组合方式各有什么区别呢，这里为了方便，先上结果，再来讲解。直接查看表格结果。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">并行队列</th>\n<th style=\"text-align:center\">串行队列</th>\n<th style=\"text-align:center\">主队列</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">同步(sync)</td>\n<td style=\"text-align:center\">没有开启新线程，串行执行任务</td>\n<td style=\"text-align:center\">没有开启新线程，串行执行任务</td>\n<td style=\"text-align:center\">没有开启新线程，串行执行任务</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">异步(async)</td>\n<td style=\"text-align:center\">有开启新线程，并行执行任务</td>\n<td style=\"text-align:center\">有开启新线程(1条)，并行执行任务</td>\n<td style=\"text-align:center\">没有开启新线程，串行执行任务</td>\n</tr>\n</tbody>\n</table>\n<p>下边我们来分别讲讲这几种不同的组合方式的使用方法。</p>\n<h4 id=\"4、GCD的基本使用\"><a href=\"#4、GCD的基本使用\" class=\"headerlink\" title=\"4、GCD的基本使用\"></a>4、GCD的基本使用</h4><h5 id=\"4-1-并行队列的两种使用方法\"><a href=\"#4-1-并行队列的两种使用方法\" class=\"headerlink\" title=\"4.1 并行队列的两种使用方法\"></a>4.1 并行队列的两种使用方法</h5><h6 id=\"4-1-1-并行队列-同步执行\"><a href=\"#4-1-1-并行队列-同步执行\" class=\"headerlink\" title=\"4.1.1 并行队列 + 同步执行\"></a>4.1.1 并行队列 + 同步执行</h6><ul>\n<li><p>不会开启新线程，执行完一个任务，再执行下一个任务</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void) syncConcurrent</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;syncConcurrent---begin&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_queue_t queue= dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_sync(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;1------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    dispatch_sync(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;2------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    dispatch_sync(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;3------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;syncConcurrent---end&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果：</span><br><span class=\"line\">GCD[11557:1897538] syncConcurrent---begin</span><br><span class=\"line\">GCD[11557:1897538] 1------&lt;NSThread: 0x7f82a1d058b0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11557:1897538] 1------&lt;NSThread: 0x7f82a1d058b0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11557:1897538] 2------&lt;NSThread: 0x7f82a1d058b0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11557:1897538] 2------&lt;NSThread: 0x7f82a1d058b0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11557:1897538] 3------&lt;NSThread: 0x7f82a1d058b0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11557:1897538] 3------&lt;NSThread: 0x7f82a1d058b0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11557:1897538] syncConcurrent---end</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>从<code>并行队列 + 同步执行</code>中可以看到，所有任务都是在主线程中执行的。由于只有一个线程，所以任务只能一个一个执行。</p>\n</li>\n<li>同时我们还可以看到，所有任务都在打印的<code>syncConcurrent---begin</code>和<code>syncConcurrent---end</code>之间，这说明任务是添加到队列中马上执行的。</li>\n</ul>\n<h6 id=\"4-1-2-并行队列-异步步执行\"><a href=\"#4-1-2-并行队列-异步步执行\" class=\"headerlink\" title=\"4.1.2 并行队列 + 异步步执行\"></a>4.1.2 并行队列 + 异步步执行</h6><ul>\n<li><p>可同时开启多线程，任务交替执行</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void) asyncConcurrent</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    NSLog(@&quot;asyncConcurrent---begin&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_queue_t queue= dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;1------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;2------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;3------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;asyncConcurrent---end&quot;);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果：</span><br><span class=\"line\">GCD[11595:1901548] asyncConcurrent---begin</span><br><span class=\"line\">GCD[11595:1901548] asyncConcurrent---end</span><br><span class=\"line\">GCD[11595:1901626] 1------&lt;NSThread: 0x7f8309c22080&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">GCD[11595:1901625] 2------&lt;NSThread: 0x7f8309f0b790&gt;&#123;number = 4, name = (null)&#125;</span><br><span class=\"line\">GCD[11595:1901855] 3------&lt;NSThread: 0x7f8309e1a950&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">GCD[11595:1901626] 1------&lt;NSThread: 0x7f8309c22080&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">GCD[11595:1901625] 2------&lt;NSThread: 0x7f8309f0b790&gt;&#123;number = 4, name = (null)&#125;</span><br><span class=\"line\">GCD[11595:1901855] 3------&lt;NSThread: 0x7f8309e1a950&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在<code>并行队列 + 异步执行</code>中可以看出，除了主线程，又开启了3个线程，并且任务是交替着同时执行的。</p>\n</li>\n<li>另一方面可以看出，所有任务是在打印的<code>syncConcurrent—begin</code>和<code>syncConcurrent—end</code>之后才开始执行的。说明任务不是马上执行，而是将所有任务添加到队列之后才开始异步执行。</li>\n</ul>\n<h5 id=\"4-2-串行队列的两种使用方法\"><a href=\"#4-2-串行队列的两种使用方法\" class=\"headerlink\" title=\"4.2 串行队列的两种使用方法\"></a>4.2 串行队列的两种使用方法</h5><h6 id=\"4-2-1-串行队列-同步执行\"><a href=\"#4-2-1-串行队列-同步执行\" class=\"headerlink\" title=\"4.2.1 串行队列 + 同步执行\"></a>4.2.1 串行队列 + 同步执行</h6><ul>\n<li><p>不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void) syncSerial</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;syncSerial---begin&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_queue_t queue = dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_sync(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;1------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);    </span><br><span class=\"line\">    dispatch_sync(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;2------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    dispatch_sync(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;3------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;syncSerial---end&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果为：</span><br><span class=\"line\">GCD[11622:1903904] syncSerial---begin</span><br><span class=\"line\">GCD[11622:1903904] 1------&lt;NSThread: 0x7fa2e9f00980&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11622:1903904] 1------&lt;NSThread: 0x7fa2e9f00980&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11622:1903904] 2------&lt;NSThread: 0x7fa2e9f00980&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11622:1903904] 2------&lt;NSThread: 0x7fa2e9f00980&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11622:1903904] 3------&lt;NSThread: 0x7fa2e9f00980&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11622:1903904] 3------&lt;NSThread: 0x7fa2e9f00980&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11622:1903904] syncSerial---end</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在<code>串行队列 + 同步执行</code>可以看到，所有任务都是在主线程中执行的，并没有开启新的线程。而且由于串行队列，所以按顺序一个一个执行。</li>\n<li>同时我们还可以看到，所有任务都在打印的<code>syncConcurrent—begin</code>和<code>syncConcurrent—end</code>之间，这说明任务是添加到队列中马上执行的。</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"4-2-2-串行队列-异步执行\"><a href=\"#4-2-2-串行队列-异步执行\" class=\"headerlink\" title=\"4.2.2 串行队列 + 异步执行\"></a>4.2.2 串行队列 + 异步执行</h6><ul>\n<li><p>会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void) asyncSerial</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;asyncSerial---begin&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_queue_t queue = dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;1------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);    </span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;2------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;3------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;asyncSerial---end&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果为：</span><br><span class=\"line\">GCD[11648:1905817] asyncSerial---begin</span><br><span class=\"line\">GCD[11648:1905817] asyncSerial---end</span><br><span class=\"line\">GCD[11648:1905895] 1------&lt;NSThread: 0x7fb548c0e390&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">GCD[11648:1905895] 1------&lt;NSThread: 0x7fb548c0e390&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">GCD[11648:1905895] 2------&lt;NSThread: 0x7fb548c0e390&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">GCD[11648:1905895] 2------&lt;NSThread: 0x7fb548c0e390&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">GCD[11648:1905895] 3------&lt;NSThread: 0x7fb548c0e390&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">GCD[11648:1905895] 3------&lt;NSThread: 0x7fb548c0e390&gt;&#123;number = 2, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在<code>串行队列 + 异步执行</code>可以看到，开启了一条新线程，但是任务还是串行，所以任务是一个一个执行。</p>\n</li>\n<li>另一方面可以看出，所有任务是在打印的<code>syncConcurrent---begin</code>和<code>syncConcurrent---end</code>之后才开始执行的。说明任务不是马上执行，而是将所有任务添加到队列之后才开始同步执行。</li>\n</ul>\n<h5 id=\"4-3-主队列\"><a href=\"#4-3-主队列\" class=\"headerlink\" title=\"4.3 主队列\"></a>4.3 主队列</h5><ul>\n<li>主队列：GCD自带的一种特殊的<strong>串行队列</strong><ul>\n<li>所有放在主队列中的任务，都会放到主线程中执行</li>\n<li>可使用<code>dispatch_get_main_queue()</code>获得主队列</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"4-3-1-主队列-同步执行\"><a href=\"#4-3-1-主队列-同步执行\" class=\"headerlink\" title=\"4.3.1 主队列 + 同步执行\"></a>4.3.1 主队列 + 同步执行</h6><ul>\n<li><p>互等卡住不可行(在主线程中调用)</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)syncMain</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;syncMain---begin&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_sync(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;1------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    dispatch_sync(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;2------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    dispatch_sync(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;3------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);   </span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;syncMain---end&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果</span><br><span class=\"line\">2016-09-03 19:32:15.356 GCD[11670:1908306] syncMain---begin</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这时候，我们惊奇的发现，在主线程中使用主队列 + 同步执行，任务不再执行了，而且syncMain—end也没有打印。这是为什么呢？</p>\n</li>\n<li><p>这是因为我们在主线程中执行这段代码。我们把任务放到了主队列中，也就是放到了主线程的队列中。而同步执行有个特点，就是对于任务是立马执行的。那么当我们把第一个任务放进主队列中，它就会立马执行。但是主线程现在正在处理syncMain方法，所以任务需要等syncMain执行完才能执行。而syncMain执行到第一个任务的时候，又要等第一个任务执行完才能往下执行第二个和第三个任务。</p>\n</li>\n<li><p>那么，现在的情况就是<code>syncMain</code>方法和第一个任务都在等对方执行完毕。这样大家互相等待，所以就卡住了，所以我们的任务执行不了，而且<code>syncMain---end</code>也没有打印。</p>\n<p>  <strong>要是如果不再主线程中调用，而在其他线程中调用会如何呢？</strong></p>\n</li>\n<li><p>不会开启新线程，执行完一个任务，再执行下一个任务（在其他线程中调用）</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(queue, ^&#123;</span><br><span class=\"line\">    [self syncMain];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果：</span><br><span class=\"line\">GCD[11686:1909617] syncMain---begin</span><br><span class=\"line\">GCD[11686:1909374] 1------&lt;NSThread: 0x7faef2f01600&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11686:1909374] 1------&lt;NSThread: 0x7faef2f01600&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11686:1909374] 2------&lt;NSThread: 0x7faef2f01600&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11686:1909374] 2------&lt;NSThread: 0x7faef2f01600&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11686:1909374] 3------&lt;NSThread: 0x7faef2f01600&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11686:1909374] 3------&lt;NSThread: 0x7faef2f01600&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11686:1909617] syncMain---end</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在其他线程中使用<code>主队列 + 同步执行</code>可看到：所有任务都是在主线程中执行的，并没有开启新的线程。而且由于主队列是串行队列，所以按顺序一个一个执行。</p>\n</li>\n</ul>\n<ul>\n<li>同时我们还可以看到，所有任务都在打印的syncConcurrent—begin和syncConcurrent—end之间，这说明任务是添加到队列中马上执行的。</li>\n</ul>\n<h6 id=\"4-3-2-主队列-异步执行\"><a href=\"#4-3-2-主队列-异步执行\" class=\"headerlink\" title=\"4.3.2 主队列 + 异步执行\"></a>4.3.2 主队列 + 异步执行</h6><ul>\n<li><p>只在主线程中执行任务，执行完一个任务，再执行下一个任务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)asyncMain</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;asyncMain---begin&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class=\"line\">    </span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;1------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);    </span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;2------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;3------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);  </span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;asyncMain---end&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果：</span><br><span class=\"line\">GCD[11706:1911313] asyncMain---begin</span><br><span class=\"line\">GCD[11706:1911313] asyncMain---end</span><br><span class=\"line\">GCD[11706:1911313] 1------&lt;NSThread: 0x7fb623d015e0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11706:1911313] 1------&lt;NSThread: 0x7fb623d015e0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11706:1911313] 2------&lt;NSThread: 0x7fb623d015e0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11706:1911313] 2------&lt;NSThread: 0x7fb623d015e0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11706:1911313] 3------&lt;NSThread: 0x7fb623d015e0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11706:1911313] 3------&lt;NSThread: 0x7fb623d015e0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>我们发现所有任务都在主线程中，虽然是异步执行，具备开启线程的能力，但因为是主队列，所以所有任务都在主线程中，并且一个接一个执行。</p>\n</li>\n<li>另一方面可以看出，所有任务是在打印的<code>syncConcurrent---begin</code>和<code>syncConcurrent---end</code>之后才开始执行的。说明任务不是马上执行，而是将所有任务添加到队列之后才开始同步执行。</li>\n</ul>\n<h4 id=\"5-GCD线程之间的通讯\"><a href=\"#5-GCD线程之间的通讯\" class=\"headerlink\" title=\"5. GCD线程之间的通讯\"></a>5. GCD线程之间的通讯</h4><p>​    在iOS开发过程中，我们一般在主线程里边进行UI刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\">    for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">        NSLog(@&quot;1------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 回到主线程</span><br><span class=\"line\">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        NSLog(@&quot;2------%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果：</span><br><span class=\"line\">GCD[11728:1913039] 1------&lt;NSThread: 0x7f8319c06820&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">GCD[11728:1913039] 1------&lt;NSThread: 0x7f8319c06820&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">GCD[11728:1912961] 2------&lt;NSThread: 0x7f8319e00560&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>可以看到在其他线程中先执行操作，执行完了之后回到主线程执行主线程的相应操作。</li>\n</ul>\n<h4 id=\"6-GCD的其他方法\"><a href=\"#6-GCD的其他方法\" class=\"headerlink\" title=\"6. GCD的其他方法\"></a>6. GCD的其他方法</h4><h5 id=\"6-1-GCD的栅栏方法-dispatch-barrier-async\"><a href=\"#6-1-GCD的栅栏方法-dispatch-barrier-async\" class=\"headerlink\" title=\"6.1 GCD的栅栏方法 dispatch_barrier_async\"></a>6.1 GCD的栅栏方法 <code>dispatch_barrier_async</code></h5><ul>\n<li><p>我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于栅栏一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到dispatch_barrier_async方法在两个操作组间形成栅栏。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)barrier</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    dispatch_queue_t queue = dispatch_queue_create(&quot;12312312&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        NSLog(@&quot;----1-----%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        NSLog(@&quot;----2-----%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_barrier_async(queue, ^&#123;</span><br><span class=\"line\">        NSLog(@&quot;---barrier%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        NSLog(@&quot;----3-----%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        NSLog(@&quot;----4-----%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果：</span><br><span class=\"line\">GCD[11750:1914724] ----1-----&lt;NSThread: 0x7fb1826047b0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">GCD[11750:1914722] ----2-----&lt;NSThread: 0x7fb182423fd0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">GCD[11750:1914722] ---barrier&lt;NSThread: 0x7fb182423fd0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">GCD[11750:1914722] ----3-----&lt;NSThread: 0x7fb182423fd0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">GCD[11750:1914724] ----4-----&lt;NSThread: 0x7fb1826047b0&gt;&#123;number = 2, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以看出在执行完栅栏前面的操作之后，才执行栅栏操作，最后再执行栅栏后边的操作。</p>\n</li>\n</ul>\n<h5 id=\"6-2-GCD的延时执行方法-dispatch-after\"><a href=\"#6-2-GCD的延时执行方法-dispatch-after\" class=\"headerlink\" title=\"6.2 GCD的延时执行方法 dispatch_after\"></a>6.2 GCD的延时执行方法 <code>dispatch_after</code></h5><ul>\n<li><p>当我们需要延迟执行一段代码时，就需要用到GCD的<code>dispatch_after</code>方法。</p>\n</li>\n<li><p><code>dispatch_after</code>能让我们添加进队列的任务延时执行，比如想让一个Block在2秒后执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC));</span><br><span class=\"line\">dispatch_after(time, dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    // 2秒后异步执行这里的代码...</span><br><span class=\"line\">   NSLog(@&quot;run-----&quot;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>NSEC_PER_SEC</code>表示的是秒数，它还提供了<code>NSEC_PER_MSEC</code>表示毫秒。</p>\n<p>上面这句<code>dispatch_after</code>的真正含义是在2秒后把任务添加进队列中，并不是表示在2秒后执行，大部分情况该函数能达到我们的预期，只有在对时间要求非常精准的情况下才可能会出现问题。</p>\n<p>获取一个<code>dispatch_time_t</code>类型的值可以通过两种方式来获取，以上是第一种方式，即通过<code>dispatch_time</code>函数，另一种是通过<code>dispatch_walltime</code>函数来获取，<code>dispatch_walltime</code>需要使用一个timespec的结构体来得到<code>dispatch_time_t</code>。通常<code>dispatch_time</code>用于计算相对时间，<code>dispatch_walltime</code>用于计算绝对时间</p>\n</li>\n</ul>\n<h5 id=\"6-3-GCD的一次性代码-只执行一次-dispatch-once\"><a href=\"#6-3-GCD的一次性代码-只执行一次-dispatch-once\" class=\"headerlink\" title=\"6.3 GCD的一次性代码(只执行一次) dispatch_once\"></a>6.3 GCD的一次性代码(只执行一次) <code>dispatch_once</code></h5><ul>\n<li><p>我们在创建单例、或者有整个程序运行过程中只执行一次的代码时，我们就用到了GCD的<code>dispatch_once</code>方法。使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static dispatch_once_t onceToken;</span><br><span class=\"line\">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">    // 只执行1次的代码(这里面默认是线程安全的)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"6-4-GCD的快速迭代方法-dispatch-apply\"><a href=\"#6-4-GCD的快速迭代方法-dispatch-apply\" class=\"headerlink\" title=\"6.4 GCD的快速迭代方法 dispatch_apply\"></a>6.4 GCD的快速迭代方法 <code>dispatch_apply</code></h5><ul>\n<li><p>通常我们会用for循环遍历，但是GCD给我们提供了快速迭代的方法<code>dispatch_apply</code>，使我们可以同时遍历。比如说遍历0~5这6个数字，for循环的做法是每次取出一个元素，逐个遍历。<code>dispatch_apply</code>可以同时遍历多个数字。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_apply(6, queue, ^(size_t index) &#123;</span><br><span class=\"line\">    NSLog(@&quot;%zd------%@&quot;,index, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果：</span><br><span class=\"line\">GCD[11764:1915764] 1------&lt;NSThread: 0x7fac9a7029e0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11764:1915885] 0------&lt;NSThread: 0x7fac9a614bd0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">GCD[11764:1915886] 2------&lt;NSThread: 0x7fac9a542b20&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">GCD[11764:1915764] 4------&lt;NSThread: 0x7fac9a7029e0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">GCD[11764:1915884] 3------&lt;NSThread: 0x7fac9a76ca10&gt;&#123;number = 4, name = (null)&#125;</span><br><span class=\"line\">GCD[11764:1915885] 5------&lt;NSThread: 0x7fac9a614bd0&gt;&#123;number = 2, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>从输出结果中前边的时间中可以看出，几乎是同时遍历的。</p>\n</li>\n</ul>\n<h5 id=\"6-5-GCD的队列组-dispatch-group\"><a href=\"#6-5-GCD的队列组-dispatch-group\" class=\"headerlink\" title=\"6.5 GCD的队列组 dispatch_group\"></a>6.5 GCD的队列组 <code>dispatch_group</code></h5><ul>\n<li><p>有时候我们会有这样的需求：分别异步执行2个耗时操作，然后当2个耗时操作都执行完毕后再回到主线程执行操作。这时候我们可以用到GCD的队列组。</p>\n<ul>\n<li>我们可以先把任务放到队列中，然后将队列放入队列组中。()</li>\n<li>调用队列组的<code>dispatch_group_notify</code>回到主线程执行操作。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_group_t group =  dispatch_group_create();</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\">    // 执行1个耗时的异步操作</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\">    // 执行1个耗时的异步操作</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    // 等前面的异步操作都执行完毕后，回到主线程...</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>（<code>dispatch_group_enter</code> &lt;—&gt;<code>dispatch_group_leave</code>) <code>enter&lt;—&gt;leave</code>会阻塞当前线程执行<code>enter&lt;—&gt;leave</code>对之前的<strong>blocks</strong>会和<code>enter&lt;—&gt;leave</code>对之内的操作同时执行，当<code>enter&lt;—&gt;leave</code>对之间的任务执行完毕当前线程继续执行。</p>\n</li>\n</ul>\n<ul>\n<li><code>dispatch_group_wait</code>阻塞当前线程，当<code>dispatch_group</code>的blocks全部执行完毕之后执行<code>dispatch_group_wait</code>之后的操作。</li>\n</ul>\n<p><strong>注意</strong>：不建议在主线程使用， <strong>enter</strong>&lt;–&gt;<strong>leave</strong>一定要成对存在否则可能崩溃</p>\n<h5 id=\"6-6-信号量控制并发dispatch-semaphore\"><a href=\"#6-6-信号量控制并发dispatch-semaphore\" class=\"headerlink\" title=\"6.6 信号量控制并发dispatch_semaphore\"></a>6.6 信号量控制并发<code>dispatch_semaphore</code></h5><p>我们知道多线程开发最难的就是执行顺序的控制，苹果已经给我们封装好了一些流控制的东西，像dispatch_group，等但是有时候某些场景还是需要我们自己实现对代码执行的控制，毕竟我们不希望自己写的代码自己都不知道执行顺序，<code>dispatch_semaphore</code>就是为了这个目的而存在的，我们可以设置一个cout来控制程序按照我们的意愿来执行。</p>\n<ul>\n<li><p>dispatch_semaphore_create　　创建一个semaphore</p>\n</li>\n<li><p>dispatch_semaphore_signal　　发送一个信号</p>\n</li>\n<li><p>dispatch_semaphore_wait　　　等待信号</p>\n<blockquote>\n<p>简单的介绍一下这三个函数，第一个函数有一个整形的参数，我们可以理解为信号的总量，dispatch_semaphore_signal是发送一个信号，自然会让信号总量加1，dispatch_semaphore_wait等待信号，当信号总量少于0的时候就会一直等待，否则就可以正常的执行，并让信号总量-1，根据这样的原理，我们便可以快速的创建一个并发控制来同步任务和有限资源访问控制。</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t serQueue = dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\">    dispatch_queue_t conQueue = dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class=\"line\">    dispatch_async(conQueue, ^&#123;</span><br><span class=\"line\">        dispatch_sync(serQueue, ^&#123;</span><br><span class=\"line\">            NSLog(@&quot;发送信息&quot;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    NSLog(@&quot;---A---&quot;);</span><br><span class=\"line\">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_NOW);</span><br><span class=\"line\">    NSLog(@&quot;---B---&quot;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果</span><br><span class=\"line\">LQHelper[1389:56036] ---A---</span><br><span class=\"line\">LQHelper[1389:56139] 发送信息</span><br><span class=\"line\">LQHelper[1389:56036] ---B---</span><br></pre></td></tr></table></figure>\n<p><strong>注意：</strong>对于这样的阻塞线程的操作，最好不要放在主线程，除非特殊要求。我觉得这应该是我们用多线程开发的共识了。</p>\n<p>转载自<a href=\"http://www.jianshu.com/p/2d57c72016c6\" target=\"_blank\" rel=\"noopener\">iOS多线程–彻底学会多线程</a></p>"},{"title":"GCD学习 —— 四","date":"2017-12-09T03:36:00.000Z","_content":"#### GCD方法注释\n\n- `Dispatch Queues` 中的任务按照FIFO的顺序进行处理，并且，由于加入任务的方式不同，执行分为同步／异步。\n- `Dispatch Groups` 可以帮助我们处理如何判断多线程全部执行结束的问题\n- `Dispatch Semaphores` 帮助我们控制多任务对有限数量资源的访问\n- `Dispatch Objects` 帮助我们对线程队列进行更加细致的控制（挂起、恢复、取消、激活等操作）\n- `Dispatch Once` 可以帮助我们确保某个函数只执行一次，可用于单例的实现\n  <!-- more -->\n```objective-c\n/******************dispatch_queue**********************/\n/* \n功能：将块函数添加到线程队列中异步执行（异步：执行后不管结果直接返回）\n参数：queue：指定的队列   block／work 块函数（context：传入block块函数中的参数）\n返回值：空\n*/\nvoid dispatch_async(dispatch_queue_t queue, dispatch_block_t block);\nvoid dispatch_async_f(dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work);\n\n/* \n功能：将块函数添加到线程队列中同步执行（异步：执行完成后返回结果）\n参数：queue：指定的队列   block／work 块函数（context：传入block块函数中的参数）\n返回值：空\n*/\nvoid dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);\nvoid dispatch_sync_f(dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work);\n\n/* \n功能：将块函数添加到线程队列中按照迭代次数执行，所有迭代完成后返回结果\n参数：iterations：迭代次数  queue：指定的队列   block／work 块函数（context：传入block块函数中的参数）\n返回值：空\n*/\nvoid dispatch_apply(size_t iterations, dispatch_queue_t queue, DISPATCH_NOESCAPE void (^block)(size_t));\nvoid dispatch_apply_f(size_t iterations, dispatch_queue_t queue, void *_Nullable context, void (*work)(void *_Nullable, size_t));\n\n/*\n功能：获取当前执行中的队列\n参数：无\n返回值：当前队列或者空\n*/\ndispatch_queue_t dispatch_get_current_queue(void);\n\n/* \n功能：获取主队列\n参数：无\n返回值：主队列或者空\n*/\ndispatch_queue_t dispatch_get_main_queue(void)\n{\n\treturn DISPATCH_GLOBAL_OBJECT(dispatch_queue_t, _dispatch_main_q);\n}\n\n/* \n功能：获取全局并发队列\n参数：identifier：队列优先级  typedef long dispatch_queue_priority_t;\n\\- DISPATCH_QUEUE_PRIORITY_HIGH:         QOS_CLASS_USER_INITIATED\n\\- DISPATCH_QUEUE_PRIORITY_DEFAULT:      QOS_CLASS_DEFAULT\n\\- DISPATCH_QUEUE_PRIORITY_LOW:          QOS_CLASS_UTILITY\n\\- DISPATCH_QUEUE_PRIORITY_BACKGROUND:   QOS_CLASS_BACKGROUND\n\\#define DISPATCH_QUEUE_PRIORITY_HIGH 2\n\\#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0\n\\#define DISPATCH_QUEUE_PRIORITY_LOW (-2)\n\\#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN\n  flags：保留供将来使用，输入除了0以外的任何值可能返回空值\n返回值：全局队列或者空\n*/\ndispatch_queue_t dispatch_get_global_queue(long identifier, unsigned long flags);\n#define DISPATCH_QUEUE_SERIAL NULL  //串行队列\n#define DISPATCH_QUEUE_SERIAL_INACTIVE//暂停状态串行队列\ndispatch_queue_attr_make_initially_inactive(DISPATCH_QUEUE_SERIAL)\n#define DISPATCH_QUEUE_CONCURRENT //并行队列\nDISPATCH_GLOBAL_OBJECT(dispatch_queue_attr_t, _dispatch_queue_attr_concurrent)\n#define DISPATCH_QUEUE_CONCURRENT_INACTIVE  //暂停状态并发队列\ndispatch_queue_attr_make_initially_inactive(DISPATCH_QUEUE_CONCURRENT)\n  \n/* \n功能：设置属性值，用于在队列的创建时加入\n参数：attr：队列属性值\n返回值：队列属性值\n*/\ndispatch_queue_attr_t dispatch_queue_attr_make_initially_inactive(\ndispatch_queue_attr_t _Nullable attr);\n#define DISPATCH_QUEUE_SERIAL_WITH_AUTORELEASE_POOL \ndispatch_queue_attr_make_with_autorelease_frequency(\nDISPATCH_QUEUE_SERIAL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM)\n#define DISPATCH_QUEUE_CONCURRENT_WITH_AUTORELEASE_POOL\ndispatch_queue_attr_make_with_autorelease_frequency(\n DISPATCH_QUEUE_CONCURRENT, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM)\ndispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(\ndispatch_queue_attr_t _Nullable attr,dispatch_autorelease_frequency_t frequency);\n\n/* \n功能：创建队列\n参数：label：队列附带信息，可有可无  attr：队列属性值  target：目标队列，相当于目标队列计数加一\n返回值：引用的队列\n*/\ndispatch_queue_t dispatch_queue_create(const char *_Nullable label, dispatch_queue_attr_t _Nullable attr);\ndispatch_queue_t dispatch_queue_create_with_target(const char *_Nullable label, dispatch_queue_attr_t _Nullable attr, dispatch_queue_t _Nullable target)\n\n/* \n功能：获取队列描述信息\n参数：label：队列附带信息，可有可无  attr：队列属性值  target：目标队列，相当于目标队列计数加一\n返回值：队列附带信息\n*/\nconst char *dispatch_queue_get_label(dispatch_queue_t _Nullable queue);\n\ndispatch_qos_class_t dispatch_queue_get_qos_class(dispatch_queue_t queue, int *_Nullable relative_priority_ptr);\n\n/* \n功能：给指定对象设置目标队列\n参数：object：目标对象  queue：目标队列\n返回值：无\n*/\nvoid dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t _Nullable queue);\n\n/* \n功能：dispatch类入口函数\n参数：无\n返回值：无\n*/\nvoid dispatch_main(void);\n\n/* \n功能：在指定时间后再目标队列执行block任务\n参数：when：时间 queue：目标队列  block／work：要执行的任务  context：传入任务中的参数\n返回值：无\n*/\nvoid dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);\nvoid dispatch_after_f(dispatch_time_t when, dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work);\n\n/* \n功能：给指定队列增加一个阻塞其它异步执行任务的任务\n参数：queue：队列  block／work：任务  context：传入任务的参数\n返回值：无\n*/\nvoid dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);\nvoid dispatch_barrier_async_f(dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work);\n\n/* \n功能：给指定队列增加一个阻塞其它同步执行任务的任务\n参数：queue：队列  block／work：任务  context：传入任务的参数\n返回值：无\n*/\nvoid dispatch_barrier_sync(dispatch_queue_t queue, DISPATCH_NOESCAPE dispatch_block_t block);\nvoid dispatch_barrier_sync_f(dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work);\n\n/* \n功能：当指定队列键值改变时，或者是所有属性值都释放后，调用销毁函数destructor\n参数：queue：队列  key：键名  context：新内容  destructor：销毁函数\n返回值：无\n*/\nvoid dispatch_queue_set_specific(dispatch_queue_t queue, const void *key, void *_Nullable context, dispatch_function_t _Nullable destructor);\n\n/* \n功能：获取指定队列特定键内容\n参数：queue：队列  key：键名  \n返回值：键值\n*/\nvoid *_Nullable dispatch_queue_get_specific(dispatch_queue_t queue, const void *key);\n\n/* \n功能：获取当前队列特定键内容\n参数： key：键名  \n返回值：键值\n*/\nvoid *_Nullable dispatch_get_specific(const void *key);\n\n/* \n功能：验证当前块任务运行在指定队列上\n参数：queue：队列 \n返回值：无\n*/\nvoid dispatch_assert_queue(dispatch_queue_t queue)\nDISPATCH_ALIAS_V2(dispatch_assert_queue);\n\n/* \n功能：验证当前块任务运行在指定队列上，并且该任务阻塞队列中的其它任务\n参数：queue：队列 \n返回值：无\n*/\n\nvoid dispatch_assert_queue_barrier(dispatch_queue_t queue);\n\n/* \n功能：验证当前块任务没有运行在指定队列上\n参数：queue：队列 \n返回值：无\n*/\nvoid dispatch_assert_queue_not(dispatch_queue_t queue)\nDISPATCH_ALIAS_V2(dispatch_assert_queue_not);\n\n/*************************dispatch_group*********************************/\n\n/* \n功能：创建派遣队列组\n参数：无\n返回值：队列组\n*/\ndispatch_group_t dispatch_group_create(void);\n\n/* \n功能：给指定队列添加异步执行任务，将队列加入组\n参数：group：队列组 queue：指定队列  block／work：任务  context：传入任务的参数\n返回值：无\n*/\nvoid dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);\nvoid dispatch_group_async_f(dispatch_group_t group, dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work);\n\n/* \n功能：等待（阻塞线程）一直到（队列组中所有任务执行结束或者是时间结束）\n参数：group：队列组 timeout：时间\n返回值：0表示成功，非0.错误\n*/\nlong dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout);\n\n/* \n功能：队列组中所有任务执行结束之后，执行新的block 任务\n参数：group：任务组 queue：指定队列  block／work：新任务  context：传入任务的参数\n返回值：任务组\n*/\nvoid dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);\nvoid dispatch_group_notify_f(dispatch_group_t group, dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work);\n\n/* \n功能：管理显示队列组中所有任务\n参数：group：队列组 \n返回值：队列组\n*/\nvoid dispatch_group_enter(dispatch_group_t group);\n\n/* \n功能：管理显示队列组中以执行结束的任务\n参数：group：队列组\n返回值：队列组\n*/\nvoid dispatch_group_leave(dispatch_group_t group);\n\n/*****************************dispatch_semaphore********************************/\n\n/* \n功能：创建信号量\n参数：value：信号量资源数\n返回值：信号量或空（失败）\n*/\ndispatch_semaphore_t dispatch_semaphore_create(long value);\n\n/* \n功能：等待获取信号量，获取到后开始继续执行，或是时间结束\n参数：dsema：信号量 timeout：限定时间\n返回值：无\n*/\nlong dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);\n\n/* \n功能：执行结束，不需要占用资源，释放信号量\n参数：dsema：信号量\n返回值：无\n*/\nlong dispatch_semaphore_signal(dispatch_semaphore_t dsema);\n\n/*****************************dispatch_object********************************/\n\n/* \n功能：增加队列引用计数\n参数：object：操作队列\n返回值：无\n*/\nvoid dispatch_retain(dispatch_object_t object);\n\n/* \n功能：减少队列引用计数\n参数：object：操作队列\n返回值：无\n*/\nvoid dispatch_release(dispatch_object_t object);\n\n/* \n功能：获取对象应用程序上下文\n参数：object：对象\n返回值：定义内容或空\n*/\nvoid *_Nullable dispatch_get_context(dispatch_object_t object);\n\n/* \n功能：设置指定对象的应用程序上下文\n参数：object：对象 context：上下文内容\n返回值：无\n*/\nvoid dispatch_set_context(dispatch_object_t object, void *_Nullable context);\n\n/* \n功能：设置对象销毁函数，在该对象所有引用释放后，销毁该对象\n参数：object：对象 finalizer：销毁函数指针\n返回值：无\n*/\nvoid dispatch_set_finalizer_f(dispatch_object_t object, dispatch_function_t _Nullable finalizer);\n\n/* \n功能：激活指定非活动对象\n参数：object：对象（一般是线程队列） \n返回值：无\n*/\nvoid dispatch_activate(dispatch_object_t object);\n\n/* \n功能：挂起／阻塞指定对象（一般是线程队列）\n参数：object：对象 \n返回值：无\n*/\nvoid dispatch_suspend(dispatch_object_t object);\n\n/* \n功能：恢复指定对象（一般是线程队列）\n参数：object：对象 \n返回值：无\n*/\nvoid dispatch_resume(dispatch_object_t object);\n\n/* \n功能：同步等待一个对象完成操作，或者是直到超出规定时间\n参数：object：对象  timeout：限定时间\n返回值：0成功，非0失败\n*/\nlong dispatch_wait(void *object, dispatch_time_t timeout);\n\n/* \n功能：在指定对象完成工作后，将一个通知块任务加入指定队列\n参数：object：对象  queue：队列 notification_block：通知块\n返回值：无\n*/\nvoid dispatch_notify(void *object, dispatch_object_t queue, dispatch_block_t notification_block);\n\n/* \n功能：取消指定对象\n参数：object：对象 \n返回值：无\n*/\nvoid dispatch_cancel(void *object);\n\n/* \n功能：判断指定对象是否被取消\n参数：object：对象 \n返回值：0表示未取消，其它表示取消\n*/\nlong dispatch_testcancel(void *object);\n\n/* \n功能：已编程方式记录指定对象的调试调度信息\n参数：object：对象 \n返回值：无\n*/\nvoid dispatch_debug(dispatch_object_t object, const char *message, ...);\nvoid dispatch_debugv(dispatch_object_t object, const char *message, va_list ap);\n\n/**********************************dispatch_once**********************************/\n\n/* \n功能：只执行任务函数一次\n参数：predicate：dispatch_once_t 对象  block／function要执行的任务函数 context：传入的内容\n返回值：无\n*/\nvoid dispatch_once(dispatch_once_t *predicate, DISPATCH_NOESCAPE dispatch_block_t block);\nvoid dispatch_once_f(dispatch_once_t *predicate, void *_Nullable context, dispatch_function_t function);\n\n/************************************dispatch_time*************************************/\n\n/* \n功能：创建时间对象，在指定时间的基础上再添加一段时间\n参数：when：时间  delta：时间段（纳秒）\n返回值：时间对象\n*/\ndispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta);\n\n/* \n功能：创建时间对象，在指定时间的基础上再添加一段时间\n参数：when：时间  delta时间段（纳秒）\n返回值：时间对象\n*/\ndispatch_time_t dispatch_walltime(const struct timespec *_Nullable when, int64_t delta);\n```","source":"_posts/GCD方法注释.md","raw":"---\ntitle: GCD学习 —— 四\ndate: 2017-12-09 11:36\ntags: iOS\ncategories: iOS Tips\n---\n#### GCD方法注释\n\n- `Dispatch Queues` 中的任务按照FIFO的顺序进行处理，并且，由于加入任务的方式不同，执行分为同步／异步。\n- `Dispatch Groups` 可以帮助我们处理如何判断多线程全部执行结束的问题\n- `Dispatch Semaphores` 帮助我们控制多任务对有限数量资源的访问\n- `Dispatch Objects` 帮助我们对线程队列进行更加细致的控制（挂起、恢复、取消、激活等操作）\n- `Dispatch Once` 可以帮助我们确保某个函数只执行一次，可用于单例的实现\n  <!-- more -->\n```objective-c\n/******************dispatch_queue**********************/\n/* \n功能：将块函数添加到线程队列中异步执行（异步：执行后不管结果直接返回）\n参数：queue：指定的队列   block／work 块函数（context：传入block块函数中的参数）\n返回值：空\n*/\nvoid dispatch_async(dispatch_queue_t queue, dispatch_block_t block);\nvoid dispatch_async_f(dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work);\n\n/* \n功能：将块函数添加到线程队列中同步执行（异步：执行完成后返回结果）\n参数：queue：指定的队列   block／work 块函数（context：传入block块函数中的参数）\n返回值：空\n*/\nvoid dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);\nvoid dispatch_sync_f(dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work);\n\n/* \n功能：将块函数添加到线程队列中按照迭代次数执行，所有迭代完成后返回结果\n参数：iterations：迭代次数  queue：指定的队列   block／work 块函数（context：传入block块函数中的参数）\n返回值：空\n*/\nvoid dispatch_apply(size_t iterations, dispatch_queue_t queue, DISPATCH_NOESCAPE void (^block)(size_t));\nvoid dispatch_apply_f(size_t iterations, dispatch_queue_t queue, void *_Nullable context, void (*work)(void *_Nullable, size_t));\n\n/*\n功能：获取当前执行中的队列\n参数：无\n返回值：当前队列或者空\n*/\ndispatch_queue_t dispatch_get_current_queue(void);\n\n/* \n功能：获取主队列\n参数：无\n返回值：主队列或者空\n*/\ndispatch_queue_t dispatch_get_main_queue(void)\n{\n\treturn DISPATCH_GLOBAL_OBJECT(dispatch_queue_t, _dispatch_main_q);\n}\n\n/* \n功能：获取全局并发队列\n参数：identifier：队列优先级  typedef long dispatch_queue_priority_t;\n\\- DISPATCH_QUEUE_PRIORITY_HIGH:         QOS_CLASS_USER_INITIATED\n\\- DISPATCH_QUEUE_PRIORITY_DEFAULT:      QOS_CLASS_DEFAULT\n\\- DISPATCH_QUEUE_PRIORITY_LOW:          QOS_CLASS_UTILITY\n\\- DISPATCH_QUEUE_PRIORITY_BACKGROUND:   QOS_CLASS_BACKGROUND\n\\#define DISPATCH_QUEUE_PRIORITY_HIGH 2\n\\#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0\n\\#define DISPATCH_QUEUE_PRIORITY_LOW (-2)\n\\#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN\n  flags：保留供将来使用，输入除了0以外的任何值可能返回空值\n返回值：全局队列或者空\n*/\ndispatch_queue_t dispatch_get_global_queue(long identifier, unsigned long flags);\n#define DISPATCH_QUEUE_SERIAL NULL  //串行队列\n#define DISPATCH_QUEUE_SERIAL_INACTIVE//暂停状态串行队列\ndispatch_queue_attr_make_initially_inactive(DISPATCH_QUEUE_SERIAL)\n#define DISPATCH_QUEUE_CONCURRENT //并行队列\nDISPATCH_GLOBAL_OBJECT(dispatch_queue_attr_t, _dispatch_queue_attr_concurrent)\n#define DISPATCH_QUEUE_CONCURRENT_INACTIVE  //暂停状态并发队列\ndispatch_queue_attr_make_initially_inactive(DISPATCH_QUEUE_CONCURRENT)\n  \n/* \n功能：设置属性值，用于在队列的创建时加入\n参数：attr：队列属性值\n返回值：队列属性值\n*/\ndispatch_queue_attr_t dispatch_queue_attr_make_initially_inactive(\ndispatch_queue_attr_t _Nullable attr);\n#define DISPATCH_QUEUE_SERIAL_WITH_AUTORELEASE_POOL \ndispatch_queue_attr_make_with_autorelease_frequency(\nDISPATCH_QUEUE_SERIAL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM)\n#define DISPATCH_QUEUE_CONCURRENT_WITH_AUTORELEASE_POOL\ndispatch_queue_attr_make_with_autorelease_frequency(\n DISPATCH_QUEUE_CONCURRENT, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM)\ndispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(\ndispatch_queue_attr_t _Nullable attr,dispatch_autorelease_frequency_t frequency);\n\n/* \n功能：创建队列\n参数：label：队列附带信息，可有可无  attr：队列属性值  target：目标队列，相当于目标队列计数加一\n返回值：引用的队列\n*/\ndispatch_queue_t dispatch_queue_create(const char *_Nullable label, dispatch_queue_attr_t _Nullable attr);\ndispatch_queue_t dispatch_queue_create_with_target(const char *_Nullable label, dispatch_queue_attr_t _Nullable attr, dispatch_queue_t _Nullable target)\n\n/* \n功能：获取队列描述信息\n参数：label：队列附带信息，可有可无  attr：队列属性值  target：目标队列，相当于目标队列计数加一\n返回值：队列附带信息\n*/\nconst char *dispatch_queue_get_label(dispatch_queue_t _Nullable queue);\n\ndispatch_qos_class_t dispatch_queue_get_qos_class(dispatch_queue_t queue, int *_Nullable relative_priority_ptr);\n\n/* \n功能：给指定对象设置目标队列\n参数：object：目标对象  queue：目标队列\n返回值：无\n*/\nvoid dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t _Nullable queue);\n\n/* \n功能：dispatch类入口函数\n参数：无\n返回值：无\n*/\nvoid dispatch_main(void);\n\n/* \n功能：在指定时间后再目标队列执行block任务\n参数：when：时间 queue：目标队列  block／work：要执行的任务  context：传入任务中的参数\n返回值：无\n*/\nvoid dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);\nvoid dispatch_after_f(dispatch_time_t when, dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work);\n\n/* \n功能：给指定队列增加一个阻塞其它异步执行任务的任务\n参数：queue：队列  block／work：任务  context：传入任务的参数\n返回值：无\n*/\nvoid dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);\nvoid dispatch_barrier_async_f(dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work);\n\n/* \n功能：给指定队列增加一个阻塞其它同步执行任务的任务\n参数：queue：队列  block／work：任务  context：传入任务的参数\n返回值：无\n*/\nvoid dispatch_barrier_sync(dispatch_queue_t queue, DISPATCH_NOESCAPE dispatch_block_t block);\nvoid dispatch_barrier_sync_f(dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work);\n\n/* \n功能：当指定队列键值改变时，或者是所有属性值都释放后，调用销毁函数destructor\n参数：queue：队列  key：键名  context：新内容  destructor：销毁函数\n返回值：无\n*/\nvoid dispatch_queue_set_specific(dispatch_queue_t queue, const void *key, void *_Nullable context, dispatch_function_t _Nullable destructor);\n\n/* \n功能：获取指定队列特定键内容\n参数：queue：队列  key：键名  \n返回值：键值\n*/\nvoid *_Nullable dispatch_queue_get_specific(dispatch_queue_t queue, const void *key);\n\n/* \n功能：获取当前队列特定键内容\n参数： key：键名  \n返回值：键值\n*/\nvoid *_Nullable dispatch_get_specific(const void *key);\n\n/* \n功能：验证当前块任务运行在指定队列上\n参数：queue：队列 \n返回值：无\n*/\nvoid dispatch_assert_queue(dispatch_queue_t queue)\nDISPATCH_ALIAS_V2(dispatch_assert_queue);\n\n/* \n功能：验证当前块任务运行在指定队列上，并且该任务阻塞队列中的其它任务\n参数：queue：队列 \n返回值：无\n*/\n\nvoid dispatch_assert_queue_barrier(dispatch_queue_t queue);\n\n/* \n功能：验证当前块任务没有运行在指定队列上\n参数：queue：队列 \n返回值：无\n*/\nvoid dispatch_assert_queue_not(dispatch_queue_t queue)\nDISPATCH_ALIAS_V2(dispatch_assert_queue_not);\n\n/*************************dispatch_group*********************************/\n\n/* \n功能：创建派遣队列组\n参数：无\n返回值：队列组\n*/\ndispatch_group_t dispatch_group_create(void);\n\n/* \n功能：给指定队列添加异步执行任务，将队列加入组\n参数：group：队列组 queue：指定队列  block／work：任务  context：传入任务的参数\n返回值：无\n*/\nvoid dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);\nvoid dispatch_group_async_f(dispatch_group_t group, dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work);\n\n/* \n功能：等待（阻塞线程）一直到（队列组中所有任务执行结束或者是时间结束）\n参数：group：队列组 timeout：时间\n返回值：0表示成功，非0.错误\n*/\nlong dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout);\n\n/* \n功能：队列组中所有任务执行结束之后，执行新的block 任务\n参数：group：任务组 queue：指定队列  block／work：新任务  context：传入任务的参数\n返回值：任务组\n*/\nvoid dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);\nvoid dispatch_group_notify_f(dispatch_group_t group, dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work);\n\n/* \n功能：管理显示队列组中所有任务\n参数：group：队列组 \n返回值：队列组\n*/\nvoid dispatch_group_enter(dispatch_group_t group);\n\n/* \n功能：管理显示队列组中以执行结束的任务\n参数：group：队列组\n返回值：队列组\n*/\nvoid dispatch_group_leave(dispatch_group_t group);\n\n/*****************************dispatch_semaphore********************************/\n\n/* \n功能：创建信号量\n参数：value：信号量资源数\n返回值：信号量或空（失败）\n*/\ndispatch_semaphore_t dispatch_semaphore_create(long value);\n\n/* \n功能：等待获取信号量，获取到后开始继续执行，或是时间结束\n参数：dsema：信号量 timeout：限定时间\n返回值：无\n*/\nlong dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);\n\n/* \n功能：执行结束，不需要占用资源，释放信号量\n参数：dsema：信号量\n返回值：无\n*/\nlong dispatch_semaphore_signal(dispatch_semaphore_t dsema);\n\n/*****************************dispatch_object********************************/\n\n/* \n功能：增加队列引用计数\n参数：object：操作队列\n返回值：无\n*/\nvoid dispatch_retain(dispatch_object_t object);\n\n/* \n功能：减少队列引用计数\n参数：object：操作队列\n返回值：无\n*/\nvoid dispatch_release(dispatch_object_t object);\n\n/* \n功能：获取对象应用程序上下文\n参数：object：对象\n返回值：定义内容或空\n*/\nvoid *_Nullable dispatch_get_context(dispatch_object_t object);\n\n/* \n功能：设置指定对象的应用程序上下文\n参数：object：对象 context：上下文内容\n返回值：无\n*/\nvoid dispatch_set_context(dispatch_object_t object, void *_Nullable context);\n\n/* \n功能：设置对象销毁函数，在该对象所有引用释放后，销毁该对象\n参数：object：对象 finalizer：销毁函数指针\n返回值：无\n*/\nvoid dispatch_set_finalizer_f(dispatch_object_t object, dispatch_function_t _Nullable finalizer);\n\n/* \n功能：激活指定非活动对象\n参数：object：对象（一般是线程队列） \n返回值：无\n*/\nvoid dispatch_activate(dispatch_object_t object);\n\n/* \n功能：挂起／阻塞指定对象（一般是线程队列）\n参数：object：对象 \n返回值：无\n*/\nvoid dispatch_suspend(dispatch_object_t object);\n\n/* \n功能：恢复指定对象（一般是线程队列）\n参数：object：对象 \n返回值：无\n*/\nvoid dispatch_resume(dispatch_object_t object);\n\n/* \n功能：同步等待一个对象完成操作，或者是直到超出规定时间\n参数：object：对象  timeout：限定时间\n返回值：0成功，非0失败\n*/\nlong dispatch_wait(void *object, dispatch_time_t timeout);\n\n/* \n功能：在指定对象完成工作后，将一个通知块任务加入指定队列\n参数：object：对象  queue：队列 notification_block：通知块\n返回值：无\n*/\nvoid dispatch_notify(void *object, dispatch_object_t queue, dispatch_block_t notification_block);\n\n/* \n功能：取消指定对象\n参数：object：对象 \n返回值：无\n*/\nvoid dispatch_cancel(void *object);\n\n/* \n功能：判断指定对象是否被取消\n参数：object：对象 \n返回值：0表示未取消，其它表示取消\n*/\nlong dispatch_testcancel(void *object);\n\n/* \n功能：已编程方式记录指定对象的调试调度信息\n参数：object：对象 \n返回值：无\n*/\nvoid dispatch_debug(dispatch_object_t object, const char *message, ...);\nvoid dispatch_debugv(dispatch_object_t object, const char *message, va_list ap);\n\n/**********************************dispatch_once**********************************/\n\n/* \n功能：只执行任务函数一次\n参数：predicate：dispatch_once_t 对象  block／function要执行的任务函数 context：传入的内容\n返回值：无\n*/\nvoid dispatch_once(dispatch_once_t *predicate, DISPATCH_NOESCAPE dispatch_block_t block);\nvoid dispatch_once_f(dispatch_once_t *predicate, void *_Nullable context, dispatch_function_t function);\n\n/************************************dispatch_time*************************************/\n\n/* \n功能：创建时间对象，在指定时间的基础上再添加一段时间\n参数：when：时间  delta：时间段（纳秒）\n返回值：时间对象\n*/\ndispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta);\n\n/* \n功能：创建时间对象，在指定时间的基础上再添加一段时间\n参数：when：时间  delta时间段（纳秒）\n返回值：时间对象\n*/\ndispatch_time_t dispatch_walltime(const struct timespec *_Nullable when, int64_t delta);\n```","slug":"GCD方法注释","published":1,"updated":"2017-12-08T02:49:08.543Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb1u1v7p00081us0gcd8fadi","content":"<h4 id=\"GCD方法注释\"><a href=\"#GCD方法注释\" class=\"headerlink\" title=\"GCD方法注释\"></a>GCD方法注释</h4><ul>\n<li><code>Dispatch Queues</code> 中的任务按照FIFO的顺序进行处理，并且，由于加入任务的方式不同，执行分为同步／异步。</li>\n<li><code>Dispatch Groups</code> 可以帮助我们处理如何判断多线程全部执行结束的问题</li>\n<li><code>Dispatch Semaphores</code> 帮助我们控制多任务对有限数量资源的访问</li>\n<li><code>Dispatch Objects</code> 帮助我们对线程队列进行更加细致的控制（挂起、恢复、取消、激活等操作）</li>\n<li><code>Dispatch Once</code> 可以帮助我们确保某个函数只执行一次，可用于单例的实现<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/******************dispatch_queue**********************/</span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：将块函数添加到线程队列中异步执行（异步：执行后不管结果直接返回）</span><br><span class=\"line\">参数：queue：指定的队列   block／work 块函数（context：传入block块函数中的参数）</span><br><span class=\"line\">返回值：空</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</span><br><span class=\"line\">void dispatch_async_f(dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：将块函数添加到线程队列中同步执行（异步：执行完成后返回结果）</span><br><span class=\"line\">参数：queue：指定的队列   block／work 块函数（context：传入block块函数中的参数）</span><br><span class=\"line\">返回值：空</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</span><br><span class=\"line\">void dispatch_sync_f(dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：将块函数添加到线程队列中按照迭代次数执行，所有迭代完成后返回结果</span><br><span class=\"line\">参数：iterations：迭代次数  queue：指定的队列   block／work 块函数（context：传入block块函数中的参数）</span><br><span class=\"line\">返回值：空</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_apply(size_t iterations, dispatch_queue_t queue, DISPATCH_NOESCAPE void (^block)(size_t));</span><br><span class=\"line\">void dispatch_apply_f(size_t iterations, dispatch_queue_t queue, void *_Nullable context, void (*work)(void *_Nullable, size_t));</span><br><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\">功能：获取当前执行中的队列</span><br><span class=\"line\">参数：无</span><br><span class=\"line\">返回值：当前队列或者空</span><br><span class=\"line\">*/</span><br><span class=\"line\">dispatch_queue_t dispatch_get_current_queue(void);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：获取主队列</span><br><span class=\"line\">参数：无</span><br><span class=\"line\">返回值：主队列或者空</span><br><span class=\"line\">*/</span><br><span class=\"line\">dispatch_queue_t dispatch_get_main_queue(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\treturn DISPATCH_GLOBAL_OBJECT(dispatch_queue_t, _dispatch_main_q);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：获取全局并发队列</span><br><span class=\"line\">参数：identifier：队列优先级  typedef long dispatch_queue_priority_t;</span><br><span class=\"line\">\\- DISPATCH_QUEUE_PRIORITY_HIGH:         QOS_CLASS_USER_INITIATED</span><br><span class=\"line\">\\- DISPATCH_QUEUE_PRIORITY_DEFAULT:      QOS_CLASS_DEFAULT</span><br><span class=\"line\">\\- DISPATCH_QUEUE_PRIORITY_LOW:          QOS_CLASS_UTILITY</span><br><span class=\"line\">\\- DISPATCH_QUEUE_PRIORITY_BACKGROUND:   QOS_CLASS_BACKGROUND</span><br><span class=\"line\">\\#define DISPATCH_QUEUE_PRIORITY_HIGH 2</span><br><span class=\"line\">\\#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0</span><br><span class=\"line\">\\#define DISPATCH_QUEUE_PRIORITY_LOW (-2)</span><br><span class=\"line\">\\#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN</span><br><span class=\"line\">  flags：保留供将来使用，输入除了0以外的任何值可能返回空值</span><br><span class=\"line\">返回值：全局队列或者空</span><br><span class=\"line\">*/</span><br><span class=\"line\">dispatch_queue_t dispatch_get_global_queue(long identifier, unsigned long flags);</span><br><span class=\"line\">#define DISPATCH_QUEUE_SERIAL NULL  //串行队列</span><br><span class=\"line\">#define DISPATCH_QUEUE_SERIAL_INACTIVE//暂停状态串行队列</span><br><span class=\"line\">dispatch_queue_attr_make_initially_inactive(DISPATCH_QUEUE_SERIAL)</span><br><span class=\"line\">#define DISPATCH_QUEUE_CONCURRENT //并行队列</span><br><span class=\"line\">DISPATCH_GLOBAL_OBJECT(dispatch_queue_attr_t, _dispatch_queue_attr_concurrent)</span><br><span class=\"line\">#define DISPATCH_QUEUE_CONCURRENT_INACTIVE  //暂停状态并发队列</span><br><span class=\"line\">dispatch_queue_attr_make_initially_inactive(DISPATCH_QUEUE_CONCURRENT)</span><br><span class=\"line\">  </span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：设置属性值，用于在队列的创建时加入</span><br><span class=\"line\">参数：attr：队列属性值</span><br><span class=\"line\">返回值：队列属性值</span><br><span class=\"line\">*/</span><br><span class=\"line\">dispatch_queue_attr_t dispatch_queue_attr_make_initially_inactive(</span><br><span class=\"line\">dispatch_queue_attr_t _Nullable attr);</span><br><span class=\"line\">#define DISPATCH_QUEUE_SERIAL_WITH_AUTORELEASE_POOL </span><br><span class=\"line\">dispatch_queue_attr_make_with_autorelease_frequency(</span><br><span class=\"line\">DISPATCH_QUEUE_SERIAL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM)</span><br><span class=\"line\">#define DISPATCH_QUEUE_CONCURRENT_WITH_AUTORELEASE_POOL</span><br><span class=\"line\">dispatch_queue_attr_make_with_autorelease_frequency(</span><br><span class=\"line\"> DISPATCH_QUEUE_CONCURRENT, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM)</span><br><span class=\"line\">dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(</span><br><span class=\"line\">dispatch_queue_attr_t _Nullable attr,dispatch_autorelease_frequency_t frequency);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：创建队列</span><br><span class=\"line\">参数：label：队列附带信息，可有可无  attr：队列属性值  target：目标队列，相当于目标队列计数加一</span><br><span class=\"line\">返回值：引用的队列</span><br><span class=\"line\">*/</span><br><span class=\"line\">dispatch_queue_t dispatch_queue_create(const char *_Nullable label, dispatch_queue_attr_t _Nullable attr);</span><br><span class=\"line\">dispatch_queue_t dispatch_queue_create_with_target(const char *_Nullable label, dispatch_queue_attr_t _Nullable attr, dispatch_queue_t _Nullable target)</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：获取队列描述信息</span><br><span class=\"line\">参数：label：队列附带信息，可有可无  attr：队列属性值  target：目标队列，相当于目标队列计数加一</span><br><span class=\"line\">返回值：队列附带信息</span><br><span class=\"line\">*/</span><br><span class=\"line\">const char *dispatch_queue_get_label(dispatch_queue_t _Nullable queue);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_qos_class_t dispatch_queue_get_qos_class(dispatch_queue_t queue, int *_Nullable relative_priority_ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：给指定对象设置目标队列</span><br><span class=\"line\">参数：object：目标对象  queue：目标队列</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t _Nullable queue);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：dispatch类入口函数</span><br><span class=\"line\">参数：无</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_main(void);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：在指定时间后再目标队列执行block任务</span><br><span class=\"line\">参数：when：时间 queue：目标队列  block／work：要执行的任务  context：传入任务中的参数</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);</span><br><span class=\"line\">void dispatch_after_f(dispatch_time_t when, dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：给指定队列增加一个阻塞其它异步执行任务的任务</span><br><span class=\"line\">参数：queue：队列  block／work：任务  context：传入任务的参数</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);</span><br><span class=\"line\">void dispatch_barrier_async_f(dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：给指定队列增加一个阻塞其它同步执行任务的任务</span><br><span class=\"line\">参数：queue：队列  block／work：任务  context：传入任务的参数</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_barrier_sync(dispatch_queue_t queue, DISPATCH_NOESCAPE dispatch_block_t block);</span><br><span class=\"line\">void dispatch_barrier_sync_f(dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：当指定队列键值改变时，或者是所有属性值都释放后，调用销毁函数destructor</span><br><span class=\"line\">参数：queue：队列  key：键名  context：新内容  destructor：销毁函数</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_queue_set_specific(dispatch_queue_t queue, const void *key, void *_Nullable context, dispatch_function_t _Nullable destructor);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：获取指定队列特定键内容</span><br><span class=\"line\">参数：queue：队列  key：键名  </span><br><span class=\"line\">返回值：键值</span><br><span class=\"line\">*/</span><br><span class=\"line\">void *_Nullable dispatch_queue_get_specific(dispatch_queue_t queue, const void *key);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：获取当前队列特定键内容</span><br><span class=\"line\">参数： key：键名  </span><br><span class=\"line\">返回值：键值</span><br><span class=\"line\">*/</span><br><span class=\"line\">void *_Nullable dispatch_get_specific(const void *key);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：验证当前块任务运行在指定队列上</span><br><span class=\"line\">参数：queue：队列 </span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_assert_queue(dispatch_queue_t queue)</span><br><span class=\"line\">DISPATCH_ALIAS_V2(dispatch_assert_queue);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：验证当前块任务运行在指定队列上，并且该任务阻塞队列中的其它任务</span><br><span class=\"line\">参数：queue：队列 </span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">void dispatch_assert_queue_barrier(dispatch_queue_t queue);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：验证当前块任务没有运行在指定队列上</span><br><span class=\"line\">参数：queue：队列 </span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_assert_queue_not(dispatch_queue_t queue)</span><br><span class=\"line\">DISPATCH_ALIAS_V2(dispatch_assert_queue_not);</span><br><span class=\"line\"></span><br><span class=\"line\">/*************************dispatch_group*********************************/</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：创建派遣队列组</span><br><span class=\"line\">参数：无</span><br><span class=\"line\">返回值：队列组</span><br><span class=\"line\">*/</span><br><span class=\"line\">dispatch_group_t dispatch_group_create(void);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：给指定队列添加异步执行任务，将队列加入组</span><br><span class=\"line\">参数：group：队列组 queue：指定队列  block／work：任务  context：传入任务的参数</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);</span><br><span class=\"line\">void dispatch_group_async_f(dispatch_group_t group, dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：等待（阻塞线程）一直到（队列组中所有任务执行结束或者是时间结束）</span><br><span class=\"line\">参数：group：队列组 timeout：时间</span><br><span class=\"line\">返回值：0表示成功，非0.错误</span><br><span class=\"line\">*/</span><br><span class=\"line\">long dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：队列组中所有任务执行结束之后，执行新的block 任务</span><br><span class=\"line\">参数：group：任务组 queue：指定队列  block／work：新任务  context：传入任务的参数</span><br><span class=\"line\">返回值：任务组</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);</span><br><span class=\"line\">void dispatch_group_notify_f(dispatch_group_t group, dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：管理显示队列组中所有任务</span><br><span class=\"line\">参数：group：队列组 </span><br><span class=\"line\">返回值：队列组</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_group_enter(dispatch_group_t group);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：管理显示队列组中以执行结束的任务</span><br><span class=\"line\">参数：group：队列组</span><br><span class=\"line\">返回值：队列组</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_group_leave(dispatch_group_t group);</span><br><span class=\"line\"></span><br><span class=\"line\">/*****************************dispatch_semaphore********************************/</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：创建信号量</span><br><span class=\"line\">参数：value：信号量资源数</span><br><span class=\"line\">返回值：信号量或空（失败）</span><br><span class=\"line\">*/</span><br><span class=\"line\">dispatch_semaphore_t dispatch_semaphore_create(long value);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：等待获取信号量，获取到后开始继续执行，或是时间结束</span><br><span class=\"line\">参数：dsema：信号量 timeout：限定时间</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：执行结束，不需要占用资源，释放信号量</span><br><span class=\"line\">参数：dsema：信号量</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">long dispatch_semaphore_signal(dispatch_semaphore_t dsema);</span><br><span class=\"line\"></span><br><span class=\"line\">/*****************************dispatch_object********************************/</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：增加队列引用计数</span><br><span class=\"line\">参数：object：操作队列</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_retain(dispatch_object_t object);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：减少队列引用计数</span><br><span class=\"line\">参数：object：操作队列</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_release(dispatch_object_t object);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：获取对象应用程序上下文</span><br><span class=\"line\">参数：object：对象</span><br><span class=\"line\">返回值：定义内容或空</span><br><span class=\"line\">*/</span><br><span class=\"line\">void *_Nullable dispatch_get_context(dispatch_object_t object);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：设置指定对象的应用程序上下文</span><br><span class=\"line\">参数：object：对象 context：上下文内容</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_set_context(dispatch_object_t object, void *_Nullable context);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：设置对象销毁函数，在该对象所有引用释放后，销毁该对象</span><br><span class=\"line\">参数：object：对象 finalizer：销毁函数指针</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_set_finalizer_f(dispatch_object_t object, dispatch_function_t _Nullable finalizer);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：激活指定非活动对象</span><br><span class=\"line\">参数：object：对象（一般是线程队列） </span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_activate(dispatch_object_t object);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：挂起／阻塞指定对象（一般是线程队列）</span><br><span class=\"line\">参数：object：对象 </span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_suspend(dispatch_object_t object);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：恢复指定对象（一般是线程队列）</span><br><span class=\"line\">参数：object：对象 </span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_resume(dispatch_object_t object);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：同步等待一个对象完成操作，或者是直到超出规定时间</span><br><span class=\"line\">参数：object：对象  timeout：限定时间</span><br><span class=\"line\">返回值：0成功，非0失败</span><br><span class=\"line\">*/</span><br><span class=\"line\">long dispatch_wait(void *object, dispatch_time_t timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：在指定对象完成工作后，将一个通知块任务加入指定队列</span><br><span class=\"line\">参数：object：对象  queue：队列 notification_block：通知块</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_notify(void *object, dispatch_object_t queue, dispatch_block_t notification_block);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：取消指定对象</span><br><span class=\"line\">参数：object：对象 </span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_cancel(void *object);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：判断指定对象是否被取消</span><br><span class=\"line\">参数：object：对象 </span><br><span class=\"line\">返回值：0表示未取消，其它表示取消</span><br><span class=\"line\">*/</span><br><span class=\"line\">long dispatch_testcancel(void *object);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：已编程方式记录指定对象的调试调度信息</span><br><span class=\"line\">参数：object：对象 </span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_debug(dispatch_object_t object, const char *message, ...);</span><br><span class=\"line\">void dispatch_debugv(dispatch_object_t object, const char *message, va_list ap);</span><br><span class=\"line\"></span><br><span class=\"line\">/**********************************dispatch_once**********************************/</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：只执行任务函数一次</span><br><span class=\"line\">参数：predicate：dispatch_once_t 对象  block／function要执行的任务函数 context：传入的内容</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_once(dispatch_once_t *predicate, DISPATCH_NOESCAPE dispatch_block_t block);</span><br><span class=\"line\">void dispatch_once_f(dispatch_once_t *predicate, void *_Nullable context, dispatch_function_t function);</span><br><span class=\"line\"></span><br><span class=\"line\">/************************************dispatch_time*************************************/</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：创建时间对象，在指定时间的基础上再添加一段时间</span><br><span class=\"line\">参数：when：时间  delta：时间段（纳秒）</span><br><span class=\"line\">返回值：时间对象</span><br><span class=\"line\">*/</span><br><span class=\"line\">dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：创建时间对象，在指定时间的基础上再添加一段时间</span><br><span class=\"line\">参数：when：时间  delta时间段（纳秒）</span><br><span class=\"line\">返回值：时间对象</span><br><span class=\"line\">*/</span><br><span class=\"line\">dispatch_time_t dispatch_walltime(const struct timespec *_Nullable when, int64_t delta);</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h4 id=\"GCD方法注释\"><a href=\"#GCD方法注释\" class=\"headerlink\" title=\"GCD方法注释\"></a>GCD方法注释</h4><ul>\n<li><code>Dispatch Queues</code> 中的任务按照FIFO的顺序进行处理，并且，由于加入任务的方式不同，执行分为同步／异步。</li>\n<li><code>Dispatch Groups</code> 可以帮助我们处理如何判断多线程全部执行结束的问题</li>\n<li><code>Dispatch Semaphores</code> 帮助我们控制多任务对有限数量资源的访问</li>\n<li><code>Dispatch Objects</code> 帮助我们对线程队列进行更加细致的控制（挂起、恢复、取消、激活等操作）</li>\n<li><code>Dispatch Once</code> 可以帮助我们确保某个函数只执行一次，可用于单例的实现</li></ul>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/******************dispatch_queue**********************/</span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：将块函数添加到线程队列中异步执行（异步：执行后不管结果直接返回）</span><br><span class=\"line\">参数：queue：指定的队列   block／work 块函数（context：传入block块函数中的参数）</span><br><span class=\"line\">返回值：空</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</span><br><span class=\"line\">void dispatch_async_f(dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：将块函数添加到线程队列中同步执行（异步：执行完成后返回结果）</span><br><span class=\"line\">参数：queue：指定的队列   block／work 块函数（context：传入block块函数中的参数）</span><br><span class=\"line\">返回值：空</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</span><br><span class=\"line\">void dispatch_sync_f(dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：将块函数添加到线程队列中按照迭代次数执行，所有迭代完成后返回结果</span><br><span class=\"line\">参数：iterations：迭代次数  queue：指定的队列   block／work 块函数（context：传入block块函数中的参数）</span><br><span class=\"line\">返回值：空</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_apply(size_t iterations, dispatch_queue_t queue, DISPATCH_NOESCAPE void (^block)(size_t));</span><br><span class=\"line\">void dispatch_apply_f(size_t iterations, dispatch_queue_t queue, void *_Nullable context, void (*work)(void *_Nullable, size_t));</span><br><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\">功能：获取当前执行中的队列</span><br><span class=\"line\">参数：无</span><br><span class=\"line\">返回值：当前队列或者空</span><br><span class=\"line\">*/</span><br><span class=\"line\">dispatch_queue_t dispatch_get_current_queue(void);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：获取主队列</span><br><span class=\"line\">参数：无</span><br><span class=\"line\">返回值：主队列或者空</span><br><span class=\"line\">*/</span><br><span class=\"line\">dispatch_queue_t dispatch_get_main_queue(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\treturn DISPATCH_GLOBAL_OBJECT(dispatch_queue_t, _dispatch_main_q);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：获取全局并发队列</span><br><span class=\"line\">参数：identifier：队列优先级  typedef long dispatch_queue_priority_t;</span><br><span class=\"line\">\\- DISPATCH_QUEUE_PRIORITY_HIGH:         QOS_CLASS_USER_INITIATED</span><br><span class=\"line\">\\- DISPATCH_QUEUE_PRIORITY_DEFAULT:      QOS_CLASS_DEFAULT</span><br><span class=\"line\">\\- DISPATCH_QUEUE_PRIORITY_LOW:          QOS_CLASS_UTILITY</span><br><span class=\"line\">\\- DISPATCH_QUEUE_PRIORITY_BACKGROUND:   QOS_CLASS_BACKGROUND</span><br><span class=\"line\">\\#define DISPATCH_QUEUE_PRIORITY_HIGH 2</span><br><span class=\"line\">\\#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0</span><br><span class=\"line\">\\#define DISPATCH_QUEUE_PRIORITY_LOW (-2)</span><br><span class=\"line\">\\#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN</span><br><span class=\"line\">  flags：保留供将来使用，输入除了0以外的任何值可能返回空值</span><br><span class=\"line\">返回值：全局队列或者空</span><br><span class=\"line\">*/</span><br><span class=\"line\">dispatch_queue_t dispatch_get_global_queue(long identifier, unsigned long flags);</span><br><span class=\"line\">#define DISPATCH_QUEUE_SERIAL NULL  //串行队列</span><br><span class=\"line\">#define DISPATCH_QUEUE_SERIAL_INACTIVE//暂停状态串行队列</span><br><span class=\"line\">dispatch_queue_attr_make_initially_inactive(DISPATCH_QUEUE_SERIAL)</span><br><span class=\"line\">#define DISPATCH_QUEUE_CONCURRENT //并行队列</span><br><span class=\"line\">DISPATCH_GLOBAL_OBJECT(dispatch_queue_attr_t, _dispatch_queue_attr_concurrent)</span><br><span class=\"line\">#define DISPATCH_QUEUE_CONCURRENT_INACTIVE  //暂停状态并发队列</span><br><span class=\"line\">dispatch_queue_attr_make_initially_inactive(DISPATCH_QUEUE_CONCURRENT)</span><br><span class=\"line\">  </span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：设置属性值，用于在队列的创建时加入</span><br><span class=\"line\">参数：attr：队列属性值</span><br><span class=\"line\">返回值：队列属性值</span><br><span class=\"line\">*/</span><br><span class=\"line\">dispatch_queue_attr_t dispatch_queue_attr_make_initially_inactive(</span><br><span class=\"line\">dispatch_queue_attr_t _Nullable attr);</span><br><span class=\"line\">#define DISPATCH_QUEUE_SERIAL_WITH_AUTORELEASE_POOL </span><br><span class=\"line\">dispatch_queue_attr_make_with_autorelease_frequency(</span><br><span class=\"line\">DISPATCH_QUEUE_SERIAL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM)</span><br><span class=\"line\">#define DISPATCH_QUEUE_CONCURRENT_WITH_AUTORELEASE_POOL</span><br><span class=\"line\">dispatch_queue_attr_make_with_autorelease_frequency(</span><br><span class=\"line\"> DISPATCH_QUEUE_CONCURRENT, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM)</span><br><span class=\"line\">dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(</span><br><span class=\"line\">dispatch_queue_attr_t _Nullable attr,dispatch_autorelease_frequency_t frequency);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：创建队列</span><br><span class=\"line\">参数：label：队列附带信息，可有可无  attr：队列属性值  target：目标队列，相当于目标队列计数加一</span><br><span class=\"line\">返回值：引用的队列</span><br><span class=\"line\">*/</span><br><span class=\"line\">dispatch_queue_t dispatch_queue_create(const char *_Nullable label, dispatch_queue_attr_t _Nullable attr);</span><br><span class=\"line\">dispatch_queue_t dispatch_queue_create_with_target(const char *_Nullable label, dispatch_queue_attr_t _Nullable attr, dispatch_queue_t _Nullable target)</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：获取队列描述信息</span><br><span class=\"line\">参数：label：队列附带信息，可有可无  attr：队列属性值  target：目标队列，相当于目标队列计数加一</span><br><span class=\"line\">返回值：队列附带信息</span><br><span class=\"line\">*/</span><br><span class=\"line\">const char *dispatch_queue_get_label(dispatch_queue_t _Nullable queue);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_qos_class_t dispatch_queue_get_qos_class(dispatch_queue_t queue, int *_Nullable relative_priority_ptr);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：给指定对象设置目标队列</span><br><span class=\"line\">参数：object：目标对象  queue：目标队列</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t _Nullable queue);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：dispatch类入口函数</span><br><span class=\"line\">参数：无</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_main(void);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：在指定时间后再目标队列执行block任务</span><br><span class=\"line\">参数：when：时间 queue：目标队列  block／work：要执行的任务  context：传入任务中的参数</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);</span><br><span class=\"line\">void dispatch_after_f(dispatch_time_t when, dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：给指定队列增加一个阻塞其它异步执行任务的任务</span><br><span class=\"line\">参数：queue：队列  block／work：任务  context：传入任务的参数</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);</span><br><span class=\"line\">void dispatch_barrier_async_f(dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：给指定队列增加一个阻塞其它同步执行任务的任务</span><br><span class=\"line\">参数：queue：队列  block／work：任务  context：传入任务的参数</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_barrier_sync(dispatch_queue_t queue, DISPATCH_NOESCAPE dispatch_block_t block);</span><br><span class=\"line\">void dispatch_barrier_sync_f(dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：当指定队列键值改变时，或者是所有属性值都释放后，调用销毁函数destructor</span><br><span class=\"line\">参数：queue：队列  key：键名  context：新内容  destructor：销毁函数</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_queue_set_specific(dispatch_queue_t queue, const void *key, void *_Nullable context, dispatch_function_t _Nullable destructor);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：获取指定队列特定键内容</span><br><span class=\"line\">参数：queue：队列  key：键名  </span><br><span class=\"line\">返回值：键值</span><br><span class=\"line\">*/</span><br><span class=\"line\">void *_Nullable dispatch_queue_get_specific(dispatch_queue_t queue, const void *key);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：获取当前队列特定键内容</span><br><span class=\"line\">参数： key：键名  </span><br><span class=\"line\">返回值：键值</span><br><span class=\"line\">*/</span><br><span class=\"line\">void *_Nullable dispatch_get_specific(const void *key);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：验证当前块任务运行在指定队列上</span><br><span class=\"line\">参数：queue：队列 </span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_assert_queue(dispatch_queue_t queue)</span><br><span class=\"line\">DISPATCH_ALIAS_V2(dispatch_assert_queue);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：验证当前块任务运行在指定队列上，并且该任务阻塞队列中的其它任务</span><br><span class=\"line\">参数：queue：队列 </span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">void dispatch_assert_queue_barrier(dispatch_queue_t queue);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：验证当前块任务没有运行在指定队列上</span><br><span class=\"line\">参数：queue：队列 </span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_assert_queue_not(dispatch_queue_t queue)</span><br><span class=\"line\">DISPATCH_ALIAS_V2(dispatch_assert_queue_not);</span><br><span class=\"line\"></span><br><span class=\"line\">/*************************dispatch_group*********************************/</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：创建派遣队列组</span><br><span class=\"line\">参数：无</span><br><span class=\"line\">返回值：队列组</span><br><span class=\"line\">*/</span><br><span class=\"line\">dispatch_group_t dispatch_group_create(void);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：给指定队列添加异步执行任务，将队列加入组</span><br><span class=\"line\">参数：group：队列组 queue：指定队列  block／work：任务  context：传入任务的参数</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);</span><br><span class=\"line\">void dispatch_group_async_f(dispatch_group_t group, dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：等待（阻塞线程）一直到（队列组中所有任务执行结束或者是时间结束）</span><br><span class=\"line\">参数：group：队列组 timeout：时间</span><br><span class=\"line\">返回值：0表示成功，非0.错误</span><br><span class=\"line\">*/</span><br><span class=\"line\">long dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：队列组中所有任务执行结束之后，执行新的block 任务</span><br><span class=\"line\">参数：group：任务组 queue：指定队列  block／work：新任务  context：传入任务的参数</span><br><span class=\"line\">返回值：任务组</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block);</span><br><span class=\"line\">void dispatch_group_notify_f(dispatch_group_t group, dispatch_queue_t queue, void *_Nullable context, dispatch_function_t work);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：管理显示队列组中所有任务</span><br><span class=\"line\">参数：group：队列组 </span><br><span class=\"line\">返回值：队列组</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_group_enter(dispatch_group_t group);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：管理显示队列组中以执行结束的任务</span><br><span class=\"line\">参数：group：队列组</span><br><span class=\"line\">返回值：队列组</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_group_leave(dispatch_group_t group);</span><br><span class=\"line\"></span><br><span class=\"line\">/*****************************dispatch_semaphore********************************/</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：创建信号量</span><br><span class=\"line\">参数：value：信号量资源数</span><br><span class=\"line\">返回值：信号量或空（失败）</span><br><span class=\"line\">*/</span><br><span class=\"line\">dispatch_semaphore_t dispatch_semaphore_create(long value);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：等待获取信号量，获取到后开始继续执行，或是时间结束</span><br><span class=\"line\">参数：dsema：信号量 timeout：限定时间</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：执行结束，不需要占用资源，释放信号量</span><br><span class=\"line\">参数：dsema：信号量</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">long dispatch_semaphore_signal(dispatch_semaphore_t dsema);</span><br><span class=\"line\"></span><br><span class=\"line\">/*****************************dispatch_object********************************/</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：增加队列引用计数</span><br><span class=\"line\">参数：object：操作队列</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_retain(dispatch_object_t object);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：减少队列引用计数</span><br><span class=\"line\">参数：object：操作队列</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_release(dispatch_object_t object);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：获取对象应用程序上下文</span><br><span class=\"line\">参数：object：对象</span><br><span class=\"line\">返回值：定义内容或空</span><br><span class=\"line\">*/</span><br><span class=\"line\">void *_Nullable dispatch_get_context(dispatch_object_t object);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：设置指定对象的应用程序上下文</span><br><span class=\"line\">参数：object：对象 context：上下文内容</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_set_context(dispatch_object_t object, void *_Nullable context);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：设置对象销毁函数，在该对象所有引用释放后，销毁该对象</span><br><span class=\"line\">参数：object：对象 finalizer：销毁函数指针</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_set_finalizer_f(dispatch_object_t object, dispatch_function_t _Nullable finalizer);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：激活指定非活动对象</span><br><span class=\"line\">参数：object：对象（一般是线程队列） </span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_activate(dispatch_object_t object);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：挂起／阻塞指定对象（一般是线程队列）</span><br><span class=\"line\">参数：object：对象 </span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_suspend(dispatch_object_t object);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：恢复指定对象（一般是线程队列）</span><br><span class=\"line\">参数：object：对象 </span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_resume(dispatch_object_t object);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：同步等待一个对象完成操作，或者是直到超出规定时间</span><br><span class=\"line\">参数：object：对象  timeout：限定时间</span><br><span class=\"line\">返回值：0成功，非0失败</span><br><span class=\"line\">*/</span><br><span class=\"line\">long dispatch_wait(void *object, dispatch_time_t timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：在指定对象完成工作后，将一个通知块任务加入指定队列</span><br><span class=\"line\">参数：object：对象  queue：队列 notification_block：通知块</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_notify(void *object, dispatch_object_t queue, dispatch_block_t notification_block);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：取消指定对象</span><br><span class=\"line\">参数：object：对象 </span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_cancel(void *object);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：判断指定对象是否被取消</span><br><span class=\"line\">参数：object：对象 </span><br><span class=\"line\">返回值：0表示未取消，其它表示取消</span><br><span class=\"line\">*/</span><br><span class=\"line\">long dispatch_testcancel(void *object);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：已编程方式记录指定对象的调试调度信息</span><br><span class=\"line\">参数：object：对象 </span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_debug(dispatch_object_t object, const char *message, ...);</span><br><span class=\"line\">void dispatch_debugv(dispatch_object_t object, const char *message, va_list ap);</span><br><span class=\"line\"></span><br><span class=\"line\">/**********************************dispatch_once**********************************/</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：只执行任务函数一次</span><br><span class=\"line\">参数：predicate：dispatch_once_t 对象  block／function要执行的任务函数 context：传入的内容</span><br><span class=\"line\">返回值：无</span><br><span class=\"line\">*/</span><br><span class=\"line\">void dispatch_once(dispatch_once_t *predicate, DISPATCH_NOESCAPE dispatch_block_t block);</span><br><span class=\"line\">void dispatch_once_f(dispatch_once_t *predicate, void *_Nullable context, dispatch_function_t function);</span><br><span class=\"line\"></span><br><span class=\"line\">/************************************dispatch_time*************************************/</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：创建时间对象，在指定时间的基础上再添加一段时间</span><br><span class=\"line\">参数：when：时间  delta：时间段（纳秒）</span><br><span class=\"line\">返回值：时间对象</span><br><span class=\"line\">*/</span><br><span class=\"line\">dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta);</span><br><span class=\"line\"></span><br><span class=\"line\">/* </span><br><span class=\"line\">功能：创建时间对象，在指定时间的基础上再添加一段时间</span><br><span class=\"line\">参数：when：时间  delta时间段（纳秒）</span><br><span class=\"line\">返回值：时间对象</span><br><span class=\"line\">*/</span><br><span class=\"line\">dispatch_time_t dispatch_walltime(const struct timespec *_Nullable when, int64_t delta);</span><br></pre></td></tr></table></figure>\n"},{"title":"GCD学习 —— 二","date":"2017-12-07T11:42:00.000Z","_content":"\n今天继续深入了解一下GCD。\n\n####   Dispatch Source\n\n​\t使用      `Dispatch Source `而不使用 `dispatch_async` 的唯一原因就是利用联结的优势。\n\n​\t联结的大致流程：在任一线程上调用它的一个函数` dispatch_source_merge_data` 后，会执行` Dispatch Source` 事先定义好的句柄（可以把句柄简单理解为一个 block ）。这个过程叫 Custom event ，用户事件。是 `dispatch source` 支持处理的一种事件。简单地说，这种事件是由你调用 `dispatch_source_merge_data` 函数来向自己发出的信号。\n\n##### 1 创建dispatch源\n\n```objective-c\ndispatch_source_t source = dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, unsigned long mask, dispatch_queue_t queue)\n```\n\n| 参数     | 意义                              |\n| ------ | ------------------------------- |\n| type   | dispatch源可处理的事件                 |\n| handle | 可以理解为句柄、索引或id，假如要监听进程，需要传入进程的ID |\n| mask   | 可以理解为描述，提供更详细的描述，让它知道具体要监听什么    |\n| queue  | 自定义源需要的一个队列，用来处理所有的响应句柄（block）  |\n<!-- more -->\n##### 2 **Dispatch Source可处理的所有事件**\n\n| 名称                             | 内容                                 |\n| ------------------------------ | ---------------------------------- |\n| DISPATCH_SOURCE_TYPE_DATA_ADD  | 自定义的事件，变量增加                        |\n| DISPATCH_SOURCE_TYPE_DATA_OR   | 自定义的事件，变量OR                        |\n| DISPATCH_SOURCE_TYPE_MACH_SEND | MACH端口发送                           |\n| DISPATCH_SOURCE_TYPE_MACH_RECV | MACH端口接收                           |\n| DISPATCH_SOURCE_TYPE_PROC      | 进程监听,如进程的退出、创建一个或更多的子线程、进程收到UNIX信号 |\n| DISPATCH_SOURCE_TYPE_READ      | IO操作，如对文件的操作、socket操作的读响应          |\n| DISPATCH_SOURCE_TYPE_SIGNAL    | 接收到UNIX信号时响应                       |\n| DISPATCH_SOURCE_TYPE_TIMER     | 定时器                                |\n| DISPATCH_SOURCE_TYPE_VNODE     | 文件状态监听，文件被删除、移动、重命名                |\n| DISPATCH_SOURCE_TYPE_WRITE     | IO操作，如对文件的操作、socket操作的写响应          |\n\n**注意：**\n\n- `DISPATCH_SOURCE_TYPE_DATA_ADD`当同一时间，一个事件的的触发频率很高，那么Dispatch Source会将这些响应以ADD的方式进行累积，然后等系统空闲时最终处理，如果触发频率比较零散，那么Dispatch Source会将这些事件分别响应。\n- `DISPATCH_SOURCE_TYPE_DATA_OR` 和上面的一样，是自定义的事件，但是它是以OR的方式进行累积\n\n##### 3 一些函数\n\n```objective-c\ndispatch_suspend(queue)  //挂起队列\n\ndispatch_resume(source)  //分派源创建时默认处于暂停状态，在分派源分派处理程序之前必须先恢复\n\n//向分派源发送事件，需要注意的是，不可以传递0值(事件不会被触发)，同样也不可以传递负数。\ndispatch_source_merge_data(dispatch_source_t  _Nonnull source, unsigned long value)\n\n//设置响应分派源事件的block，在分派源指定的队列上运行\ndispatch_source_set_event_handler(dispatch_source_t  _Nonnull source, ^(void)handler) \n\ndispatch_source_get_data(dispatch_source_t  _Nonnull source) //得到分派源的数据\n\n//得到dispatch源创建，即调用dispatch_source_create的第二个参数\nuintptr_t dispatch_source_get_handle(dispatch_source_t source); \n\n//得到dispatch源创建，即调用dispatch_source_create的第三个参数\nunsigned long dispatch_source_get_mask(dispatch_source_t source); \n\n//取消dispatch源的事件处理--即不再调用block。如果调用dispatch_suspend只是暂停dispatch源。\nvoid dispatch_source_cancel(dispatch_source_t source); \n\n//检测是否dispatch源被取消，如果返回非0值则表明dispatch源已经被取消\nlong dispatch_source_testcancel(dispatch_source_t source); \n\n//dispatch源取消时调用的block，一般用于关闭文件或socket等，释放相关资源\nvoid dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t cancel_handler); \n\n//可用于设置dispatch源启动时调用block，调用完成后即释放这个block。也可在dispatch源运行当中随时调用这个函数。\nvoid dispatch_source_set_registration_handler(dispatch_source_t source, dispatch_block_t registration_handler); \n```\n\n##### 4 dispatch_source的基本用法\n\n```objective-c\ndispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, dispatch_get_global_queue(0, 0));\n  dispatch_source_set_event_handler(source, ^{\n    dispatch_sync(dispatch_get_main_queue(), ^{\n        //更新UI\n        NSLog(@\"更新UI\");\n    });\n});\ndispatch_resume(source);\ndispatch_async(dispatch_get_global_queue(0, 0), ^{\n\n    //网络请求\n    NSLog(@\"更新UI\");\n    dispatch_source_merge_data(source, 1); //通知队列\n    [NSThread sleepForTimeInterval:0.01];\n});\n```\n上面的例子创建一个source，source的type为ADD的方式，然后将事件触发后要执行的句柄添加到main队列里，在source创建后默认是挂起的，需要用`dispatch_resume`函数来恢复监听，在执行了`dispatch_source_merge_data`后一定要执行`[NSThread sleepForTimeInterval:0.01];`否则上面的句柄操作有可能不执行，后面为了测试监听，加入了一个for循环，用`dispatch_source_merge_data`来触发事件，但是在触发事件的响应句柄里我们只打印了一次，结果是每次相加的和，也就是10，而不是打印了4次。\n\n**原因：**`DISPATCH_SOURCE_TYPE_DATA_ADD`是将所有触发结果相加，最后统一执行响应，但是加入`sleepForTimeInterval`后，如果interval的时间越长，则每次触发都会响应，但是如果interval的时间很短，则会将触发后的结果相加后统一触发。\n\n这在更新UI时很有用，比如更新进度条时，没必要每次触发都响应，因为更新时还有其他的用户操作（用户输入，触碰等），所以可以统一触发\n\n```objective-c\n//创建source，以DISPATCH_SOURCE_TYPE_DATA_ADD的方式进行累加，而DISPATCH_SOURCE_TYPE_DATA_OR是对结果进行二进制或运算\ndispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, \t\tdispatch_get_main_queue());\n//事件触发后执行的句柄\ndispatch_source_set_event_handler(source,^{\n    NSLog(@\"监听函数：%lu\",dispatch_source_get_data(source));\n});\n//开启source\ndispatch_resume(source);\ndispatch_queue_t myqueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);  \ndispatch_async(myqueue, ^ {\n  for(int i = 1; i <= 4; i ++){\n     NSLog(@\"~~~~~~~~~~~~~~%d\", i);\n     //触发事件，向source发送事件，这里i不能为0，否则触发不了事件\n     dispatch_source_merge_data(source,i);\n     //当Interval的事件越长，则每次的句柄都会触发\n     [NSThread sleepForTimeInterval:0.01];\n  }\n});\n```\n##### 5  使用timer定时器\n\n```objective-c\ndispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)\n```\n\n- source 分派源\n- start 数控制计时器第一次触发的时刻。参数类型是 `dispatch_time_t`，这是一个opaque类型，我们不能直接操作它。我们得需要 `dispatch_time` 和  `dispatch_walltime` 函数来创建它们。另外，常量  `DISPATCH_TIME_NOW` 和 `DISPATCH_TIME_FOREVER` 通常很有用。\n- interval 间隔时间\n- leeway 计时器触发的精准程度\n\n实例：\n\n```objective-c\n//倒计时时间\n__block int timeout = 3;\n//创建队列\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n//创建timer\ndispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, \t\tqueue);\n//设置2s触发一次，0s的误差，2s执行\ndispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),2.0 * NSEC_PER_SEC, 0); \n//触发的事件\ndispatch_source_set_event_handler(_timer, ^{\n    if(timeout <= 0){ \n        //倒计时结束，取消dispatch源\n        dispatch_source_cancel(_timer);\n    } else {\n        timeout--;\n        dispatch_async(dispatch_get_main_queue(), ^{\n            //更新主界面的操作\n            NSLog(@\"倒计时:%d\", timeout);\n        });\n    }\n});\n//开始执行dispatch源\ndispatch_resume(_timer);\n```\n\n##### 6 dispatch_suspend挂起队列\n\n实例：\n\n```objective-c\n//创建DISPATCH_QUEUE_SERIAL队列\ndispatch_queue_t queue1 = dispatch_queue_create(\"com.itachi.queue1\", 0);\ndispatch_queue_t queue2 = dispatch_queue_create(\"com.itachi.queue2\", 0);\n//创建group\ndispatch_group_t group = dispatch_group_create();\n//异步执行任务\ndispatch_async(queue1, ^{\n    NSLog(@\"任务1：queue 1...\");\n    sleep(1);\n    NSLog(@\":white_check_mark:完成任务1\");\n});\n\ndispatch_async(queue2, ^{\n    NSLog(@\"任务1：queue 2...\");\n    sleep(1);\n    NSLog(@\":white_check_mark:完成任务2\");\n});\n\n//将队列加入到group\ndispatch_group_async(group, queue1, ^{\n    NSLog(@\":no_entry_sign:正在暂停1\");\n    dispatch_suspend(queue1);\n});\n\ndispatch_group_async(group, queue2, ^{\n    NSLog(@\":no_entry_sign:正在暂停2\");\n    dispatch_suspend(queue2);\n});\n\n//等待两个queue执行完毕后再执行\n//当将dispatch_group_wait(group, DISPATCH_TIME_FOREVER);注释后，会产生崩溃，因为所有的任务都是异步执行的，在执行恢复queue1和queue2队列的时候，可能这个时候还没有执行queue1和queue2的挂起队列\ndispatch_group_wait(group, DISPATCH_TIME_FOREVER);\nNSLog(@\"等待两个queue1完成, 再往下进行\");\n\n//异步执行任务\ndispatch_async(queue1, ^{\n    NSLog(@\"任务2：queue 1\");\n});\ndispatch_async(queue2, ^{\n    NSLog(@\"任务2：queue 2\");\n});\n\n//在这里将这两个队列重新恢复\ndispatch_resume(queue1);\ndispatch_resume(queue2);\n```\n\n##### 7 进度条实例\n\n```objective-c\n//1、指定DISPATCH_SOURCE_TYPE_DATA_ADD，做成Dispatch Source(分派源)。设定Main Dispatch Queue 为追加处理的Dispatch Queue\ndispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, \t\tdispatch_get_main_queue());\n__block NSUInteger totalComplete = 0;\ndispatch_source_set_event_handler(source, ^{\n    //当处理事件被最终执行时，计算后的数据可以通过dispatch_source_get_data来获取。这个数据的值在每次响应事件执行后会被重置，所以totalComplete的值是最终累积的值。\n    NSUInteger value = dispatch_source_get_data(source);\n    totalComplete += value;\n    NSLog(@\"进度：%@\", @((CGFloat)totalComplete/100));\n    NSLog(@\":large_blue_circle:线程号：%@\", [NSThread currentThread]);\n});\n\n//分派源创建时默认处于暂停状态，在分派源分派处理程序之前必须先恢复。\ndispatch_resume(source);\n\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n\n//2、恢复源后，就可以通过dispatch_source_merge_data向Dispatch Source(分派源)发送事件:\nfor (NSUInteger index = 0; index < 100; index++) {\n    dispatch_async(queue, ^{\n        dispatch_source_merge_data(source, 1);\n        NSLog(@\":recycle:线程号：%@~~~~~~~~~~~~i = %ld\", [NSThread currentThread], index);\n        usleep(20000);//0.02秒\n    });\n}\n\n//3、比较上面的for循环代码，将dispatch_async放在外面for循环的外面，打印结果不一样\ndispatch_async(queue, ^{\n    for (NSUInteger index = 0; index < 100; index++) {\n        dispatch_source_merge_data(source, 1);\n        NSLog(@\":recycle:线程号：%@~~~~~~~~~~~~i = %ld\", [NSThread currentThread], index);\n        usleep(20000);//0.02秒\n    }\n});\n//2是将100个任务添加到queue里面，而3是在queue里面添加一个任务，而这一个任务做了100次循环\n```\n\n\n转载自[iOS多线程——Dispatch Source](http://www.jianshu.com/p/880c2f9301b6)","source":"_posts/GCD深入学习.md","raw":"---\ntitle: GCD学习 —— 二\ndate: 2017-12-07 19:42\ntags: iOS\ncategories: iOS Tips\n---\n\n今天继续深入了解一下GCD。\n\n####   Dispatch Source\n\n​\t使用      `Dispatch Source `而不使用 `dispatch_async` 的唯一原因就是利用联结的优势。\n\n​\t联结的大致流程：在任一线程上调用它的一个函数` dispatch_source_merge_data` 后，会执行` Dispatch Source` 事先定义好的句柄（可以把句柄简单理解为一个 block ）。这个过程叫 Custom event ，用户事件。是 `dispatch source` 支持处理的一种事件。简单地说，这种事件是由你调用 `dispatch_source_merge_data` 函数来向自己发出的信号。\n\n##### 1 创建dispatch源\n\n```objective-c\ndispatch_source_t source = dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, unsigned long mask, dispatch_queue_t queue)\n```\n\n| 参数     | 意义                              |\n| ------ | ------------------------------- |\n| type   | dispatch源可处理的事件                 |\n| handle | 可以理解为句柄、索引或id，假如要监听进程，需要传入进程的ID |\n| mask   | 可以理解为描述，提供更详细的描述，让它知道具体要监听什么    |\n| queue  | 自定义源需要的一个队列，用来处理所有的响应句柄（block）  |\n<!-- more -->\n##### 2 **Dispatch Source可处理的所有事件**\n\n| 名称                             | 内容                                 |\n| ------------------------------ | ---------------------------------- |\n| DISPATCH_SOURCE_TYPE_DATA_ADD  | 自定义的事件，变量增加                        |\n| DISPATCH_SOURCE_TYPE_DATA_OR   | 自定义的事件，变量OR                        |\n| DISPATCH_SOURCE_TYPE_MACH_SEND | MACH端口发送                           |\n| DISPATCH_SOURCE_TYPE_MACH_RECV | MACH端口接收                           |\n| DISPATCH_SOURCE_TYPE_PROC      | 进程监听,如进程的退出、创建一个或更多的子线程、进程收到UNIX信号 |\n| DISPATCH_SOURCE_TYPE_READ      | IO操作，如对文件的操作、socket操作的读响应          |\n| DISPATCH_SOURCE_TYPE_SIGNAL    | 接收到UNIX信号时响应                       |\n| DISPATCH_SOURCE_TYPE_TIMER     | 定时器                                |\n| DISPATCH_SOURCE_TYPE_VNODE     | 文件状态监听，文件被删除、移动、重命名                |\n| DISPATCH_SOURCE_TYPE_WRITE     | IO操作，如对文件的操作、socket操作的写响应          |\n\n**注意：**\n\n- `DISPATCH_SOURCE_TYPE_DATA_ADD`当同一时间，一个事件的的触发频率很高，那么Dispatch Source会将这些响应以ADD的方式进行累积，然后等系统空闲时最终处理，如果触发频率比较零散，那么Dispatch Source会将这些事件分别响应。\n- `DISPATCH_SOURCE_TYPE_DATA_OR` 和上面的一样，是自定义的事件，但是它是以OR的方式进行累积\n\n##### 3 一些函数\n\n```objective-c\ndispatch_suspend(queue)  //挂起队列\n\ndispatch_resume(source)  //分派源创建时默认处于暂停状态，在分派源分派处理程序之前必须先恢复\n\n//向分派源发送事件，需要注意的是，不可以传递0值(事件不会被触发)，同样也不可以传递负数。\ndispatch_source_merge_data(dispatch_source_t  _Nonnull source, unsigned long value)\n\n//设置响应分派源事件的block，在分派源指定的队列上运行\ndispatch_source_set_event_handler(dispatch_source_t  _Nonnull source, ^(void)handler) \n\ndispatch_source_get_data(dispatch_source_t  _Nonnull source) //得到分派源的数据\n\n//得到dispatch源创建，即调用dispatch_source_create的第二个参数\nuintptr_t dispatch_source_get_handle(dispatch_source_t source); \n\n//得到dispatch源创建，即调用dispatch_source_create的第三个参数\nunsigned long dispatch_source_get_mask(dispatch_source_t source); \n\n//取消dispatch源的事件处理--即不再调用block。如果调用dispatch_suspend只是暂停dispatch源。\nvoid dispatch_source_cancel(dispatch_source_t source); \n\n//检测是否dispatch源被取消，如果返回非0值则表明dispatch源已经被取消\nlong dispatch_source_testcancel(dispatch_source_t source); \n\n//dispatch源取消时调用的block，一般用于关闭文件或socket等，释放相关资源\nvoid dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t cancel_handler); \n\n//可用于设置dispatch源启动时调用block，调用完成后即释放这个block。也可在dispatch源运行当中随时调用这个函数。\nvoid dispatch_source_set_registration_handler(dispatch_source_t source, dispatch_block_t registration_handler); \n```\n\n##### 4 dispatch_source的基本用法\n\n```objective-c\ndispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, dispatch_get_global_queue(0, 0));\n  dispatch_source_set_event_handler(source, ^{\n    dispatch_sync(dispatch_get_main_queue(), ^{\n        //更新UI\n        NSLog(@\"更新UI\");\n    });\n});\ndispatch_resume(source);\ndispatch_async(dispatch_get_global_queue(0, 0), ^{\n\n    //网络请求\n    NSLog(@\"更新UI\");\n    dispatch_source_merge_data(source, 1); //通知队列\n    [NSThread sleepForTimeInterval:0.01];\n});\n```\n上面的例子创建一个source，source的type为ADD的方式，然后将事件触发后要执行的句柄添加到main队列里，在source创建后默认是挂起的，需要用`dispatch_resume`函数来恢复监听，在执行了`dispatch_source_merge_data`后一定要执行`[NSThread sleepForTimeInterval:0.01];`否则上面的句柄操作有可能不执行，后面为了测试监听，加入了一个for循环，用`dispatch_source_merge_data`来触发事件，但是在触发事件的响应句柄里我们只打印了一次，结果是每次相加的和，也就是10，而不是打印了4次。\n\n**原因：**`DISPATCH_SOURCE_TYPE_DATA_ADD`是将所有触发结果相加，最后统一执行响应，但是加入`sleepForTimeInterval`后，如果interval的时间越长，则每次触发都会响应，但是如果interval的时间很短，则会将触发后的结果相加后统一触发。\n\n这在更新UI时很有用，比如更新进度条时，没必要每次触发都响应，因为更新时还有其他的用户操作（用户输入，触碰等），所以可以统一触发\n\n```objective-c\n//创建source，以DISPATCH_SOURCE_TYPE_DATA_ADD的方式进行累加，而DISPATCH_SOURCE_TYPE_DATA_OR是对结果进行二进制或运算\ndispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, \t\tdispatch_get_main_queue());\n//事件触发后执行的句柄\ndispatch_source_set_event_handler(source,^{\n    NSLog(@\"监听函数：%lu\",dispatch_source_get_data(source));\n});\n//开启source\ndispatch_resume(source);\ndispatch_queue_t myqueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);  \ndispatch_async(myqueue, ^ {\n  for(int i = 1; i <= 4; i ++){\n     NSLog(@\"~~~~~~~~~~~~~~%d\", i);\n     //触发事件，向source发送事件，这里i不能为0，否则触发不了事件\n     dispatch_source_merge_data(source,i);\n     //当Interval的事件越长，则每次的句柄都会触发\n     [NSThread sleepForTimeInterval:0.01];\n  }\n});\n```\n##### 5  使用timer定时器\n\n```objective-c\ndispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)\n```\n\n- source 分派源\n- start 数控制计时器第一次触发的时刻。参数类型是 `dispatch_time_t`，这是一个opaque类型，我们不能直接操作它。我们得需要 `dispatch_time` 和  `dispatch_walltime` 函数来创建它们。另外，常量  `DISPATCH_TIME_NOW` 和 `DISPATCH_TIME_FOREVER` 通常很有用。\n- interval 间隔时间\n- leeway 计时器触发的精准程度\n\n实例：\n\n```objective-c\n//倒计时时间\n__block int timeout = 3;\n//创建队列\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n//创建timer\ndispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, \t\tqueue);\n//设置2s触发一次，0s的误差，2s执行\ndispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),2.0 * NSEC_PER_SEC, 0); \n//触发的事件\ndispatch_source_set_event_handler(_timer, ^{\n    if(timeout <= 0){ \n        //倒计时结束，取消dispatch源\n        dispatch_source_cancel(_timer);\n    } else {\n        timeout--;\n        dispatch_async(dispatch_get_main_queue(), ^{\n            //更新主界面的操作\n            NSLog(@\"倒计时:%d\", timeout);\n        });\n    }\n});\n//开始执行dispatch源\ndispatch_resume(_timer);\n```\n\n##### 6 dispatch_suspend挂起队列\n\n实例：\n\n```objective-c\n//创建DISPATCH_QUEUE_SERIAL队列\ndispatch_queue_t queue1 = dispatch_queue_create(\"com.itachi.queue1\", 0);\ndispatch_queue_t queue2 = dispatch_queue_create(\"com.itachi.queue2\", 0);\n//创建group\ndispatch_group_t group = dispatch_group_create();\n//异步执行任务\ndispatch_async(queue1, ^{\n    NSLog(@\"任务1：queue 1...\");\n    sleep(1);\n    NSLog(@\":white_check_mark:完成任务1\");\n});\n\ndispatch_async(queue2, ^{\n    NSLog(@\"任务1：queue 2...\");\n    sleep(1);\n    NSLog(@\":white_check_mark:完成任务2\");\n});\n\n//将队列加入到group\ndispatch_group_async(group, queue1, ^{\n    NSLog(@\":no_entry_sign:正在暂停1\");\n    dispatch_suspend(queue1);\n});\n\ndispatch_group_async(group, queue2, ^{\n    NSLog(@\":no_entry_sign:正在暂停2\");\n    dispatch_suspend(queue2);\n});\n\n//等待两个queue执行完毕后再执行\n//当将dispatch_group_wait(group, DISPATCH_TIME_FOREVER);注释后，会产生崩溃，因为所有的任务都是异步执行的，在执行恢复queue1和queue2队列的时候，可能这个时候还没有执行queue1和queue2的挂起队列\ndispatch_group_wait(group, DISPATCH_TIME_FOREVER);\nNSLog(@\"等待两个queue1完成, 再往下进行\");\n\n//异步执行任务\ndispatch_async(queue1, ^{\n    NSLog(@\"任务2：queue 1\");\n});\ndispatch_async(queue2, ^{\n    NSLog(@\"任务2：queue 2\");\n});\n\n//在这里将这两个队列重新恢复\ndispatch_resume(queue1);\ndispatch_resume(queue2);\n```\n\n##### 7 进度条实例\n\n```objective-c\n//1、指定DISPATCH_SOURCE_TYPE_DATA_ADD，做成Dispatch Source(分派源)。设定Main Dispatch Queue 为追加处理的Dispatch Queue\ndispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, \t\tdispatch_get_main_queue());\n__block NSUInteger totalComplete = 0;\ndispatch_source_set_event_handler(source, ^{\n    //当处理事件被最终执行时，计算后的数据可以通过dispatch_source_get_data来获取。这个数据的值在每次响应事件执行后会被重置，所以totalComplete的值是最终累积的值。\n    NSUInteger value = dispatch_source_get_data(source);\n    totalComplete += value;\n    NSLog(@\"进度：%@\", @((CGFloat)totalComplete/100));\n    NSLog(@\":large_blue_circle:线程号：%@\", [NSThread currentThread]);\n});\n\n//分派源创建时默认处于暂停状态，在分派源分派处理程序之前必须先恢复。\ndispatch_resume(source);\n\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n\n//2、恢复源后，就可以通过dispatch_source_merge_data向Dispatch Source(分派源)发送事件:\nfor (NSUInteger index = 0; index < 100; index++) {\n    dispatch_async(queue, ^{\n        dispatch_source_merge_data(source, 1);\n        NSLog(@\":recycle:线程号：%@~~~~~~~~~~~~i = %ld\", [NSThread currentThread], index);\n        usleep(20000);//0.02秒\n    });\n}\n\n//3、比较上面的for循环代码，将dispatch_async放在外面for循环的外面，打印结果不一样\ndispatch_async(queue, ^{\n    for (NSUInteger index = 0; index < 100; index++) {\n        dispatch_source_merge_data(source, 1);\n        NSLog(@\":recycle:线程号：%@~~~~~~~~~~~~i = %ld\", [NSThread currentThread], index);\n        usleep(20000);//0.02秒\n    }\n});\n//2是将100个任务添加到queue里面，而3是在queue里面添加一个任务，而这一个任务做了100次循环\n```\n\n\n转载自[iOS多线程——Dispatch Source](http://www.jianshu.com/p/880c2f9301b6)","slug":"GCD深入学习","published":1,"updated":"2017-12-08T09:29:20.351Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb1u1v7s00091us0t3s70n6h","content":"<p>今天继续深入了解一下GCD。</p>\n<h4 id=\"Dispatch-Source\"><a href=\"#Dispatch-Source\" class=\"headerlink\" title=\"Dispatch Source\"></a>Dispatch Source</h4><p>​    使用      <code>Dispatch Source</code>而不使用 <code>dispatch_async</code> 的唯一原因就是利用联结的优势。</p>\n<p>​    联结的大致流程：在任一线程上调用它的一个函数<code>dispatch_source_merge_data</code> 后，会执行<code>Dispatch Source</code> 事先定义好的句柄（可以把句柄简单理解为一个 block ）。这个过程叫 Custom event ，用户事件。是 <code>dispatch source</code> 支持处理的一种事件。简单地说，这种事件是由你调用 <code>dispatch_source_merge_data</code> 函数来向自己发出的信号。</p>\n<h5 id=\"1-创建dispatch源\"><a href=\"#1-创建dispatch源\" class=\"headerlink\" title=\"1 创建dispatch源\"></a>1 创建dispatch源</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_source_t source = dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, unsigned long mask, dispatch_queue_t queue)</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>type</td>\n<td>dispatch源可处理的事件</td>\n</tr>\n<tr>\n<td>handle</td>\n<td>可以理解为句柄、索引或id，假如要监听进程，需要传入进程的ID</td>\n</tr>\n<tr>\n<td>mask</td>\n<td>可以理解为描述，提供更详细的描述，让它知道具体要监听什么</td>\n</tr>\n<tr>\n<td>queue</td>\n<td>自定义源需要的一个队列，用来处理所有的响应句柄（block）</td>\n</tr>\n</tbody>\n</table>\n<a id=\"more\"></a>\n<h5 id=\"2-Dispatch-Source可处理的所有事件\"><a href=\"#2-Dispatch-Source可处理的所有事件\" class=\"headerlink\" title=\"2 Dispatch Source可处理的所有事件\"></a>2 <strong>Dispatch Source可处理的所有事件</strong></h5><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DISPATCH_SOURCE_TYPE_DATA_ADD</td>\n<td>自定义的事件，变量增加</td>\n</tr>\n<tr>\n<td>DISPATCH_SOURCE_TYPE_DATA_OR</td>\n<td>自定义的事件，变量OR</td>\n</tr>\n<tr>\n<td>DISPATCH_SOURCE_TYPE_MACH_SEND</td>\n<td>MACH端口发送</td>\n</tr>\n<tr>\n<td>DISPATCH_SOURCE_TYPE_MACH_RECV</td>\n<td>MACH端口接收</td>\n</tr>\n<tr>\n<td>DISPATCH_SOURCE_TYPE_PROC</td>\n<td>进程监听,如进程的退出、创建一个或更多的子线程、进程收到UNIX信号</td>\n</tr>\n<tr>\n<td>DISPATCH_SOURCE_TYPE_READ</td>\n<td>IO操作，如对文件的操作、socket操作的读响应</td>\n</tr>\n<tr>\n<td>DISPATCH_SOURCE_TYPE_SIGNAL</td>\n<td>接收到UNIX信号时响应</td>\n</tr>\n<tr>\n<td>DISPATCH_SOURCE_TYPE_TIMER</td>\n<td>定时器</td>\n</tr>\n<tr>\n<td>DISPATCH_SOURCE_TYPE_VNODE</td>\n<td>文件状态监听，文件被删除、移动、重命名</td>\n</tr>\n<tr>\n<td>DISPATCH_SOURCE_TYPE_WRITE</td>\n<td>IO操作，如对文件的操作、socket操作的写响应</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意：</strong></p>\n<ul>\n<li><code>DISPATCH_SOURCE_TYPE_DATA_ADD</code>当同一时间，一个事件的的触发频率很高，那么Dispatch Source会将这些响应以ADD的方式进行累积，然后等系统空闲时最终处理，如果触发频率比较零散，那么Dispatch Source会将这些事件分别响应。</li>\n<li><code>DISPATCH_SOURCE_TYPE_DATA_OR</code> 和上面的一样，是自定义的事件，但是它是以OR的方式进行累积</li>\n</ul>\n<h5 id=\"3-一些函数\"><a href=\"#3-一些函数\" class=\"headerlink\" title=\"3 一些函数\"></a>3 一些函数</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_suspend(queue)  //挂起队列</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_resume(source)  //分派源创建时默认处于暂停状态，在分派源分派处理程序之前必须先恢复</span><br><span class=\"line\"></span><br><span class=\"line\">//向分派源发送事件，需要注意的是，不可以传递0值(事件不会被触发)，同样也不可以传递负数。</span><br><span class=\"line\">dispatch_source_merge_data(dispatch_source_t  _Nonnull source, unsigned long value)</span><br><span class=\"line\"></span><br><span class=\"line\">//设置响应分派源事件的block，在分派源指定的队列上运行</span><br><span class=\"line\">dispatch_source_set_event_handler(dispatch_source_t  _Nonnull source, ^(void)handler) </span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_source_get_data(dispatch_source_t  _Nonnull source) //得到分派源的数据</span><br><span class=\"line\"></span><br><span class=\"line\">//得到dispatch源创建，即调用dispatch_source_create的第二个参数</span><br><span class=\"line\">uintptr_t dispatch_source_get_handle(dispatch_source_t source); </span><br><span class=\"line\"></span><br><span class=\"line\">//得到dispatch源创建，即调用dispatch_source_create的第三个参数</span><br><span class=\"line\">unsigned long dispatch_source_get_mask(dispatch_source_t source); </span><br><span class=\"line\"></span><br><span class=\"line\">//取消dispatch源的事件处理--即不再调用block。如果调用dispatch_suspend只是暂停dispatch源。</span><br><span class=\"line\">void dispatch_source_cancel(dispatch_source_t source); </span><br><span class=\"line\"></span><br><span class=\"line\">//检测是否dispatch源被取消，如果返回非0值则表明dispatch源已经被取消</span><br><span class=\"line\">long dispatch_source_testcancel(dispatch_source_t source); </span><br><span class=\"line\"></span><br><span class=\"line\">//dispatch源取消时调用的block，一般用于关闭文件或socket等，释放相关资源</span><br><span class=\"line\">void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t cancel_handler); </span><br><span class=\"line\"></span><br><span class=\"line\">//可用于设置dispatch源启动时调用block，调用完成后即释放这个block。也可在dispatch源运行当中随时调用这个函数。</span><br><span class=\"line\">void dispatch_source_set_registration_handler(dispatch_source_t source, dispatch_block_t registration_handler);</span><br></pre></td></tr></table></figure>\n<h5 id=\"4-dispatch-source的基本用法\"><a href=\"#4-dispatch-source的基本用法\" class=\"headerlink\" title=\"4 dispatch_source的基本用法\"></a>4 dispatch_source的基本用法</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, dispatch_get_global_queue(0, 0));</span><br><span class=\"line\">  dispatch_source_set_event_handler(source, ^&#123;</span><br><span class=\"line\">    dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        //更新UI</span><br><span class=\"line\">        NSLog(@&quot;更新UI&quot;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_resume(source);</span><br><span class=\"line\">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //网络请求</span><br><span class=\"line\">    NSLog(@&quot;更新UI&quot;);</span><br><span class=\"line\">    dispatch_source_merge_data(source, 1); //通知队列</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:0.01];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面的例子创建一个source，source的type为ADD的方式，然后将事件触发后要执行的句柄添加到main队列里，在source创建后默认是挂起的，需要用<code>dispatch_resume</code>函数来恢复监听，在执行了<code>dispatch_source_merge_data</code>后一定要执行<code>[NSThread sleepForTimeInterval:0.01];</code>否则上面的句柄操作有可能不执行，后面为了测试监听，加入了一个for循环，用<code>dispatch_source_merge_data</code>来触发事件，但是在触发事件的响应句柄里我们只打印了一次，结果是每次相加的和，也就是10，而不是打印了4次。</p>\n<p><strong>原因：</strong><code>DISPATCH_SOURCE_TYPE_DATA_ADD</code>是将所有触发结果相加，最后统一执行响应，但是加入<code>sleepForTimeInterval</code>后，如果interval的时间越长，则每次触发都会响应，但是如果interval的时间很短，则会将触发后的结果相加后统一触发。</p>\n<p>这在更新UI时很有用，比如更新进度条时，没必要每次触发都响应，因为更新时还有其他的用户操作（用户输入，触碰等），所以可以统一触发</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//创建source，以DISPATCH_SOURCE_TYPE_DATA_ADD的方式进行累加，而DISPATCH_SOURCE_TYPE_DATA_OR是对结果进行二进制或运算</span><br><span class=\"line\">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, \t\tdispatch_get_main_queue());</span><br><span class=\"line\">//事件触发后执行的句柄</span><br><span class=\"line\">dispatch_source_set_event_handler(source,^&#123;</span><br><span class=\"line\">    NSLog(@&quot;监听函数：%lu&quot;,dispatch_source_get_data(source));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">//开启source</span><br><span class=\"line\">dispatch_resume(source);</span><br><span class=\"line\">dispatch_queue_t myqueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);  </span><br><span class=\"line\">dispatch_async(myqueue, ^ &#123;</span><br><span class=\"line\">  for(int i = 1; i &lt;= 4; i ++)&#123;</span><br><span class=\"line\">     NSLog(@&quot;~~~~~~~~~~~~~~%d&quot;, i);</span><br><span class=\"line\">     //触发事件，向source发送事件，这里i不能为0，否则触发不了事件</span><br><span class=\"line\">     dispatch_source_merge_data(source,i);</span><br><span class=\"line\">     //当Interval的事件越长，则每次的句柄都会触发</span><br><span class=\"line\">     [NSThread sleepForTimeInterval:0.01];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h5 id=\"5-使用timer定时器\"><a href=\"#5-使用timer定时器\" class=\"headerlink\" title=\"5  使用timer定时器\"></a>5  使用timer定时器</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>source 分派源</li>\n<li>start 数控制计时器第一次触发的时刻。参数类型是 <code>dispatch_time_t</code>，这是一个opaque类型，我们不能直接操作它。我们得需要 <code>dispatch_time</code> 和  <code>dispatch_walltime</code> 函数来创建它们。另外，常量  <code>DISPATCH_TIME_NOW</code> 和 <code>DISPATCH_TIME_FOREVER</code> 通常很有用。</li>\n<li>interval 间隔时间</li>\n<li>leeway 计时器触发的精准程度</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//倒计时时间</span><br><span class=\"line\">__block int timeout = 3;</span><br><span class=\"line\">//创建队列</span><br><span class=\"line\">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class=\"line\">//创建timer</span><br><span class=\"line\">dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, \t\tqueue);</span><br><span class=\"line\">//设置2s触发一次，0s的误差，2s执行</span><br><span class=\"line\">dispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),2.0 * NSEC_PER_SEC, 0); </span><br><span class=\"line\">//触发的事件</span><br><span class=\"line\">dispatch_source_set_event_handler(_timer, ^&#123;</span><br><span class=\"line\">    if(timeout &lt;= 0)&#123; </span><br><span class=\"line\">        //倒计时结束，取消dispatch源</span><br><span class=\"line\">        dispatch_source_cancel(_timer);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        timeout--;</span><br><span class=\"line\">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">            //更新主界面的操作</span><br><span class=\"line\">            NSLog(@&quot;倒计时:%d&quot;, timeout);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">//开始执行dispatch源</span><br><span class=\"line\">dispatch_resume(_timer);</span><br></pre></td></tr></table></figure>\n<h5 id=\"6-dispatch-suspend挂起队列\"><a href=\"#6-dispatch-suspend挂起队列\" class=\"headerlink\" title=\"6 dispatch_suspend挂起队列\"></a>6 dispatch_suspend挂起队列</h5><p>实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//创建DISPATCH_QUEUE_SERIAL队列</span><br><span class=\"line\">dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.itachi.queue1&quot;, 0);</span><br><span class=\"line\">dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.itachi.queue2&quot;, 0);</span><br><span class=\"line\">//创建group</span><br><span class=\"line\">dispatch_group_t group = dispatch_group_create();</span><br><span class=\"line\">//异步执行任务</span><br><span class=\"line\">dispatch_async(queue1, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;任务1：queue 1...&quot;);</span><br><span class=\"line\">    sleep(1);</span><br><span class=\"line\">    NSLog(@&quot;:white_check_mark:完成任务1&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(queue2, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;任务1：queue 2...&quot;);</span><br><span class=\"line\">    sleep(1);</span><br><span class=\"line\">    NSLog(@&quot;:white_check_mark:完成任务2&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//将队列加入到group</span><br><span class=\"line\">dispatch_group_async(group, queue1, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;:no_entry_sign:正在暂停1&quot;);</span><br><span class=\"line\">    dispatch_suspend(queue1);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_group_async(group, queue2, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;:no_entry_sign:正在暂停2&quot;);</span><br><span class=\"line\">    dispatch_suspend(queue2);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//等待两个queue执行完毕后再执行</span><br><span class=\"line\">//当将dispatch_group_wait(group, DISPATCH_TIME_FOREVER);注释后，会产生崩溃，因为所有的任务都是异步执行的，在执行恢复queue1和queue2队列的时候，可能这个时候还没有执行queue1和queue2的挂起队列</span><br><span class=\"line\">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class=\"line\">NSLog(@&quot;等待两个queue1完成, 再往下进行&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">//异步执行任务</span><br><span class=\"line\">dispatch_async(queue1, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;任务2：queue 1&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_async(queue2, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;任务2：queue 2&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//在这里将这两个队列重新恢复</span><br><span class=\"line\">dispatch_resume(queue1);</span><br><span class=\"line\">dispatch_resume(queue2);</span><br></pre></td></tr></table></figure>\n<h5 id=\"7-进度条实例\"><a href=\"#7-进度条实例\" class=\"headerlink\" title=\"7 进度条实例\"></a>7 进度条实例</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1、指定DISPATCH_SOURCE_TYPE_DATA_ADD，做成Dispatch Source(分派源)。设定Main Dispatch Queue 为追加处理的Dispatch Queue</span><br><span class=\"line\">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, \t\tdispatch_get_main_queue());</span><br><span class=\"line\">__block NSUInteger totalComplete = 0;</span><br><span class=\"line\">dispatch_source_set_event_handler(source, ^&#123;</span><br><span class=\"line\">    //当处理事件被最终执行时，计算后的数据可以通过dispatch_source_get_data来获取。这个数据的值在每次响应事件执行后会被重置，所以totalComplete的值是最终累积的值。</span><br><span class=\"line\">    NSUInteger value = dispatch_source_get_data(source);</span><br><span class=\"line\">    totalComplete += value;</span><br><span class=\"line\">    NSLog(@&quot;进度：%@&quot;, @((CGFloat)totalComplete/100));</span><br><span class=\"line\">    NSLog(@&quot;:large_blue_circle:线程号：%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//分派源创建时默认处于暂停状态，在分派源分派处理程序之前必须先恢复。</span><br><span class=\"line\">dispatch_resume(source);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">//2、恢复源后，就可以通过dispatch_source_merge_data向Dispatch Source(分派源)发送事件:</span><br><span class=\"line\">for (NSUInteger index = 0; index &lt; 100; index++) &#123;</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        dispatch_source_merge_data(source, 1);</span><br><span class=\"line\">        NSLog(@&quot;:recycle:线程号：%@~~~~~~~~~~~~i = %ld&quot;, [NSThread currentThread], index);</span><br><span class=\"line\">        usleep(20000);//0.02秒</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//3、比较上面的for循环代码，将dispatch_async放在外面for循环的外面，打印结果不一样</span><br><span class=\"line\">dispatch_async(queue, ^&#123;</span><br><span class=\"line\">    for (NSUInteger index = 0; index &lt; 100; index++) &#123;</span><br><span class=\"line\">        dispatch_source_merge_data(source, 1);</span><br><span class=\"line\">        NSLog(@&quot;:recycle:线程号：%@~~~~~~~~~~~~i = %ld&quot;, [NSThread currentThread], index);</span><br><span class=\"line\">        usleep(20000);//0.02秒</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">//2是将100个任务添加到queue里面，而3是在queue里面添加一个任务，而这一个任务做了100次循环</span><br></pre></td></tr></table></figure>\n<p>转载自<a href=\"http://www.jianshu.com/p/880c2f9301b6\" target=\"_blank\" rel=\"noopener\">iOS多线程——Dispatch Source</a></p>\n","site":{"data":{}},"excerpt":"<p>今天继续深入了解一下GCD。</p>\n<h4 id=\"Dispatch-Source\"><a href=\"#Dispatch-Source\" class=\"headerlink\" title=\"Dispatch Source\"></a>Dispatch Source</h4><p>​    使用      <code>Dispatch Source</code>而不使用 <code>dispatch_async</code> 的唯一原因就是利用联结的优势。</p>\n<p>​    联结的大致流程：在任一线程上调用它的一个函数<code>dispatch_source_merge_data</code> 后，会执行<code>Dispatch Source</code> 事先定义好的句柄（可以把句柄简单理解为一个 block ）。这个过程叫 Custom event ，用户事件。是 <code>dispatch source</code> 支持处理的一种事件。简单地说，这种事件是由你调用 <code>dispatch_source_merge_data</code> 函数来向自己发出的信号。</p>\n<h5 id=\"1-创建dispatch源\"><a href=\"#1-创建dispatch源\" class=\"headerlink\" title=\"1 创建dispatch源\"></a>1 创建dispatch源</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_source_t source = dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, unsigned long mask, dispatch_queue_t queue)</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>type</td>\n<td>dispatch源可处理的事件</td>\n</tr>\n<tr>\n<td>handle</td>\n<td>可以理解为句柄、索引或id，假如要监听进程，需要传入进程的ID</td>\n</tr>\n<tr>\n<td>mask</td>\n<td>可以理解为描述，提供更详细的描述，让它知道具体要监听什么</td>\n</tr>\n<tr>\n<td>queue</td>\n<td>自定义源需要的一个队列，用来处理所有的响应句柄（block）</td>\n</tr>\n</tbody>\n</table>","more":"<h5 id=\"2-Dispatch-Source可处理的所有事件\"><a href=\"#2-Dispatch-Source可处理的所有事件\" class=\"headerlink\" title=\"2 Dispatch Source可处理的所有事件\"></a>2 <strong>Dispatch Source可处理的所有事件</strong></h5><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DISPATCH_SOURCE_TYPE_DATA_ADD</td>\n<td>自定义的事件，变量增加</td>\n</tr>\n<tr>\n<td>DISPATCH_SOURCE_TYPE_DATA_OR</td>\n<td>自定义的事件，变量OR</td>\n</tr>\n<tr>\n<td>DISPATCH_SOURCE_TYPE_MACH_SEND</td>\n<td>MACH端口发送</td>\n</tr>\n<tr>\n<td>DISPATCH_SOURCE_TYPE_MACH_RECV</td>\n<td>MACH端口接收</td>\n</tr>\n<tr>\n<td>DISPATCH_SOURCE_TYPE_PROC</td>\n<td>进程监听,如进程的退出、创建一个或更多的子线程、进程收到UNIX信号</td>\n</tr>\n<tr>\n<td>DISPATCH_SOURCE_TYPE_READ</td>\n<td>IO操作，如对文件的操作、socket操作的读响应</td>\n</tr>\n<tr>\n<td>DISPATCH_SOURCE_TYPE_SIGNAL</td>\n<td>接收到UNIX信号时响应</td>\n</tr>\n<tr>\n<td>DISPATCH_SOURCE_TYPE_TIMER</td>\n<td>定时器</td>\n</tr>\n<tr>\n<td>DISPATCH_SOURCE_TYPE_VNODE</td>\n<td>文件状态监听，文件被删除、移动、重命名</td>\n</tr>\n<tr>\n<td>DISPATCH_SOURCE_TYPE_WRITE</td>\n<td>IO操作，如对文件的操作、socket操作的写响应</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意：</strong></p>\n<ul>\n<li><code>DISPATCH_SOURCE_TYPE_DATA_ADD</code>当同一时间，一个事件的的触发频率很高，那么Dispatch Source会将这些响应以ADD的方式进行累积，然后等系统空闲时最终处理，如果触发频率比较零散，那么Dispatch Source会将这些事件分别响应。</li>\n<li><code>DISPATCH_SOURCE_TYPE_DATA_OR</code> 和上面的一样，是自定义的事件，但是它是以OR的方式进行累积</li>\n</ul>\n<h5 id=\"3-一些函数\"><a href=\"#3-一些函数\" class=\"headerlink\" title=\"3 一些函数\"></a>3 一些函数</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_suspend(queue)  //挂起队列</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_resume(source)  //分派源创建时默认处于暂停状态，在分派源分派处理程序之前必须先恢复</span><br><span class=\"line\"></span><br><span class=\"line\">//向分派源发送事件，需要注意的是，不可以传递0值(事件不会被触发)，同样也不可以传递负数。</span><br><span class=\"line\">dispatch_source_merge_data(dispatch_source_t  _Nonnull source, unsigned long value)</span><br><span class=\"line\"></span><br><span class=\"line\">//设置响应分派源事件的block，在分派源指定的队列上运行</span><br><span class=\"line\">dispatch_source_set_event_handler(dispatch_source_t  _Nonnull source, ^(void)handler) </span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_source_get_data(dispatch_source_t  _Nonnull source) //得到分派源的数据</span><br><span class=\"line\"></span><br><span class=\"line\">//得到dispatch源创建，即调用dispatch_source_create的第二个参数</span><br><span class=\"line\">uintptr_t dispatch_source_get_handle(dispatch_source_t source); </span><br><span class=\"line\"></span><br><span class=\"line\">//得到dispatch源创建，即调用dispatch_source_create的第三个参数</span><br><span class=\"line\">unsigned long dispatch_source_get_mask(dispatch_source_t source); </span><br><span class=\"line\"></span><br><span class=\"line\">//取消dispatch源的事件处理--即不再调用block。如果调用dispatch_suspend只是暂停dispatch源。</span><br><span class=\"line\">void dispatch_source_cancel(dispatch_source_t source); </span><br><span class=\"line\"></span><br><span class=\"line\">//检测是否dispatch源被取消，如果返回非0值则表明dispatch源已经被取消</span><br><span class=\"line\">long dispatch_source_testcancel(dispatch_source_t source); </span><br><span class=\"line\"></span><br><span class=\"line\">//dispatch源取消时调用的block，一般用于关闭文件或socket等，释放相关资源</span><br><span class=\"line\">void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t cancel_handler); </span><br><span class=\"line\"></span><br><span class=\"line\">//可用于设置dispatch源启动时调用block，调用完成后即释放这个block。也可在dispatch源运行当中随时调用这个函数。</span><br><span class=\"line\">void dispatch_source_set_registration_handler(dispatch_source_t source, dispatch_block_t registration_handler);</span><br></pre></td></tr></table></figure>\n<h5 id=\"4-dispatch-source的基本用法\"><a href=\"#4-dispatch-source的基本用法\" class=\"headerlink\" title=\"4 dispatch_source的基本用法\"></a>4 dispatch_source的基本用法</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, dispatch_get_global_queue(0, 0));</span><br><span class=\"line\">  dispatch_source_set_event_handler(source, ^&#123;</span><br><span class=\"line\">    dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        //更新UI</span><br><span class=\"line\">        NSLog(@&quot;更新UI&quot;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_resume(source);</span><br><span class=\"line\">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //网络请求</span><br><span class=\"line\">    NSLog(@&quot;更新UI&quot;);</span><br><span class=\"line\">    dispatch_source_merge_data(source, 1); //通知队列</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:0.01];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面的例子创建一个source，source的type为ADD的方式，然后将事件触发后要执行的句柄添加到main队列里，在source创建后默认是挂起的，需要用<code>dispatch_resume</code>函数来恢复监听，在执行了<code>dispatch_source_merge_data</code>后一定要执行<code>[NSThread sleepForTimeInterval:0.01];</code>否则上面的句柄操作有可能不执行，后面为了测试监听，加入了一个for循环，用<code>dispatch_source_merge_data</code>来触发事件，但是在触发事件的响应句柄里我们只打印了一次，结果是每次相加的和，也就是10，而不是打印了4次。</p>\n<p><strong>原因：</strong><code>DISPATCH_SOURCE_TYPE_DATA_ADD</code>是将所有触发结果相加，最后统一执行响应，但是加入<code>sleepForTimeInterval</code>后，如果interval的时间越长，则每次触发都会响应，但是如果interval的时间很短，则会将触发后的结果相加后统一触发。</p>\n<p>这在更新UI时很有用，比如更新进度条时，没必要每次触发都响应，因为更新时还有其他的用户操作（用户输入，触碰等），所以可以统一触发</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//创建source，以DISPATCH_SOURCE_TYPE_DATA_ADD的方式进行累加，而DISPATCH_SOURCE_TYPE_DATA_OR是对结果进行二进制或运算</span><br><span class=\"line\">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, \t\tdispatch_get_main_queue());</span><br><span class=\"line\">//事件触发后执行的句柄</span><br><span class=\"line\">dispatch_source_set_event_handler(source,^&#123;</span><br><span class=\"line\">    NSLog(@&quot;监听函数：%lu&quot;,dispatch_source_get_data(source));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">//开启source</span><br><span class=\"line\">dispatch_resume(source);</span><br><span class=\"line\">dispatch_queue_t myqueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);  </span><br><span class=\"line\">dispatch_async(myqueue, ^ &#123;</span><br><span class=\"line\">  for(int i = 1; i &lt;= 4; i ++)&#123;</span><br><span class=\"line\">     NSLog(@&quot;~~~~~~~~~~~~~~%d&quot;, i);</span><br><span class=\"line\">     //触发事件，向source发送事件，这里i不能为0，否则触发不了事件</span><br><span class=\"line\">     dispatch_source_merge_data(source,i);</span><br><span class=\"line\">     //当Interval的事件越长，则每次的句柄都会触发</span><br><span class=\"line\">     [NSThread sleepForTimeInterval:0.01];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h5 id=\"5-使用timer定时器\"><a href=\"#5-使用timer定时器\" class=\"headerlink\" title=\"5  使用timer定时器\"></a>5  使用timer定时器</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>source 分派源</li>\n<li>start 数控制计时器第一次触发的时刻。参数类型是 <code>dispatch_time_t</code>，这是一个opaque类型，我们不能直接操作它。我们得需要 <code>dispatch_time</code> 和  <code>dispatch_walltime</code> 函数来创建它们。另外，常量  <code>DISPATCH_TIME_NOW</code> 和 <code>DISPATCH_TIME_FOREVER</code> 通常很有用。</li>\n<li>interval 间隔时间</li>\n<li>leeway 计时器触发的精准程度</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//倒计时时间</span><br><span class=\"line\">__block int timeout = 3;</span><br><span class=\"line\">//创建队列</span><br><span class=\"line\">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class=\"line\">//创建timer</span><br><span class=\"line\">dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, \t\tqueue);</span><br><span class=\"line\">//设置2s触发一次，0s的误差，2s执行</span><br><span class=\"line\">dispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),2.0 * NSEC_PER_SEC, 0); </span><br><span class=\"line\">//触发的事件</span><br><span class=\"line\">dispatch_source_set_event_handler(_timer, ^&#123;</span><br><span class=\"line\">    if(timeout &lt;= 0)&#123; </span><br><span class=\"line\">        //倒计时结束，取消dispatch源</span><br><span class=\"line\">        dispatch_source_cancel(_timer);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        timeout--;</span><br><span class=\"line\">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">            //更新主界面的操作</span><br><span class=\"line\">            NSLog(@&quot;倒计时:%d&quot;, timeout);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">//开始执行dispatch源</span><br><span class=\"line\">dispatch_resume(_timer);</span><br></pre></td></tr></table></figure>\n<h5 id=\"6-dispatch-suspend挂起队列\"><a href=\"#6-dispatch-suspend挂起队列\" class=\"headerlink\" title=\"6 dispatch_suspend挂起队列\"></a>6 dispatch_suspend挂起队列</h5><p>实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//创建DISPATCH_QUEUE_SERIAL队列</span><br><span class=\"line\">dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.itachi.queue1&quot;, 0);</span><br><span class=\"line\">dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.itachi.queue2&quot;, 0);</span><br><span class=\"line\">//创建group</span><br><span class=\"line\">dispatch_group_t group = dispatch_group_create();</span><br><span class=\"line\">//异步执行任务</span><br><span class=\"line\">dispatch_async(queue1, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;任务1：queue 1...&quot;);</span><br><span class=\"line\">    sleep(1);</span><br><span class=\"line\">    NSLog(@&quot;:white_check_mark:完成任务1&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(queue2, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;任务1：queue 2...&quot;);</span><br><span class=\"line\">    sleep(1);</span><br><span class=\"line\">    NSLog(@&quot;:white_check_mark:完成任务2&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//将队列加入到group</span><br><span class=\"line\">dispatch_group_async(group, queue1, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;:no_entry_sign:正在暂停1&quot;);</span><br><span class=\"line\">    dispatch_suspend(queue1);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_group_async(group, queue2, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;:no_entry_sign:正在暂停2&quot;);</span><br><span class=\"line\">    dispatch_suspend(queue2);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//等待两个queue执行完毕后再执行</span><br><span class=\"line\">//当将dispatch_group_wait(group, DISPATCH_TIME_FOREVER);注释后，会产生崩溃，因为所有的任务都是异步执行的，在执行恢复queue1和queue2队列的时候，可能这个时候还没有执行queue1和queue2的挂起队列</span><br><span class=\"line\">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class=\"line\">NSLog(@&quot;等待两个queue1完成, 再往下进行&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">//异步执行任务</span><br><span class=\"line\">dispatch_async(queue1, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;任务2：queue 1&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_async(queue2, ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;任务2：queue 2&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//在这里将这两个队列重新恢复</span><br><span class=\"line\">dispatch_resume(queue1);</span><br><span class=\"line\">dispatch_resume(queue2);</span><br></pre></td></tr></table></figure>\n<h5 id=\"7-进度条实例\"><a href=\"#7-进度条实例\" class=\"headerlink\" title=\"7 进度条实例\"></a>7 进度条实例</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//1、指定DISPATCH_SOURCE_TYPE_DATA_ADD，做成Dispatch Source(分派源)。设定Main Dispatch Queue 为追加处理的Dispatch Queue</span><br><span class=\"line\">dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, \t\tdispatch_get_main_queue());</span><br><span class=\"line\">__block NSUInteger totalComplete = 0;</span><br><span class=\"line\">dispatch_source_set_event_handler(source, ^&#123;</span><br><span class=\"line\">    //当处理事件被最终执行时，计算后的数据可以通过dispatch_source_get_data来获取。这个数据的值在每次响应事件执行后会被重置，所以totalComplete的值是最终累积的值。</span><br><span class=\"line\">    NSUInteger value = dispatch_source_get_data(source);</span><br><span class=\"line\">    totalComplete += value;</span><br><span class=\"line\">    NSLog(@&quot;进度：%@&quot;, @((CGFloat)totalComplete/100));</span><br><span class=\"line\">    NSLog(@&quot;:large_blue_circle:线程号：%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">//分派源创建时默认处于暂停状态，在分派源分派处理程序之前必须先恢复。</span><br><span class=\"line\">dispatch_resume(source);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">//2、恢复源后，就可以通过dispatch_source_merge_data向Dispatch Source(分派源)发送事件:</span><br><span class=\"line\">for (NSUInteger index = 0; index &lt; 100; index++) &#123;</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        dispatch_source_merge_data(source, 1);</span><br><span class=\"line\">        NSLog(@&quot;:recycle:线程号：%@~~~~~~~~~~~~i = %ld&quot;, [NSThread currentThread], index);</span><br><span class=\"line\">        usleep(20000);//0.02秒</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//3、比较上面的for循环代码，将dispatch_async放在外面for循环的外面，打印结果不一样</span><br><span class=\"line\">dispatch_async(queue, ^&#123;</span><br><span class=\"line\">    for (NSUInteger index = 0; index &lt; 100; index++) &#123;</span><br><span class=\"line\">        dispatch_source_merge_data(source, 1);</span><br><span class=\"line\">        NSLog(@&quot;:recycle:线程号：%@~~~~~~~~~~~~i = %ld&quot;, [NSThread currentThread], index);</span><br><span class=\"line\">        usleep(20000);//0.02秒</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">//2是将100个任务添加到queue里面，而3是在queue里面添加一个任务，而这一个任务做了100次循环</span><br></pre></td></tr></table></figure>\n<p>转载自<a href=\"http://www.jianshu.com/p/880c2f9301b6\" target=\"_blank\" rel=\"noopener\">iOS多线程——Dispatch Source</a></p>"},{"title":"MarkDown","date":"2016-11-21T08:21:00.000Z","_content":"><font color=\"#4590a3\" size = \"4px\">文字</font>\n\n\n\n# This is an H1\n\n## This is an H2 \n\n### This is an H3 \n\n>哈哈我就是这个热线\n\n\n\t- (UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section\n\t{\n\t\tUIView *footV = [[PurchaseSectionFooterView alloc] init];\n\t\treturn footV;\n\t}\t\n\n\n> This is the first level of quoting.\n>\n> > This is nested blockquote.\n>\n> Back to the first level.\n> > > My name is Leo\n\n这是为啥呢\n\n<!--more -->\n\n> ## 这是一个标题。\n>\n> 1.   这是第一行列表项。\n> 2.   这是第二行列表项。\n>\n> 给出一些例子代码：\n>\n>     return shell_exec(\"echo $input | $markdown_script\");\n\n\n*   Red\n*   Green\n*   Blue\n\n+   Red\n+   Green\n+   Blue\n\n-   Red\n-   Green\n-   Blue\n\n1.  Bird\n2.  McHale\n3.  Parish\n\n\n<ol>\n<li>Bird</li>\n<li>McHale</li>\n<li>Parish</li>\n</ol>\n\n1.  Bird\n2.  McHale\n3.  Parish\n\n\n\n\n3. Bird\n4. McHale\n5. Parish\n\n<ul>\n<li>Bird</li>\n<li>Magic</li>\n</ul>\n\n1.  This is a list item with two paragraphs. Lorem ipsum dolor\n    sit amet, consectetuer adipiscing elit. Aliquam hendrerit\n    mi posuere lectus.\n\n    Vestibulum enim wisi, viverra nec, fringilla in, laoreet\n    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum\n    sit amet velit.\n\n2.  Suspendisse id sem consectetuer libero luctus adipiscing.\n\n\n*   This is a list item with two paragraphs.\n\n    This is the second paragraph in the list item. You're\n    only required to indent the first line. Lorem ipsum dolor\n    sit amet, consectetuer adipiscing elit.\n\n*   Another item in the same list.\n\n\n*   A list item with a blockquote:\n\n    > This is a blockquote\n    > inside a list item.\n\n\n*   一列表项包含一个列表区块：\n\n        <代码写在这>\n   \n\n1986\\. What a great season.\n\n* * *\n\n***\n\n*****\n\n- - -\n\n---------------------------------------\n\nThis is [an example](http://example.com/ \"Title\") inline link.\n\n[This link](http://example.net/) has no title attribute.\n\nSee my [About](/about/) page for details.\n\nThis is [an example][id] reference-style link.\n\nThis is [an example] [id] reference-style link.\n\n[link text][a]\n[link text][A]\n\n[id]: http://example.com/  \"Optional Title Here\"\n\n[A]: http://example.com/  \"Optional Title Here\"\n[foo]: http://example.com/  \"Optional Title Here\"\n[foo]: http://example.com/  \"Optional Title Here\"\n\n[Google][]\n[Google]: http://google.com/\n\nVisit [Daring Fireball][] for more information.\n[Daring Fireball]: http://daringfireball.net/\n\nI get 10 times more traffic from [Google] [1] than from\n[Yahoo] [2] or [MSN] [3].\n\n[1]: http://google.com/        \"Google\"\n[2]: http://search.yahoo.com/  \"Yahoo Search\"\n[3]: http://search.msn.com/    \"MSN Search\"\n\n\n<p>I get 10 times more traffic from <a href=\"http://google.com/\"\ntitle=\"Google\">Google</a> than from\n<a href=\"http://search.yahoo.com/\" title=\"Yahoo Search\">Yahoo</a>\nor <a href=\"http://search.msn.com/\" title=\"MSN Search\">MSN</a>.</p>\n\nI get 10 times more traffic from [Google](http://google.com/ \"Google\")\nthan from [Yahoo](http://search.yahoo.com/ \"Yahoo Search\") or\n[MSN](http://search.msn.com/ \"MSN Search\").\n\n\n*single asterisks*\n\n_ single underscores_\n\n**double asterisks**\n\n__double underscores__\n\nun*frigging*believable\n\n\\*this text is surrounded by literal asterisks\\*\n\nUse the `printf()` function.\n\n\n``There is a literal backtick (`) here.``\n\nA single backtick in a code span: `` ` ``\n\nA backtick-delimited string in a code span: `` `foo` ``\n\nPlease don't use any `<blink>` tags.\n\n&#1254; is the decimal-encoded equivalent of `&mdash;`.\n\n![Alt text](http://img5q.duitang.com/uploads/item/201306/26/20130626164439_MRL8t.thumb.700_0.jpeg) \n<center>luffy</center>\n![Alt text](http://img5q.duitang.com/uploads/item/201504/10/20150410H5845_3BHyr.jpeg)\n\n<address@example.com>\n\n\n\n插入外部链接图片\n![“图片描述”](“图片地址”)  \n\n添加本地图片\n在\\hexo\\source目录下新建文件夹，命名为images或者其他你喜欢的名字，然后编辑你的md博文，插入下面的代码样式：\n![“图片描述”](/images/你的图片名字.JPG)  \n\n插入音乐\n比如网易云音乐，找到喜欢的歌曲，点击分享按钮，把里面的代码复制下来，直接粘贴到博文中即可\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86>\n    src=\"http://music.163.com/outchain/player?type=2&id=25706282&auto=0&height=66\">  \n</iframe>  \n\n\n\t\t\\   反斜线\n\t\t`   反引号\n\t\t*   星号\n\t\t_   底线\n\t\t{}  花括号\n\t\t[]  方括号\n\t\t()  括弧\n\t\t#   井字号\n\t\t+   加号\n\t\t-   减号\n\t\t.   英文句点\n\t\t!   惊叹号","source":"_posts/MarkDown-Test.md","raw":"---\ntitle: MarkDown\ndate: 2016-11-21 16:21\ntags: Hexo\n---\n><font color=\"#4590a3\" size = \"4px\">文字</font>\n\n\n\n# This is an H1\n\n## This is an H2 \n\n### This is an H3 \n\n>哈哈我就是这个热线\n\n\n\t- (UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section\n\t{\n\t\tUIView *footV = [[PurchaseSectionFooterView alloc] init];\n\t\treturn footV;\n\t}\t\n\n\n> This is the first level of quoting.\n>\n> > This is nested blockquote.\n>\n> Back to the first level.\n> > > My name is Leo\n\n这是为啥呢\n\n<!--more -->\n\n> ## 这是一个标题。\n>\n> 1.   这是第一行列表项。\n> 2.   这是第二行列表项。\n>\n> 给出一些例子代码：\n>\n>     return shell_exec(\"echo $input | $markdown_script\");\n\n\n*   Red\n*   Green\n*   Blue\n\n+   Red\n+   Green\n+   Blue\n\n-   Red\n-   Green\n-   Blue\n\n1.  Bird\n2.  McHale\n3.  Parish\n\n\n<ol>\n<li>Bird</li>\n<li>McHale</li>\n<li>Parish</li>\n</ol>\n\n1.  Bird\n2.  McHale\n3.  Parish\n\n\n\n\n3. Bird\n4. McHale\n5. Parish\n\n<ul>\n<li>Bird</li>\n<li>Magic</li>\n</ul>\n\n1.  This is a list item with two paragraphs. Lorem ipsum dolor\n    sit amet, consectetuer adipiscing elit. Aliquam hendrerit\n    mi posuere lectus.\n\n    Vestibulum enim wisi, viverra nec, fringilla in, laoreet\n    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum\n    sit amet velit.\n\n2.  Suspendisse id sem consectetuer libero luctus adipiscing.\n\n\n*   This is a list item with two paragraphs.\n\n    This is the second paragraph in the list item. You're\n    only required to indent the first line. Lorem ipsum dolor\n    sit amet, consectetuer adipiscing elit.\n\n*   Another item in the same list.\n\n\n*   A list item with a blockquote:\n\n    > This is a blockquote\n    > inside a list item.\n\n\n*   一列表项包含一个列表区块：\n\n        <代码写在这>\n   \n\n1986\\. What a great season.\n\n* * *\n\n***\n\n*****\n\n- - -\n\n---------------------------------------\n\nThis is [an example](http://example.com/ \"Title\") inline link.\n\n[This link](http://example.net/) has no title attribute.\n\nSee my [About](/about/) page for details.\n\nThis is [an example][id] reference-style link.\n\nThis is [an example] [id] reference-style link.\n\n[link text][a]\n[link text][A]\n\n[id]: http://example.com/  \"Optional Title Here\"\n\n[A]: http://example.com/  \"Optional Title Here\"\n[foo]: http://example.com/  \"Optional Title Here\"\n[foo]: http://example.com/  \"Optional Title Here\"\n\n[Google][]\n[Google]: http://google.com/\n\nVisit [Daring Fireball][] for more information.\n[Daring Fireball]: http://daringfireball.net/\n\nI get 10 times more traffic from [Google] [1] than from\n[Yahoo] [2] or [MSN] [3].\n\n[1]: http://google.com/        \"Google\"\n[2]: http://search.yahoo.com/  \"Yahoo Search\"\n[3]: http://search.msn.com/    \"MSN Search\"\n\n\n<p>I get 10 times more traffic from <a href=\"http://google.com/\"\ntitle=\"Google\">Google</a> than from\n<a href=\"http://search.yahoo.com/\" title=\"Yahoo Search\">Yahoo</a>\nor <a href=\"http://search.msn.com/\" title=\"MSN Search\">MSN</a>.</p>\n\nI get 10 times more traffic from [Google](http://google.com/ \"Google\")\nthan from [Yahoo](http://search.yahoo.com/ \"Yahoo Search\") or\n[MSN](http://search.msn.com/ \"MSN Search\").\n\n\n*single asterisks*\n\n_ single underscores_\n\n**double asterisks**\n\n__double underscores__\n\nun*frigging*believable\n\n\\*this text is surrounded by literal asterisks\\*\n\nUse the `printf()` function.\n\n\n``There is a literal backtick (`) here.``\n\nA single backtick in a code span: `` ` ``\n\nA backtick-delimited string in a code span: `` `foo` ``\n\nPlease don't use any `<blink>` tags.\n\n&#1254; is the decimal-encoded equivalent of `&mdash;`.\n\n![Alt text](http://img5q.duitang.com/uploads/item/201306/26/20130626164439_MRL8t.thumb.700_0.jpeg) \n<center>luffy</center>\n![Alt text](http://img5q.duitang.com/uploads/item/201504/10/20150410H5845_3BHyr.jpeg)\n\n<address@example.com>\n\n\n\n插入外部链接图片\n![“图片描述”](“图片地址”)  \n\n添加本地图片\n在\\hexo\\source目录下新建文件夹，命名为images或者其他你喜欢的名字，然后编辑你的md博文，插入下面的代码样式：\n![“图片描述”](/images/你的图片名字.JPG)  \n\n插入音乐\n比如网易云音乐，找到喜欢的歌曲，点击分享按钮，把里面的代码复制下来，直接粘贴到博文中即可\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86>\n    src=\"http://music.163.com/outchain/player?type=2&id=25706282&auto=0&height=66\">  \n</iframe>  \n\n\n\t\t\\   反斜线\n\t\t`   反引号\n\t\t*   星号\n\t\t_   底线\n\t\t{}  花括号\n\t\t[]  方括号\n\t\t()  括弧\n\t\t#   井字号\n\t\t+   加号\n\t\t-   减号\n\t\t.   英文句点\n\t\t!   惊叹号","slug":"MarkDown-Test","published":1,"updated":"2017-12-06T02:25:10.916Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb1u1v7u000d1us0s5m4y2br","content":"<blockquote>\n<font color=\"#4590a3\" size=\"4px\">文字</font>\n\n\n\n</blockquote>\n<h1 id=\"This-is-an-H1\"><a href=\"#This-is-an-H1\" class=\"headerlink\" title=\"This is an H1\"></a>This is an H1</h1><h2 id=\"This-is-an-H2\"><a href=\"#This-is-an-H2\" class=\"headerlink\" title=\"This is an H2\"></a>This is an H2</h2><h3 id=\"This-is-an-H3\"><a href=\"#This-is-an-H3\" class=\"headerlink\" title=\"This is an H3\"></a>This is an H3</h3><blockquote>\n<p>哈哈我就是这个热线</p>\n</blockquote>\n<pre><code>- (UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section\n{\n    UIView *footV = [[PurchaseSectionFooterView alloc] init];\n    return footV;\n}    \n</code></pre><blockquote>\n<p>This is the first level of quoting.</p>\n<blockquote>\n<p>This is nested blockquote.</p>\n</blockquote>\n<p>Back to the first level.</p>\n<blockquote>\n<blockquote>\n<p>My name is Leo</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>这是为啥呢</p>\n<a id=\"more\"></a>\n<blockquote>\n<h2 id=\"这是一个标题。\"><a href=\"#这是一个标题。\" class=\"headerlink\" title=\"这是一个标题。\"></a>这是一个标题。</h2><ol>\n<li>这是第一行列表项。</li>\n<li>这是第二行列表项。</li>\n</ol>\n<p>给出一些例子代码：</p>\n<pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);\n</code></pre></blockquote>\n<ul>\n<li>Red</li>\n<li>Green</li>\n<li>Blue</li>\n</ul>\n<ul>\n<li>Red</li>\n<li>Green</li>\n<li>Blue</li>\n</ul>\n<ul>\n<li>Red</li>\n<li>Green</li>\n<li>Blue</li>\n</ul>\n<ol>\n<li>Bird</li>\n<li>McHale</li>\n<li>Parish</li>\n</ol>\n<ol><br><li>Bird</li><br><li>McHale</li><br><li>Parish</li><br></ol>\n\n<ol>\n<li>Bird</li>\n<li>McHale</li>\n<li>Parish</li>\n</ol>\n<ol>\n<li>Bird</li>\n<li>McHale</li>\n<li>Parish</li>\n</ol>\n<ul><br><li>Bird</li><br><li>Magic</li><br></ul>\n\n<ol>\n<li><p>This is a list item with two paragraphs. Lorem ipsum dolor<br>sit amet, consectetuer adipiscing elit. Aliquam hendrerit<br>mi posuere lectus.</p>\n<p>Vestibulum enim wisi, viverra nec, fringilla in, laoreet<br>vitae, risus. Donec sit amet nisl. Aliquam semper ipsum<br>sit amet velit.</p>\n</li>\n<li><p>Suspendisse id sem consectetuer libero luctus adipiscing.</p>\n</li>\n</ol>\n<ul>\n<li><p>This is a list item with two paragraphs.</p>\n<p>This is the second paragraph in the list item. You’re<br>only required to indent the first line. Lorem ipsum dolor<br>sit amet, consectetuer adipiscing elit.</p>\n</li>\n<li><p>Another item in the same list.</p>\n</li>\n</ul>\n<ul>\n<li><p>A list item with a blockquote:</p>\n<blockquote>\n<p>This is a blockquote<br>inside a list item.</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>一列表项包含一个列表区块：</p>\n<pre><code>&lt;代码写在这&gt;\n</code></pre></li>\n</ul>\n<p>1986. What a great season.</p>\n<hr>\n<hr>\n<hr>\n<hr>\n<hr>\n<p>This is <a href=\"http://example.com/\" title=\"Title\" target=\"_blank\" rel=\"noopener\">an example</a> inline link.</p>\n<p><a href=\"http://example.net/\" target=\"_blank\" rel=\"noopener\">This link</a> has no title attribute.</p>\n<p>See my <a href=\"/about/\">About</a> page for details.</p>\n<p>This is <a href=\"http://example.com/\" title=\"Optional Title Here\" target=\"_blank\" rel=\"noopener\">an example</a> reference-style link.</p>\n<p>This is <a href=\"http://example.com/\" title=\"Optional Title Here\" target=\"_blank\" rel=\"noopener\">an example</a> reference-style link.</p>\n<p><a href=\"http://example.com/\" title=\"Optional Title Here\" target=\"_blank\" rel=\"noopener\">link text</a><br><a href=\"http://example.com/\" title=\"Optional Title Here\" target=\"_blank\" rel=\"noopener\">link text</a></p>\n<p><a href=\"http://google.com/\" target=\"_blank\" rel=\"noopener\">Google</a></p>\n<p>Visit <a href=\"http://daringfireball.net/\" target=\"_blank\" rel=\"noopener\">Daring Fireball</a> for more information.</p>\n<p>I get 10 times more traffic from <a href=\"http://google.com/\" title=\"Google\" target=\"_blank\" rel=\"noopener\">Google</a> than from<br><a href=\"http://search.yahoo.com/\" title=\"Yahoo Search\" target=\"_blank\" rel=\"noopener\">Yahoo</a> or <a href=\"http://search.msn.com/\" title=\"MSN Search\" target=\"_blank\" rel=\"noopener\">MSN</a>.</p>\n<p>I get 10 times more traffic from <a href=\"http://google.com/\" title=\"Google\" target=\"_blank\" rel=\"noopener\">Google</a> than from<br><a href=\"http://search.yahoo.com/\" title=\"Yahoo Search\" target=\"_blank\" rel=\"noopener\">Yahoo</a><br>or <a href=\"http://search.msn.com/\" title=\"MSN Search\" target=\"_blank\" rel=\"noopener\">MSN</a>.</p>\n\n<p>I get 10 times more traffic from <a href=\"http://google.com/\" title=\"Google\" target=\"_blank\" rel=\"noopener\">Google</a><br>than from <a href=\"http://search.yahoo.com/\" title=\"Yahoo Search\" target=\"_blank\" rel=\"noopener\">Yahoo</a> or<br><a href=\"http://search.msn.com/\" title=\"MSN Search\" target=\"_blank\" rel=\"noopener\">MSN</a>.</p>\n<p><em>single asterisks</em></p>\n<p><em> single underscores</em></p>\n<p><strong>double asterisks</strong></p>\n<p><strong>double underscores</strong></p>\n<p>un<em>frigging</em>believable</p>\n<p>*this text is surrounded by literal asterisks*</p>\n<p>Use the <code>printf()</code> function.</p>\n<p><code>There is a literal backtick (`) here.</code></p>\n<p>A single backtick in a code span: <code>` </code></p>\n<p>A backtick-delimited string in a code span: <code>`foo` </code></p>\n<p>Please don’t use any <code>&lt;blink&gt;</code> tags.</p>\n<p>&#1254; is the decimal-encoded equivalent of <code>&amp;mdash;</code>.</p>\n<p><img src=\"http://img5q.duitang.com/uploads/item/201306/26/20130626164439_MRL8t.thumb.700_0.jpeg\" alt=\"Alt text\"> </p>\n<p><center>luffy</center><br><img src=\"http://img5q.duitang.com/uploads/item/201504/10/20150410H5845_3BHyr.jpeg\" alt=\"Alt text\"></p>\n<p><a href=\"&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#97;&#100;&#x64;&#114;&#x65;&#115;&#x73;&#x40;&#101;&#120;&#97;&#x6d;&#112;&#108;&#x65;&#x2e;&#99;&#111;&#109;\">&#97;&#100;&#x64;&#114;&#x65;&#115;&#x73;&#x40;&#101;&#120;&#97;&#x6d;&#112;&#108;&#x65;&#x2e;&#99;&#111;&#109;</a></p>\n<p>插入外部链接图片<br><img src=\"/2016/11/21/MarkDown-Test/“图片地址”\" alt=\"“图片描述”\">  </p>\n<p>添加本地图片<br>在\\hexo\\source目录下新建文件夹，命名为images或者其他你喜欢的名字，然后编辑你的md博文，插入下面的代码样式：<br><img src=\"/images/你的图片名字.JPG\" alt=\"“图片描述”\">  </p>\n<p>插入音乐<br>比如网易云音乐，找到喜欢的歌曲，点击分享按钮，把里面的代码复制下来，直接粘贴到博文中即可</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\"><br>    src=”<a href=\"http://music.163.com/outchain/player?type=2&amp;id=25706282&amp;auto=0&amp;height=66&quot;&gt;\" target=\"_blank\" rel=\"noopener\">http://music.163.com/outchain/player?type=2&amp;id=25706282&amp;auto=0&amp;height=66&quot;&gt;</a><br></iframe>  \n\n\n<pre><code>\\   反斜线\n`   反引号\n*   星号\n_   底线\n{}  花括号\n[]  方括号\n()  括弧\n#   井字号\n+   加号\n-   减号\n.   英文句点\n!   惊叹号\n</code></pre>","site":{"data":{}},"excerpt":"<blockquote>\n<font color=\"#4590a3\" size=\"4px\">文字</font>\n\n\n\n</blockquote>\n<h1 id=\"This-is-an-H1\"><a href=\"#This-is-an-H1\" class=\"headerlink\" title=\"This is an H1\"></a>This is an H1</h1><h2 id=\"This-is-an-H2\"><a href=\"#This-is-an-H2\" class=\"headerlink\" title=\"This is an H2\"></a>This is an H2</h2><h3 id=\"This-is-an-H3\"><a href=\"#This-is-an-H3\" class=\"headerlink\" title=\"This is an H3\"></a>This is an H3</h3><blockquote>\n<p>哈哈我就是这个热线</p>\n</blockquote>\n<pre><code>- (UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section\n{\n    UIView *footV = [[PurchaseSectionFooterView alloc] init];\n    return footV;\n}    \n</code></pre><blockquote>\n<p>This is the first level of quoting.</p>\n<blockquote>\n<p>This is nested blockquote.</p>\n</blockquote>\n<p>Back to the first level.</p>\n<blockquote>\n<blockquote>\n<p>My name is Leo</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>这是为啥呢</p>","more":"<blockquote>\n<h2 id=\"这是一个标题。\"><a href=\"#这是一个标题。\" class=\"headerlink\" title=\"这是一个标题。\"></a>这是一个标题。</h2><ol>\n<li>这是第一行列表项。</li>\n<li>这是第二行列表项。</li>\n</ol>\n<p>给出一些例子代码：</p>\n<pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);\n</code></pre></blockquote>\n<ul>\n<li>Red</li>\n<li>Green</li>\n<li>Blue</li>\n</ul>\n<ul>\n<li>Red</li>\n<li>Green</li>\n<li>Blue</li>\n</ul>\n<ul>\n<li>Red</li>\n<li>Green</li>\n<li>Blue</li>\n</ul>\n<ol>\n<li>Bird</li>\n<li>McHale</li>\n<li>Parish</li>\n</ol>\n<ol><br><li>Bird</li><br><li>McHale</li><br><li>Parish</li><br></ol>\n\n<ol>\n<li>Bird</li>\n<li>McHale</li>\n<li>Parish</li>\n</ol>\n<ol>\n<li>Bird</li>\n<li>McHale</li>\n<li>Parish</li>\n</ol>\n<ul><br><li>Bird</li><br><li>Magic</li><br></ul>\n\n<ol>\n<li><p>This is a list item with two paragraphs. Lorem ipsum dolor<br>sit amet, consectetuer adipiscing elit. Aliquam hendrerit<br>mi posuere lectus.</p>\n<p>Vestibulum enim wisi, viverra nec, fringilla in, laoreet<br>vitae, risus. Donec sit amet nisl. Aliquam semper ipsum<br>sit amet velit.</p>\n</li>\n<li><p>Suspendisse id sem consectetuer libero luctus adipiscing.</p>\n</li>\n</ol>\n<ul>\n<li><p>This is a list item with two paragraphs.</p>\n<p>This is the second paragraph in the list item. You’re<br>only required to indent the first line. Lorem ipsum dolor<br>sit amet, consectetuer adipiscing elit.</p>\n</li>\n<li><p>Another item in the same list.</p>\n</li>\n</ul>\n<ul>\n<li><p>A list item with a blockquote:</p>\n<blockquote>\n<p>This is a blockquote<br>inside a list item.</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>一列表项包含一个列表区块：</p>\n<pre><code>&lt;代码写在这&gt;\n</code></pre></li>\n</ul>\n<p>1986. What a great season.</p>\n<hr>\n<hr>\n<hr>\n<hr>\n<hr>\n<p>This is <a href=\"http://example.com/\" title=\"Title\" target=\"_blank\" rel=\"noopener\">an example</a> inline link.</p>\n<p><a href=\"http://example.net/\" target=\"_blank\" rel=\"noopener\">This link</a> has no title attribute.</p>\n<p>See my <a href=\"/about/\">About</a> page for details.</p>\n<p>This is <a href=\"http://example.com/\" title=\"Optional Title Here\" target=\"_blank\" rel=\"noopener\">an example</a> reference-style link.</p>\n<p>This is <a href=\"http://example.com/\" title=\"Optional Title Here\" target=\"_blank\" rel=\"noopener\">an example</a> reference-style link.</p>\n<p><a href=\"http://example.com/\" title=\"Optional Title Here\" target=\"_blank\" rel=\"noopener\">link text</a><br><a href=\"http://example.com/\" title=\"Optional Title Here\" target=\"_blank\" rel=\"noopener\">link text</a></p>\n<p><a href=\"http://google.com/\" target=\"_blank\" rel=\"noopener\">Google</a></p>\n<p>Visit <a href=\"http://daringfireball.net/\" target=\"_blank\" rel=\"noopener\">Daring Fireball</a> for more information.</p>\n<p>I get 10 times more traffic from <a href=\"http://google.com/\" title=\"Google\" target=\"_blank\" rel=\"noopener\">Google</a> than from<br><a href=\"http://search.yahoo.com/\" title=\"Yahoo Search\" target=\"_blank\" rel=\"noopener\">Yahoo</a> or <a href=\"http://search.msn.com/\" title=\"MSN Search\" target=\"_blank\" rel=\"noopener\">MSN</a>.</p>\n<p>I get 10 times more traffic from <a href=\"http://google.com/\" title=\"Google\" target=\"_blank\" rel=\"noopener\">Google</a> than from<br><a href=\"http://search.yahoo.com/\" title=\"Yahoo Search\" target=\"_blank\" rel=\"noopener\">Yahoo</a><br>or <a href=\"http://search.msn.com/\" title=\"MSN Search\" target=\"_blank\" rel=\"noopener\">MSN</a>.</p>\n\n<p>I get 10 times more traffic from <a href=\"http://google.com/\" title=\"Google\" target=\"_blank\" rel=\"noopener\">Google</a><br>than from <a href=\"http://search.yahoo.com/\" title=\"Yahoo Search\" target=\"_blank\" rel=\"noopener\">Yahoo</a> or<br><a href=\"http://search.msn.com/\" title=\"MSN Search\" target=\"_blank\" rel=\"noopener\">MSN</a>.</p>\n<p><em>single asterisks</em></p>\n<p><em> single underscores</em></p>\n<p><strong>double asterisks</strong></p>\n<p><strong>double underscores</strong></p>\n<p>un<em>frigging</em>believable</p>\n<p>*this text is surrounded by literal asterisks*</p>\n<p>Use the <code>printf()</code> function.</p>\n<p><code>There is a literal backtick (`) here.</code></p>\n<p>A single backtick in a code span: <code>` </code></p>\n<p>A backtick-delimited string in a code span: <code>`foo` </code></p>\n<p>Please don’t use any <code>&lt;blink&gt;</code> tags.</p>\n<p>&#1254; is the decimal-encoded equivalent of <code>&amp;mdash;</code>.</p>\n<p><img src=\"http://img5q.duitang.com/uploads/item/201306/26/20130626164439_MRL8t.thumb.700_0.jpeg\" alt=\"Alt text\"> </p>\n<p><center>luffy</center><br><img src=\"http://img5q.duitang.com/uploads/item/201504/10/20150410H5845_3BHyr.jpeg\" alt=\"Alt text\"></p>\n<p><a href=\"&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#97;&#100;&#x64;&#114;&#x65;&#115;&#x73;&#x40;&#101;&#120;&#97;&#x6d;&#112;&#108;&#x65;&#x2e;&#99;&#111;&#109;\">&#97;&#100;&#x64;&#114;&#x65;&#115;&#x73;&#x40;&#101;&#120;&#97;&#x6d;&#112;&#108;&#x65;&#x2e;&#99;&#111;&#109;</a></p>\n<p>插入外部链接图片<br><img src=\"/2016/11/21/MarkDown-Test/“图片地址”\" alt=\"“图片描述”\">  </p>\n<p>添加本地图片<br>在\\hexo\\source目录下新建文件夹，命名为images或者其他你喜欢的名字，然后编辑你的md博文，插入下面的代码样式：<br><img src=\"/images/你的图片名字.JPG\" alt=\"“图片描述”\">  </p>\n<p>插入音乐<br>比如网易云音乐，找到喜欢的歌曲，点击分享按钮，把里面的代码复制下来，直接粘贴到博文中即可</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\"><br>    src=”<a href=\"http://music.163.com/outchain/player?type=2&amp;id=25706282&amp;auto=0&amp;height=66&quot;&gt;\" target=\"_blank\" rel=\"noopener\">http://music.163.com/outchain/player?type=2&amp;id=25706282&amp;auto=0&amp;height=66&quot;&gt;</a><br></iframe>  \n\n\n<pre><code>\\   反斜线\n`   反引号\n*   星号\n_   底线\n{}  花括号\n[]  方括号\n()  括弧\n#   井字号\n+   加号\n-   减号\n.   英文句点\n!   惊叹号\n</code></pre>"},{"title":"如何选择修饰关键字","date":"2016-11-25T10:54:00.000Z","_content":"\n\n1.代理用nonatomic, weak修饰\nweak:指明该对象并不负责保持delegate这个对象，delegate这个对象的销毁由外部控制，会在dealloc方法中销毁。\n\n    @property (nonatomic, weak) id <LWDelegate> delegate;\n\nstrong：该对象强引用delegate，外界不能销毁delegate对象，会导致循环引用(Retain Cycles)，不会在dealloc方法中销毁，会导致内存泄漏。\n\n    @property (nonatomic, strong) id <LWDelegate> delegate;\n\n<!-- more -->\n2.block块用nonatomic，copy\nblock属性的声明，首先需要用copy修饰符，因为只有copy后的block才会在堆中，栈中的block的生命周期是和栈绑定的，加了copy属性后，当其所在栈被释放的时候，这些本地变量将变得不可访问，一旦代码执行到block这段就会导致bad access。另一个需要注意的问题是关于线程安全，在声明Block属性时需要确认在调用Block时另一个线程有没有可能去修改Block，如果确定不会有这种情况发生的话，那么block属性声明可以用nonatomic。\n\n3.NSString对象一般用nonatomic，copy（因为字符串一般要遵循NSCopying协议）\n我们在声明NSString对象的时候，一般都是不希望外部来对他进行修改的，防止将NSMutableString赋值给NSString时，前者修改引起后者值变化而用的。\n\n    @property (nonatomic, copy) NSString *lwcopyStr;\n    @property (nonatomic, strong) NSString *lwstrongStr;\n    \n    NSMutableString *lwmuStr = [NSMutableString stringWithString:@\"LWW -- MutableString\"];\n\n    self.lwcopyStr = lwmuStr;\n    self.lwstrongStr = lwmuStr;\n    \n    [lwmuStr appendString:@\"---copy\"];\n\n    NSLog(@\"lwmuStr %p lwcopyStr  %p lwstrongStr  %p\", lwmuStr, self.lwcopyStr,  self.lwstrongStr);\n    NSLog(@\"%@   %@\", self.lwcopyStr, self.lwstrongStr);\n\n![结果图.png](http://upload-images.jianshu.io/upload_images/293993-a907c5711c7921ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n**注意**：在这里要用self.属性，不能用下划线属性，因为下划线是直接访问属性，没有经过get方法，看不到效果。\n\n4.BOOL、CGFloat、NSInteger、int等一般用nonatomic，assign\nassign: 简单赋值，不更改索引计数对基础数据类型，例如NSInteger，CGFloat和C数据类型（int, float, double, char等。适用简单数据类型。此标记说明设置器直接进行赋值，这也是默认值。\n\n5.结构体，枚举属性一般用nonatomic，assign\n因为在结构体里面的每个枚举成员均具有相关联的常数值，此值的类型就是包含了它的那个枚举的基础类型。每个枚举成员的常数值必须在该枚举的基础类型的范围之内，故枚举跟上面的简单数据类型一样，都是用assign的，进行简单赋值就行。每个枚举值却的的确确都有一个整数类型的数值相对应，而且可以转换，只不过这种转换必须用明晰的转型语法来表达。\n**注意**：枚举不能被继承\n\n6.一般的属性对象用nonatomic，strong\n**注意**：如果是用XIB或者storyBoard拖的则是用weak，自己手动创建则是用strong。\niOS 5 中对属性的设置新增了strong 和weak关键字来修饰属性\nstrong 用来修饰强引用的属性；\n\n    @property (strong) SomeClass * aObject;\n\n对应原来的\n\n    @property (retain) SomeClass * aObject; \n    @property (copy) SomeClass * aObject;\n\nweak 用来修饰弱引用的属性；\n\n    @property (weak) SomeClass * aObject;\n对应原来的\n\n    @property (assign) SomeClass * aObject;","source":"_posts/Modify-The-KeyWord-Of-iOS.md","raw":"---\ntitle: 如何选择修饰关键字\ndate: 2016-11-25 18:54\ntags: iOS\ncategories: iOS Tips\n---\n\n\n1.代理用nonatomic, weak修饰\nweak:指明该对象并不负责保持delegate这个对象，delegate这个对象的销毁由外部控制，会在dealloc方法中销毁。\n\n    @property (nonatomic, weak) id <LWDelegate> delegate;\n\nstrong：该对象强引用delegate，外界不能销毁delegate对象，会导致循环引用(Retain Cycles)，不会在dealloc方法中销毁，会导致内存泄漏。\n\n    @property (nonatomic, strong) id <LWDelegate> delegate;\n\n<!-- more -->\n2.block块用nonatomic，copy\nblock属性的声明，首先需要用copy修饰符，因为只有copy后的block才会在堆中，栈中的block的生命周期是和栈绑定的，加了copy属性后，当其所在栈被释放的时候，这些本地变量将变得不可访问，一旦代码执行到block这段就会导致bad access。另一个需要注意的问题是关于线程安全，在声明Block属性时需要确认在调用Block时另一个线程有没有可能去修改Block，如果确定不会有这种情况发生的话，那么block属性声明可以用nonatomic。\n\n3.NSString对象一般用nonatomic，copy（因为字符串一般要遵循NSCopying协议）\n我们在声明NSString对象的时候，一般都是不希望外部来对他进行修改的，防止将NSMutableString赋值给NSString时，前者修改引起后者值变化而用的。\n\n    @property (nonatomic, copy) NSString *lwcopyStr;\n    @property (nonatomic, strong) NSString *lwstrongStr;\n    \n    NSMutableString *lwmuStr = [NSMutableString stringWithString:@\"LWW -- MutableString\"];\n\n    self.lwcopyStr = lwmuStr;\n    self.lwstrongStr = lwmuStr;\n    \n    [lwmuStr appendString:@\"---copy\"];\n\n    NSLog(@\"lwmuStr %p lwcopyStr  %p lwstrongStr  %p\", lwmuStr, self.lwcopyStr,  self.lwstrongStr);\n    NSLog(@\"%@   %@\", self.lwcopyStr, self.lwstrongStr);\n\n![结果图.png](http://upload-images.jianshu.io/upload_images/293993-a907c5711c7921ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n**注意**：在这里要用self.属性，不能用下划线属性，因为下划线是直接访问属性，没有经过get方法，看不到效果。\n\n4.BOOL、CGFloat、NSInteger、int等一般用nonatomic，assign\nassign: 简单赋值，不更改索引计数对基础数据类型，例如NSInteger，CGFloat和C数据类型（int, float, double, char等。适用简单数据类型。此标记说明设置器直接进行赋值，这也是默认值。\n\n5.结构体，枚举属性一般用nonatomic，assign\n因为在结构体里面的每个枚举成员均具有相关联的常数值，此值的类型就是包含了它的那个枚举的基础类型。每个枚举成员的常数值必须在该枚举的基础类型的范围之内，故枚举跟上面的简单数据类型一样，都是用assign的，进行简单赋值就行。每个枚举值却的的确确都有一个整数类型的数值相对应，而且可以转换，只不过这种转换必须用明晰的转型语法来表达。\n**注意**：枚举不能被继承\n\n6.一般的属性对象用nonatomic，strong\n**注意**：如果是用XIB或者storyBoard拖的则是用weak，自己手动创建则是用strong。\niOS 5 中对属性的设置新增了strong 和weak关键字来修饰属性\nstrong 用来修饰强引用的属性；\n\n    @property (strong) SomeClass * aObject;\n\n对应原来的\n\n    @property (retain) SomeClass * aObject; \n    @property (copy) SomeClass * aObject;\n\nweak 用来修饰弱引用的属性；\n\n    @property (weak) SomeClass * aObject;\n对应原来的\n\n    @property (assign) SomeClass * aObject;","slug":"Modify-The-KeyWord-Of-iOS","published":1,"updated":"2017-12-05T10:38:33.082Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb1u1v7w000f1us0t1trz0iw","content":"<p>1.代理用nonatomic, weak修饰<br>weak:指明该对象并不负责保持delegate这个对象，delegate这个对象的销毁由外部控制，会在dealloc方法中销毁。</p>\n<pre><code>@property (nonatomic, weak) id &lt;LWDelegate&gt; delegate;\n</code></pre><p>strong：该对象强引用delegate，外界不能销毁delegate对象，会导致循环引用(Retain Cycles)，不会在dealloc方法中销毁，会导致内存泄漏。</p>\n<pre><code>@property (nonatomic, strong) id &lt;LWDelegate&gt; delegate;\n</code></pre><a id=\"more\"></a>\n<p>2.block块用nonatomic，copy<br>block属性的声明，首先需要用copy修饰符，因为只有copy后的block才会在堆中，栈中的block的生命周期是和栈绑定的，加了copy属性后，当其所在栈被释放的时候，这些本地变量将变得不可访问，一旦代码执行到block这段就会导致bad access。另一个需要注意的问题是关于线程安全，在声明Block属性时需要确认在调用Block时另一个线程有没有可能去修改Block，如果确定不会有这种情况发生的话，那么block属性声明可以用nonatomic。</p>\n<p>3.NSString对象一般用nonatomic，copy（因为字符串一般要遵循NSCopying协议）<br>我们在声明NSString对象的时候，一般都是不希望外部来对他进行修改的，防止将NSMutableString赋值给NSString时，前者修改引起后者值变化而用的。</p>\n<pre><code>@property (nonatomic, copy) NSString *lwcopyStr;\n@property (nonatomic, strong) NSString *lwstrongStr;\n\nNSMutableString *lwmuStr = [NSMutableString stringWithString:@&quot;LWW -- MutableString&quot;];\n\nself.lwcopyStr = lwmuStr;\nself.lwstrongStr = lwmuStr;\n\n[lwmuStr appendString:@&quot;---copy&quot;];\n\nNSLog(@&quot;lwmuStr %p lwcopyStr  %p lwstrongStr  %p&quot;, lwmuStr, self.lwcopyStr,  self.lwstrongStr);\nNSLog(@&quot;%@   %@&quot;, self.lwcopyStr, self.lwstrongStr);\n</code></pre><p><img src=\"http://upload-images.jianshu.io/upload_images/293993-a907c5711c7921ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"结果图.png\"><br><strong>注意</strong>：在这里要用self.属性，不能用下划线属性，因为下划线是直接访问属性，没有经过get方法，看不到效果。</p>\n<p>4.BOOL、CGFloat、NSInteger、int等一般用nonatomic，assign<br>assign: 简单赋值，不更改索引计数对基础数据类型，例如NSInteger，CGFloat和C数据类型（int, float, double, char等。适用简单数据类型。此标记说明设置器直接进行赋值，这也是默认值。</p>\n<p>5.结构体，枚举属性一般用nonatomic，assign<br>因为在结构体里面的每个枚举成员均具有相关联的常数值，此值的类型就是包含了它的那个枚举的基础类型。每个枚举成员的常数值必须在该枚举的基础类型的范围之内，故枚举跟上面的简单数据类型一样，都是用assign的，进行简单赋值就行。每个枚举值却的的确确都有一个整数类型的数值相对应，而且可以转换，只不过这种转换必须用明晰的转型语法来表达。<br><strong>注意</strong>：枚举不能被继承</p>\n<p>6.一般的属性对象用nonatomic，strong<br><strong>注意</strong>：如果是用XIB或者storyBoard拖的则是用weak，自己手动创建则是用strong。<br>iOS 5 中对属性的设置新增了strong 和weak关键字来修饰属性<br>strong 用来修饰强引用的属性；</p>\n<pre><code>@property (strong) SomeClass * aObject;\n</code></pre><p>对应原来的</p>\n<pre><code>@property (retain) SomeClass * aObject; \n@property (copy) SomeClass * aObject;\n</code></pre><p>weak 用来修饰弱引用的属性；</p>\n<pre><code>@property (weak) SomeClass * aObject;\n</code></pre><p>对应原来的</p>\n<pre><code>@property (assign) SomeClass * aObject;\n</code></pre>","site":{"data":{}},"excerpt":"<p>1.代理用nonatomic, weak修饰<br>weak:指明该对象并不负责保持delegate这个对象，delegate这个对象的销毁由外部控制，会在dealloc方法中销毁。</p>\n<pre><code>@property (nonatomic, weak) id &lt;LWDelegate&gt; delegate;\n</code></pre><p>strong：该对象强引用delegate，外界不能销毁delegate对象，会导致循环引用(Retain Cycles)，不会在dealloc方法中销毁，会导致内存泄漏。</p>\n<pre><code>@property (nonatomic, strong) id &lt;LWDelegate&gt; delegate;\n</code></pre>","more":"<p>2.block块用nonatomic，copy<br>block属性的声明，首先需要用copy修饰符，因为只有copy后的block才会在堆中，栈中的block的生命周期是和栈绑定的，加了copy属性后，当其所在栈被释放的时候，这些本地变量将变得不可访问，一旦代码执行到block这段就会导致bad access。另一个需要注意的问题是关于线程安全，在声明Block属性时需要确认在调用Block时另一个线程有没有可能去修改Block，如果确定不会有这种情况发生的话，那么block属性声明可以用nonatomic。</p>\n<p>3.NSString对象一般用nonatomic，copy（因为字符串一般要遵循NSCopying协议）<br>我们在声明NSString对象的时候，一般都是不希望外部来对他进行修改的，防止将NSMutableString赋值给NSString时，前者修改引起后者值变化而用的。</p>\n<pre><code>@property (nonatomic, copy) NSString *lwcopyStr;\n@property (nonatomic, strong) NSString *lwstrongStr;\n\nNSMutableString *lwmuStr = [NSMutableString stringWithString:@&quot;LWW -- MutableString&quot;];\n\nself.lwcopyStr = lwmuStr;\nself.lwstrongStr = lwmuStr;\n\n[lwmuStr appendString:@&quot;---copy&quot;];\n\nNSLog(@&quot;lwmuStr %p lwcopyStr  %p lwstrongStr  %p&quot;, lwmuStr, self.lwcopyStr,  self.lwstrongStr);\nNSLog(@&quot;%@   %@&quot;, self.lwcopyStr, self.lwstrongStr);\n</code></pre><p><img src=\"http://upload-images.jianshu.io/upload_images/293993-a907c5711c7921ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"结果图.png\"><br><strong>注意</strong>：在这里要用self.属性，不能用下划线属性，因为下划线是直接访问属性，没有经过get方法，看不到效果。</p>\n<p>4.BOOL、CGFloat、NSInteger、int等一般用nonatomic，assign<br>assign: 简单赋值，不更改索引计数对基础数据类型，例如NSInteger，CGFloat和C数据类型（int, float, double, char等。适用简单数据类型。此标记说明设置器直接进行赋值，这也是默认值。</p>\n<p>5.结构体，枚举属性一般用nonatomic，assign<br>因为在结构体里面的每个枚举成员均具有相关联的常数值，此值的类型就是包含了它的那个枚举的基础类型。每个枚举成员的常数值必须在该枚举的基础类型的范围之内，故枚举跟上面的简单数据类型一样，都是用assign的，进行简单赋值就行。每个枚举值却的的确确都有一个整数类型的数值相对应，而且可以转换，只不过这种转换必须用明晰的转型语法来表达。<br><strong>注意</strong>：枚举不能被继承</p>\n<p>6.一般的属性对象用nonatomic，strong<br><strong>注意</strong>：如果是用XIB或者storyBoard拖的则是用weak，自己手动创建则是用strong。<br>iOS 5 中对属性的设置新增了strong 和weak关键字来修饰属性<br>strong 用来修饰强引用的属性；</p>\n<pre><code>@property (strong) SomeClass * aObject;\n</code></pre><p>对应原来的</p>\n<pre><code>@property (retain) SomeClass * aObject; \n@property (copy) SomeClass * aObject;\n</code></pre><p>weak 用来修饰弱引用的属性；</p>\n<pre><code>@property (weak) SomeClass * aObject;\n</code></pre><p>对应原来的</p>\n<pre><code>@property (assign) SomeClass * aObject;\n</code></pre>"},{"title":"苦逼的改了一天","date":"2016-11-20T04:34:00.000Z","_content":"\n<center>谨记自己学习Hexo博客第一天。。。\n\n哈哈哈哈哈-----\n\n卧草  好麻烦啊\n\n啊啊啊啊啊啊\n\n卧草  这头像咋这么麻烦  为啥就是不能显示头像  卧草\n\n删了重新来   删了重新来   删了重新来   好了   \n\n啊哈哈哈哈  终于搞好了！</center>","source":"_posts/MyFirst-Hexo.md","raw":"---\ntitle: 苦逼的改了一天\ndate: 2016-11-20 12:34\ntags: 开开心心每一天！feel小记录\ncategories: Hexo\n---\n\n<center>谨记自己学习Hexo博客第一天。。。\n\n哈哈哈哈哈-----\n\n卧草  好麻烦啊\n\n啊啊啊啊啊啊\n\n卧草  这头像咋这么麻烦  为啥就是不能显示头像  卧草\n\n删了重新来   删了重新来   删了重新来   好了   \n\n啊哈哈哈哈  终于搞好了！</center>","slug":"MyFirst-Hexo","published":1,"updated":"2017-12-05T10:38:50.247Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb1u1v7z000k1us035vh3hqp","content":"<center>谨记自己学习Hexo博客第一天。。。<br><br>哈哈哈哈哈—–<br><br>卧草  好麻烦啊<br><br>啊啊啊啊啊啊<br><br>卧草  这头像咋这么麻烦  为啥就是不能显示头像  卧草<br><br>删了重新来   删了重新来   删了重新来   好了<br><br>啊哈哈哈哈  终于搞好了！</center>","site":{"data":{}},"excerpt":"","more":"<center>谨记自己学习Hexo博客第一天。。。<br><br>哈哈哈哈哈—–<br><br>卧草  好麻烦啊<br><br>啊啊啊啊啊啊<br><br>卧草  这头像咋这么麻烦  为啥就是不能显示头像  卧草<br><br>删了重新来   删了重新来   删了重新来   好了<br><br>啊哈哈哈哈  终于搞好了！</center>"},{"title":"NSOperation简介","date":"2017-12-08T06:38:35.000Z","_content":"\n#### 1 NSOperation简介\n\nNSOperation是苹果提供给我们的一套多线程解决方案。实际上NSOperation是基于GCD更高一层的封装，但是比GCD更简单易用、代码可读性也更高。\n\nNSOperation需要配合NSOperationQueue来实现多线程。**因为默认情况下，NSOperation单独使用时系统同步执行操作，并没有开辟新线程的能力，只有配合NSOperationQueue才能实现异步执行。**\n\n因为NSOperation是基于GCD的，那么使用起来也和GCD差不多，其中，NSOperation相当于GCD中的任务，而NSOperationQueue则相当于GCD中的队列。NSOperation实现多线程的使用步骤分为三步：\n\n- 1 创建任务：先将需要执行的操作封装到一个NSOperation对象中。\n\n- 2 创建队列：创建NSOperationQueue对象。\n\n- 3 将任务加入到队列中：然后将NSOperation对象添加到NSOperationQueue中。\n\n之后呢，系统就会自动将NSOperationQueue中的NSOperation取出来，在新线程中执行操作。\n\n下面我们来学习下NSOperation和NSOperationQueue的基本使用。\n\n<!-- more -->\n\n#### 2 NSOperation和NSOperationQueue的基本使用\n\n##### 2.1 创建任务\n\nNSOperation是个抽象类，并不能封装任务。我们只有使用它的子类来封装任务。我们有三种方式来封装任务。\n\n- 1 使用子类NSInvocationOperation\n- 2 使用子类NSBlockOperation\n- 3 定义继承自NSOperation的子类，通过实现内部相应的方法来封装任务。\n\n在不使用NSOperationQueue，单独使用NSOperation的情况下系统同步执行操作，下面我们学习以下任务的三种创建方式。\n\n###### 2.1.1 使用子类`- NSInvocationOperation:`\n\n```objective-c\n// 1.创建NSInvocationOperation对象\nNSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];\n\n// 2.调用start方法开始执行操作\n[op start];\n\n- (void)run\n{\n    NSLog(@\"------%@\", [NSThread currentThread]);\n}\n```\n\n```objective-c\n输出结果：\nNSOperation[15834:2384555] ------<NSThread: 0x7fa3e2e05410>{number = 1, name = main}\n```\n\n从中可以看到，在没有使用NSOperationQueue、单独使用NSInvocationOperation的情况下，NSInvocationOperation在主线程执行操作，并没有开启新线程。\n\n###### 2.1.2 使用子类`- NSBlockOperation`\n\n```objective-c\nNSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^{\n    // 在主线程\n    NSLog(@\"------%@\", [NSThread currentThread]);\n}];\n\n[op start];\n```\n\n```objective-c\n输出结果：\nNSOperation[15884:2387780] ------<NSThread: 0x7fb2196012c0>{number = 1, name = main}\n```\n\n我们同样可以看到，在没有使用NSOperationQueue、单独使用NSBlockOperation的情况下，NSBlockOperation也是在主线程执行操作，并没有开启新线程。\n\n**但是，NSBlockOperation还提供了一个方法`addExecutionBlock:`，通过`addExecutionBlock:`就可以为NSBlockOperation添加额外的操作，这些额外的操作就会在其他线程并发执行。**\n\n```objective-c\n- (void)blockOperation\n{\n    NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^{\n        // 在主线程\n        NSLog(@\"1------%@\", [NSThread currentThread]);\n    }];    \n\n    // 添加额外的任务(在子线程执行)\n    [op addExecutionBlock:^{\n        NSLog(@\"2------%@\", [NSThread currentThread]);\n    }];\n    [op addExecutionBlock:^{\n        NSLog(@\"3------%@\", [NSThread currentThread]);\n    }];\n    [op addExecutionBlock:^{\n        NSLog(@\"4------%@\", [NSThread currentThread]);\n    }];\n\n    [op start];\n}\n```\n\n```objective-c\n输出结果：\nNSOperation[15896:2390616] 1------<NSThread: 0x7ff633f03be0>{number = 1, name = main}\nNSOperation[15896:2390825] 2------<NSThread: 0x7ff633e24600>{number = 2, name = (null)}\nNSOperation[15896:2390657] 3------<NSThread: 0x7ff633c411e0>{number = 3, name = (null)}\nNSOperation[15896:2390656] 4------<NSThread: 0x7ff633f1d3e0>{number = 4, name = (null)}\n```\n\n可以看出，`blockOperationWithBlock:`方法中的操作是在主线程中执行的，而`addExecutionBlock:`方法中的操作是在其他线程中执行的。\n\n###### 2.1.3 定义继承自NSOperation的子类\n\nh文件\n\n```objective-c\n#import <Foundation/Foundation.h>\n@interface LQOperation : NSOperation\n\n@end\n```\n\nm文件\n\n```objective-c\n#import \"LQOperation.h\"\n\n@implementation LQOperation\n/**\n * 需要执行的任务\n */\n- (void)main\n{\n    for (int i = 0; i < 2; ++i) {\n        NSLog(@\"1-----%@\",[NSThread currentThread]);\n    }    \n}\n@end\n```\n\n然后使用的时候导入头文件`LQOperation.h`。\n\n```objective-c\n// 创建YSCOperation\nLQOperation *op = [[LQOperation alloc] init];\n[op start];\n```\n\n```objective-c\n输出结果：\nNSOperation[16566:2501606] 1-----<NSThread: 0x7f8030d05150>{number = 1, name = main}\nNSOperation[16566:2501606] 1-----<NSThread: 0x7f8030d05150>{number = 1, name = main}\n```\n\n可以看出：在没有使用NSOperationQueue、单独使用自定义子类的情况下，是在主线程执行操作，并没有开启新线程。\n\n##### 2.2 创建队列\n\n和GCD中的并发队列、串行队列略有不同的是：`NSOperationQueue`一共有两种队列：主队列、其他队列。其中其他队列同时包含了串行、并发功能。下边是主队列、其他队列的基本创建方法和特点\n\n- 主队列\n\n  - 凡是添加到主队列中的任务（NSOperation），都会放到主线程中执行\n\n    ```objective-c\n    NSOperationQueue *queue = [NSOperationQueue mainQueue];\n    ```\n\n- 其他队列（非主队列）\n\n  - 添加到这种队列中的任务（NSOperation），就会自动放到子线程中执行\n\n  - 同时包含了：串行、并发功能\n\n    ```objective-c\n    NSOperationQueue *queue = [[NSOperationQueue alloc] init];\n    ```\n\n##### 2.3 将任务加入到队列中\n\n前边说了，NSOperation需要配合NSOperationQueue来实现多线程。\n那么我们需要将创建好的任务加入到队列中去。总共有两种方法\n\n###### 2.3.1 ``-(void)addOperation:(NSOperation *)op;``\n\n- 需要先创建任务，再将创建好的任务加入到创建好的队列中去\n\n  ```objective-c\n  - (void)addOperationToQueue\n  {\n      // 1.创建队列\n      NSOperationQueue *queue = [[NSOperationQueue alloc] init];\n\n      // 2. 创建操作  \n      // 创建NSInvocationOperation    \n      NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];    \n      // 创建NSBlockOperation    \n      NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^{\n          for (int i = 0; i < 2; ++i) {\n              NSLog(@\"1-----%@\", [NSThread currentThread]);\n          }\n      }];\n\n      // 3. 添加操作到队列中：addOperation:   \n      [queue addOperation:op1]; // [op1 start]    \n      [queue addOperation:op2]; // [op2 start]\n  }\n\n  - (void)run\n  {\n      for (int i = 0; i < 2; ++i) {\n          NSLog(@\"2-----%@\", [NSThread currentThread]);\n      }\n  }\n  ```\n\n  ```objective-c\n  输出结果：\n  NSOperationQueue[16201:2452281] 1-----<NSThread: 0x7fe4824080e0>{number = 3, name = (null)}\n  NSOperationQueue[16201:2452175] 2-----<NSThread: 0x7fe482404a50>{number = 2, name = (null)}\n  NSOperationQueue[16201:2452175] 2-----<NSThread: 0x7fe482404a50>{number = 2, name = (null)}\n  NSOperationQueue[16201:2452281] 1-----<NSThread: 0x7fe4824080e0>{number = 3, name = (null)}\n  ```\n\n  可以看出：NSInvocationOperation和NSOperationQueue结合后能够开启新线程，进行并发执行，NSBlockOperation和NSOperationQueue也能够开启新线程，进行并发执行。\n\n###### 2.3.2 ``- (void)addOperationWithBlock:(void (^)(void))block;``\n\n- 无需先创建任务，在block中添加任务，直接将任务block加入到队列中。\n\n  ```objective-c\n  - (void)addOperationWithBlockToQueue\n  {\n      // 1. 创建队列\n      NSOperationQueue *queue = [[NSOperationQueue alloc] init];\n\n      // 2. 添加操作到队列中：addOperationWithBlock:\n      [queue addOperationWithBlock:^{\n          for (int i = 0; i < 2; ++i) {\n              NSLog(@\"-----%@\", [NSThread currentThread]);\n          }\n      }];\n  }\n  ```\n\n  ```objective-c\n  输出结果：\n  NSOperationQueue[16293:2457487] -----<NSThread: 0x7ffa6bc0e1e0>{number = 2, name = (null)}\n  NSOperationQueue[16293:2457487] -----<NSThread: 0x7ffa6bc0e1e0>{number = 2, name = (null)}\n  ```\n\n  可以看出addOperationWithBlock:和NSOperationQueue能够开启新线程，进行并发执行。\n\n#### 3 控制串行执行和并行执行的关键\n\n之前我们说过，NSOperationQueue创建的其他队列同时具有串行、并发功能，上边我们演示了并发功能，那么他的串行功能是如何实现的？\n\n这里有个关键参数`maxConcurrentOperationCount`，叫做**最大并发数**。\n\n- 最大并发数：`maxConcurrentOperationCount`\n\n  - `maxConcurrentOperationCount`默认情况下为-1，表示不进行限制，默认为并发执行。\n  - 当`maxConcurrentOperationCount`为1时，进行串行执行。\n  - 当`maxConcurrentOperationCount`大于1时，进行并发执行，当然这个值不应超过系统限制，即使自己设置一个很大的值，系统也会自动调整。\n\n  ```objective-c\n  - (void)opetationQueue\n  {\n      // 创建队列\n      NSOperationQueue *queue = [[NSOperationQueue alloc] init];\n\n      // 设置最大并发操作数\n      //    queue.maxConcurrentOperationCount = 2;\n      queue.maxConcurrentOperationCount = 1; // 就变成了串行队列\n\n      // 添加操作\n      [queue addOperationWithBlock:^{\n          NSLog(@\"1-----%@\", [NSThread currentThread]);\n          [NSThread sleepForTimeInterval:0.01];\n      }];\n      [queue addOperationWithBlock:^{\n          NSLog(@\"2-----%@\", [NSThread currentThread]);\n          [NSThread sleepForTimeInterval:0.01];\n      }];\n      [queue addOperationWithBlock:^{\n          NSLog(@\"3-----%@\", [NSThread currentThread]);\n          [NSThread sleepForTimeInterval:0.01];\n      }];\n      [queue addOperationWithBlock:^{\n          NSLog(@\"4-----%@\", [NSThread currentThread]);\n          [NSThread sleepForTimeInterval:0.01];\n      }];\n      [queue addOperationWithBlock:^{\n          NSLog(@\"5-----%@\", [NSThread currentThread]);\n          [NSThread sleepForTimeInterval:0.01];\n      }];\n\n      [queue addOperationWithBlock:^{\n          NSLog(@\"6-----%@\", [NSThread currentThread]);\n          [NSThread sleepForTimeInterval:0.01];\n      }];\n  }\n  ```\n\n  ```objective-c\n  最大并发数为1输出结果：\n  NSOperationQueue[16320:2464630] 1-----<NSThread: 0x7fc892d0b3a0>{number = 2, name = (null)}\n  NSOperationQueue[16320:2464631] 2-----<NSThread: 0x7fc892c0a7b0>{number = 3, name = (null)}\n  NSOperationQueue[16320:2464630] 3-----<NSThread: 0x7fc892d0b3a0>{number = 2, name = (null)}\n  NSOperationQueue[16320:2464631] 4-----<NSThread: 0x7fc892c0a7b0>{number = 3, name = (null)}\n  NSOperationQueue[16320:2464631] 5-----<NSThread: 0x7fc892c0a7b0>{number = 3, name = (null)}\n  NSOperationQueue[16320:2464630] 6-----<NSThread: 0x7fc892d0b3a0>{number = 2, name = (null)}\n  ```\n\n  ```objective-c\n  最大并发数为2输出结果：\n  NSOperationQueue[16331:2466366] 2-----<NSThread: 0x7fd729f0f270>{number = 3, name = (null)}\n  NSOperationQueue[16331:2466491] 1-----<NSThread: 0x7fd729f4e290>{number = 2, name = (null)}\n  NSOperationQueue[16331:2466367] 3-----<NSThread: 0x7fd729d214e0>{number = 4, name = (null)}\n  NSOperationQueue[16331:2466366] 4-----<NSThread: 0x7fd729f0f270>{number = 3, name = (null)}\n  NSOperationQueue[16331:2466366] 6-----<NSThread: 0x7fd729f0f270>{number = 3, name = (null)}\n  NSOperationQueue[16331:2466511] 5-----<NSThread: 0x7fd729e056c0>{number = 5, name = (null)}\n  ```\n\n  可以看出：当最大并发数为1时，任务是按顺序串行执行的。当最大并发数为2时，任务是并发执行的。而且开启线程数量是由系统决定的，不需要我们来管理。这样看来，是不是比GCD还要简单了许多？\n\n#### 4 操作依赖\n\nNSOperation和NSOperationQueue最吸引人的地方是它能添加操作之间的依赖关系。比如说有A、B两个操作，其中A执行完操作，B才能执行操作，那么就需要让B依赖于A。具体如下：\n\n```objective-c\n- (void)addDependency\n{\n    NSOperationQueue *queue = [[NSOperationQueue alloc] init];\n\n    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"1-----%@\", [NSThread  currentThread]);\n    }];\n    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"2-----%@\", [NSThread  currentThread]);\n    }];\n\n    [op1 addDependency:op2];    // 让op1 依赖于 op2，则先执行op2，再执行op1\n\n    [queue addOperation:op1];\n    [queue addOperation:op2];\n}\n```\n\n```objective-c\n输出结果：\n操作依赖[16423:2484866] 2-----<NSThread: 0x7fc138e1e7c0>{number = 2, name = (null)}\n操作依赖[16423:2484866] 1-----<NSThread: 0x7fc138e1e7c0>{number = 2, name = (null)}\n```\n\n可以看到，无论运行几次，其结果都是op2先执行，op1后执行。\n\n#### 5 一些其他方法\n\n- `- (void)cancel;` NSOperation提供的方法，可取消单个操作\n- `- (void)cancelAllOperations;` NSOperationQueue提供的方法，可以取消队列的所有操作\n- `- (void)setSuspended:(BOOL)b;` 可设置任务的暂停和恢复，YES代表暂停队列，NO代表恢复队列\n- `- (BOOL)isSuspended;` 判断暂停状态\n\n**注意：**\n\n- 这里的暂停和取消并不代表可以将当前的操作立即取消，而是当当前的操作执行完毕之后不再执行新的操作。\n\n- 暂停和取消的区别就在于：暂停操作之后还可以恢复操作，继续向下执行；而取消操作之后，所有的操作就清空了，无法再接着执行剩下的操作。\n\n  ​\n\n转载自[iOS多线程--彻底学会多线程](http://www.jianshu.com/p/4b1d77054b35)","source":"_posts/NSOperation简介.md","raw":"---\ntitle: NSOperation简介\ndate: 2017-12-08 14:38:35\ntags: iOS\ncategories: iOS Tips\n---\n\n#### 1 NSOperation简介\n\nNSOperation是苹果提供给我们的一套多线程解决方案。实际上NSOperation是基于GCD更高一层的封装，但是比GCD更简单易用、代码可读性也更高。\n\nNSOperation需要配合NSOperationQueue来实现多线程。**因为默认情况下，NSOperation单独使用时系统同步执行操作，并没有开辟新线程的能力，只有配合NSOperationQueue才能实现异步执行。**\n\n因为NSOperation是基于GCD的，那么使用起来也和GCD差不多，其中，NSOperation相当于GCD中的任务，而NSOperationQueue则相当于GCD中的队列。NSOperation实现多线程的使用步骤分为三步：\n\n- 1 创建任务：先将需要执行的操作封装到一个NSOperation对象中。\n\n- 2 创建队列：创建NSOperationQueue对象。\n\n- 3 将任务加入到队列中：然后将NSOperation对象添加到NSOperationQueue中。\n\n之后呢，系统就会自动将NSOperationQueue中的NSOperation取出来，在新线程中执行操作。\n\n下面我们来学习下NSOperation和NSOperationQueue的基本使用。\n\n<!-- more -->\n\n#### 2 NSOperation和NSOperationQueue的基本使用\n\n##### 2.1 创建任务\n\nNSOperation是个抽象类，并不能封装任务。我们只有使用它的子类来封装任务。我们有三种方式来封装任务。\n\n- 1 使用子类NSInvocationOperation\n- 2 使用子类NSBlockOperation\n- 3 定义继承自NSOperation的子类，通过实现内部相应的方法来封装任务。\n\n在不使用NSOperationQueue，单独使用NSOperation的情况下系统同步执行操作，下面我们学习以下任务的三种创建方式。\n\n###### 2.1.1 使用子类`- NSInvocationOperation:`\n\n```objective-c\n// 1.创建NSInvocationOperation对象\nNSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];\n\n// 2.调用start方法开始执行操作\n[op start];\n\n- (void)run\n{\n    NSLog(@\"------%@\", [NSThread currentThread]);\n}\n```\n\n```objective-c\n输出结果：\nNSOperation[15834:2384555] ------<NSThread: 0x7fa3e2e05410>{number = 1, name = main}\n```\n\n从中可以看到，在没有使用NSOperationQueue、单独使用NSInvocationOperation的情况下，NSInvocationOperation在主线程执行操作，并没有开启新线程。\n\n###### 2.1.2 使用子类`- NSBlockOperation`\n\n```objective-c\nNSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^{\n    // 在主线程\n    NSLog(@\"------%@\", [NSThread currentThread]);\n}];\n\n[op start];\n```\n\n```objective-c\n输出结果：\nNSOperation[15884:2387780] ------<NSThread: 0x7fb2196012c0>{number = 1, name = main}\n```\n\n我们同样可以看到，在没有使用NSOperationQueue、单独使用NSBlockOperation的情况下，NSBlockOperation也是在主线程执行操作，并没有开启新线程。\n\n**但是，NSBlockOperation还提供了一个方法`addExecutionBlock:`，通过`addExecutionBlock:`就可以为NSBlockOperation添加额外的操作，这些额外的操作就会在其他线程并发执行。**\n\n```objective-c\n- (void)blockOperation\n{\n    NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^{\n        // 在主线程\n        NSLog(@\"1------%@\", [NSThread currentThread]);\n    }];    \n\n    // 添加额外的任务(在子线程执行)\n    [op addExecutionBlock:^{\n        NSLog(@\"2------%@\", [NSThread currentThread]);\n    }];\n    [op addExecutionBlock:^{\n        NSLog(@\"3------%@\", [NSThread currentThread]);\n    }];\n    [op addExecutionBlock:^{\n        NSLog(@\"4------%@\", [NSThread currentThread]);\n    }];\n\n    [op start];\n}\n```\n\n```objective-c\n输出结果：\nNSOperation[15896:2390616] 1------<NSThread: 0x7ff633f03be0>{number = 1, name = main}\nNSOperation[15896:2390825] 2------<NSThread: 0x7ff633e24600>{number = 2, name = (null)}\nNSOperation[15896:2390657] 3------<NSThread: 0x7ff633c411e0>{number = 3, name = (null)}\nNSOperation[15896:2390656] 4------<NSThread: 0x7ff633f1d3e0>{number = 4, name = (null)}\n```\n\n可以看出，`blockOperationWithBlock:`方法中的操作是在主线程中执行的，而`addExecutionBlock:`方法中的操作是在其他线程中执行的。\n\n###### 2.1.3 定义继承自NSOperation的子类\n\nh文件\n\n```objective-c\n#import <Foundation/Foundation.h>\n@interface LQOperation : NSOperation\n\n@end\n```\n\nm文件\n\n```objective-c\n#import \"LQOperation.h\"\n\n@implementation LQOperation\n/**\n * 需要执行的任务\n */\n- (void)main\n{\n    for (int i = 0; i < 2; ++i) {\n        NSLog(@\"1-----%@\",[NSThread currentThread]);\n    }    \n}\n@end\n```\n\n然后使用的时候导入头文件`LQOperation.h`。\n\n```objective-c\n// 创建YSCOperation\nLQOperation *op = [[LQOperation alloc] init];\n[op start];\n```\n\n```objective-c\n输出结果：\nNSOperation[16566:2501606] 1-----<NSThread: 0x7f8030d05150>{number = 1, name = main}\nNSOperation[16566:2501606] 1-----<NSThread: 0x7f8030d05150>{number = 1, name = main}\n```\n\n可以看出：在没有使用NSOperationQueue、单独使用自定义子类的情况下，是在主线程执行操作，并没有开启新线程。\n\n##### 2.2 创建队列\n\n和GCD中的并发队列、串行队列略有不同的是：`NSOperationQueue`一共有两种队列：主队列、其他队列。其中其他队列同时包含了串行、并发功能。下边是主队列、其他队列的基本创建方法和特点\n\n- 主队列\n\n  - 凡是添加到主队列中的任务（NSOperation），都会放到主线程中执行\n\n    ```objective-c\n    NSOperationQueue *queue = [NSOperationQueue mainQueue];\n    ```\n\n- 其他队列（非主队列）\n\n  - 添加到这种队列中的任务（NSOperation），就会自动放到子线程中执行\n\n  - 同时包含了：串行、并发功能\n\n    ```objective-c\n    NSOperationQueue *queue = [[NSOperationQueue alloc] init];\n    ```\n\n##### 2.3 将任务加入到队列中\n\n前边说了，NSOperation需要配合NSOperationQueue来实现多线程。\n那么我们需要将创建好的任务加入到队列中去。总共有两种方法\n\n###### 2.3.1 ``-(void)addOperation:(NSOperation *)op;``\n\n- 需要先创建任务，再将创建好的任务加入到创建好的队列中去\n\n  ```objective-c\n  - (void)addOperationToQueue\n  {\n      // 1.创建队列\n      NSOperationQueue *queue = [[NSOperationQueue alloc] init];\n\n      // 2. 创建操作  \n      // 创建NSInvocationOperation    \n      NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];    \n      // 创建NSBlockOperation    \n      NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^{\n          for (int i = 0; i < 2; ++i) {\n              NSLog(@\"1-----%@\", [NSThread currentThread]);\n          }\n      }];\n\n      // 3. 添加操作到队列中：addOperation:   \n      [queue addOperation:op1]; // [op1 start]    \n      [queue addOperation:op2]; // [op2 start]\n  }\n\n  - (void)run\n  {\n      for (int i = 0; i < 2; ++i) {\n          NSLog(@\"2-----%@\", [NSThread currentThread]);\n      }\n  }\n  ```\n\n  ```objective-c\n  输出结果：\n  NSOperationQueue[16201:2452281] 1-----<NSThread: 0x7fe4824080e0>{number = 3, name = (null)}\n  NSOperationQueue[16201:2452175] 2-----<NSThread: 0x7fe482404a50>{number = 2, name = (null)}\n  NSOperationQueue[16201:2452175] 2-----<NSThread: 0x7fe482404a50>{number = 2, name = (null)}\n  NSOperationQueue[16201:2452281] 1-----<NSThread: 0x7fe4824080e0>{number = 3, name = (null)}\n  ```\n\n  可以看出：NSInvocationOperation和NSOperationQueue结合后能够开启新线程，进行并发执行，NSBlockOperation和NSOperationQueue也能够开启新线程，进行并发执行。\n\n###### 2.3.2 ``- (void)addOperationWithBlock:(void (^)(void))block;``\n\n- 无需先创建任务，在block中添加任务，直接将任务block加入到队列中。\n\n  ```objective-c\n  - (void)addOperationWithBlockToQueue\n  {\n      // 1. 创建队列\n      NSOperationQueue *queue = [[NSOperationQueue alloc] init];\n\n      // 2. 添加操作到队列中：addOperationWithBlock:\n      [queue addOperationWithBlock:^{\n          for (int i = 0; i < 2; ++i) {\n              NSLog(@\"-----%@\", [NSThread currentThread]);\n          }\n      }];\n  }\n  ```\n\n  ```objective-c\n  输出结果：\n  NSOperationQueue[16293:2457487] -----<NSThread: 0x7ffa6bc0e1e0>{number = 2, name = (null)}\n  NSOperationQueue[16293:2457487] -----<NSThread: 0x7ffa6bc0e1e0>{number = 2, name = (null)}\n  ```\n\n  可以看出addOperationWithBlock:和NSOperationQueue能够开启新线程，进行并发执行。\n\n#### 3 控制串行执行和并行执行的关键\n\n之前我们说过，NSOperationQueue创建的其他队列同时具有串行、并发功能，上边我们演示了并发功能，那么他的串行功能是如何实现的？\n\n这里有个关键参数`maxConcurrentOperationCount`，叫做**最大并发数**。\n\n- 最大并发数：`maxConcurrentOperationCount`\n\n  - `maxConcurrentOperationCount`默认情况下为-1，表示不进行限制，默认为并发执行。\n  - 当`maxConcurrentOperationCount`为1时，进行串行执行。\n  - 当`maxConcurrentOperationCount`大于1时，进行并发执行，当然这个值不应超过系统限制，即使自己设置一个很大的值，系统也会自动调整。\n\n  ```objective-c\n  - (void)opetationQueue\n  {\n      // 创建队列\n      NSOperationQueue *queue = [[NSOperationQueue alloc] init];\n\n      // 设置最大并发操作数\n      //    queue.maxConcurrentOperationCount = 2;\n      queue.maxConcurrentOperationCount = 1; // 就变成了串行队列\n\n      // 添加操作\n      [queue addOperationWithBlock:^{\n          NSLog(@\"1-----%@\", [NSThread currentThread]);\n          [NSThread sleepForTimeInterval:0.01];\n      }];\n      [queue addOperationWithBlock:^{\n          NSLog(@\"2-----%@\", [NSThread currentThread]);\n          [NSThread sleepForTimeInterval:0.01];\n      }];\n      [queue addOperationWithBlock:^{\n          NSLog(@\"3-----%@\", [NSThread currentThread]);\n          [NSThread sleepForTimeInterval:0.01];\n      }];\n      [queue addOperationWithBlock:^{\n          NSLog(@\"4-----%@\", [NSThread currentThread]);\n          [NSThread sleepForTimeInterval:0.01];\n      }];\n      [queue addOperationWithBlock:^{\n          NSLog(@\"5-----%@\", [NSThread currentThread]);\n          [NSThread sleepForTimeInterval:0.01];\n      }];\n\n      [queue addOperationWithBlock:^{\n          NSLog(@\"6-----%@\", [NSThread currentThread]);\n          [NSThread sleepForTimeInterval:0.01];\n      }];\n  }\n  ```\n\n  ```objective-c\n  最大并发数为1输出结果：\n  NSOperationQueue[16320:2464630] 1-----<NSThread: 0x7fc892d0b3a0>{number = 2, name = (null)}\n  NSOperationQueue[16320:2464631] 2-----<NSThread: 0x7fc892c0a7b0>{number = 3, name = (null)}\n  NSOperationQueue[16320:2464630] 3-----<NSThread: 0x7fc892d0b3a0>{number = 2, name = (null)}\n  NSOperationQueue[16320:2464631] 4-----<NSThread: 0x7fc892c0a7b0>{number = 3, name = (null)}\n  NSOperationQueue[16320:2464631] 5-----<NSThread: 0x7fc892c0a7b0>{number = 3, name = (null)}\n  NSOperationQueue[16320:2464630] 6-----<NSThread: 0x7fc892d0b3a0>{number = 2, name = (null)}\n  ```\n\n  ```objective-c\n  最大并发数为2输出结果：\n  NSOperationQueue[16331:2466366] 2-----<NSThread: 0x7fd729f0f270>{number = 3, name = (null)}\n  NSOperationQueue[16331:2466491] 1-----<NSThread: 0x7fd729f4e290>{number = 2, name = (null)}\n  NSOperationQueue[16331:2466367] 3-----<NSThread: 0x7fd729d214e0>{number = 4, name = (null)}\n  NSOperationQueue[16331:2466366] 4-----<NSThread: 0x7fd729f0f270>{number = 3, name = (null)}\n  NSOperationQueue[16331:2466366] 6-----<NSThread: 0x7fd729f0f270>{number = 3, name = (null)}\n  NSOperationQueue[16331:2466511] 5-----<NSThread: 0x7fd729e056c0>{number = 5, name = (null)}\n  ```\n\n  可以看出：当最大并发数为1时，任务是按顺序串行执行的。当最大并发数为2时，任务是并发执行的。而且开启线程数量是由系统决定的，不需要我们来管理。这样看来，是不是比GCD还要简单了许多？\n\n#### 4 操作依赖\n\nNSOperation和NSOperationQueue最吸引人的地方是它能添加操作之间的依赖关系。比如说有A、B两个操作，其中A执行完操作，B才能执行操作，那么就需要让B依赖于A。具体如下：\n\n```objective-c\n- (void)addDependency\n{\n    NSOperationQueue *queue = [[NSOperationQueue alloc] init];\n\n    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"1-----%@\", [NSThread  currentThread]);\n    }];\n    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^{\n        NSLog(@\"2-----%@\", [NSThread  currentThread]);\n    }];\n\n    [op1 addDependency:op2];    // 让op1 依赖于 op2，则先执行op2，再执行op1\n\n    [queue addOperation:op1];\n    [queue addOperation:op2];\n}\n```\n\n```objective-c\n输出结果：\n操作依赖[16423:2484866] 2-----<NSThread: 0x7fc138e1e7c0>{number = 2, name = (null)}\n操作依赖[16423:2484866] 1-----<NSThread: 0x7fc138e1e7c0>{number = 2, name = (null)}\n```\n\n可以看到，无论运行几次，其结果都是op2先执行，op1后执行。\n\n#### 5 一些其他方法\n\n- `- (void)cancel;` NSOperation提供的方法，可取消单个操作\n- `- (void)cancelAllOperations;` NSOperationQueue提供的方法，可以取消队列的所有操作\n- `- (void)setSuspended:(BOOL)b;` 可设置任务的暂停和恢复，YES代表暂停队列，NO代表恢复队列\n- `- (BOOL)isSuspended;` 判断暂停状态\n\n**注意：**\n\n- 这里的暂停和取消并不代表可以将当前的操作立即取消，而是当当前的操作执行完毕之后不再执行新的操作。\n\n- 暂停和取消的区别就在于：暂停操作之后还可以恢复操作，继续向下执行；而取消操作之后，所有的操作就清空了，无法再接着执行剩下的操作。\n\n  ​\n\n转载自[iOS多线程--彻底学会多线程](http://www.jianshu.com/p/4b1d77054b35)","slug":"NSOperation简介","published":1,"updated":"2017-12-08T09:03:43.434Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb1u1v81000n1us07hwg5sp6","content":"<h4 id=\"1-NSOperation简介\"><a href=\"#1-NSOperation简介\" class=\"headerlink\" title=\"1 NSOperation简介\"></a>1 NSOperation简介</h4><p>NSOperation是苹果提供给我们的一套多线程解决方案。实际上NSOperation是基于GCD更高一层的封装，但是比GCD更简单易用、代码可读性也更高。</p>\n<p>NSOperation需要配合NSOperationQueue来实现多线程。<strong>因为默认情况下，NSOperation单独使用时系统同步执行操作，并没有开辟新线程的能力，只有配合NSOperationQueue才能实现异步执行。</strong></p>\n<p>因为NSOperation是基于GCD的，那么使用起来也和GCD差不多，其中，NSOperation相当于GCD中的任务，而NSOperationQueue则相当于GCD中的队列。NSOperation实现多线程的使用步骤分为三步：</p>\n<ul>\n<li><p>1 创建任务：先将需要执行的操作封装到一个NSOperation对象中。</p>\n</li>\n<li><p>2 创建队列：创建NSOperationQueue对象。</p>\n</li>\n<li><p>3 将任务加入到队列中：然后将NSOperation对象添加到NSOperationQueue中。</p>\n</li>\n</ul>\n<p>之后呢，系统就会自动将NSOperationQueue中的NSOperation取出来，在新线程中执行操作。</p>\n<p>下面我们来学习下NSOperation和NSOperationQueue的基本使用。</p>\n<a id=\"more\"></a>\n<h4 id=\"2-NSOperation和NSOperationQueue的基本使用\"><a href=\"#2-NSOperation和NSOperationQueue的基本使用\" class=\"headerlink\" title=\"2 NSOperation和NSOperationQueue的基本使用\"></a>2 NSOperation和NSOperationQueue的基本使用</h4><h5 id=\"2-1-创建任务\"><a href=\"#2-1-创建任务\" class=\"headerlink\" title=\"2.1 创建任务\"></a>2.1 创建任务</h5><p>NSOperation是个抽象类，并不能封装任务。我们只有使用它的子类来封装任务。我们有三种方式来封装任务。</p>\n<ul>\n<li>1 使用子类NSInvocationOperation</li>\n<li>2 使用子类NSBlockOperation</li>\n<li>3 定义继承自NSOperation的子类，通过实现内部相应的方法来封装任务。</li>\n</ul>\n<p>在不使用NSOperationQueue，单独使用NSOperation的情况下系统同步执行操作，下面我们学习以下任务的三种创建方式。</p>\n<h6 id=\"2-1-1-使用子类-NSInvocationOperation\"><a href=\"#2-1-1-使用子类-NSInvocationOperation\" class=\"headerlink\" title=\"2.1.1 使用子类- NSInvocationOperation:\"></a>2.1.1 使用子类<code>- NSInvocationOperation:</code></h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1.创建NSInvocationOperation对象</span><br><span class=\"line\">NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];</span><br><span class=\"line\"></span><br><span class=\"line\">// 2.调用start方法开始执行操作</span><br><span class=\"line\">[op start];</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)run</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;------%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果：</span><br><span class=\"line\">NSOperation[15834:2384555] ------&lt;NSThread: 0x7fa3e2e05410&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>从中可以看到，在没有使用NSOperationQueue、单独使用NSInvocationOperation的情况下，NSInvocationOperation在主线程执行操作，并没有开启新线程。</p>\n<h6 id=\"2-1-2-使用子类-NSBlockOperation\"><a href=\"#2-1-2-使用子类-NSBlockOperation\" class=\"headerlink\" title=\"2.1.2 使用子类- NSBlockOperation\"></a>2.1.2 使用子类<code>- NSBlockOperation</code></h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class=\"line\">    // 在主线程</span><br><span class=\"line\">    NSLog(@&quot;------%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">[op start];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果：</span><br><span class=\"line\">NSOperation[15884:2387780] ------&lt;NSThread: 0x7fb2196012c0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>我们同样可以看到，在没有使用NSOperationQueue、单独使用NSBlockOperation的情况下，NSBlockOperation也是在主线程执行操作，并没有开启新线程。</p>\n<p><strong>但是，NSBlockOperation还提供了一个方法<code>addExecutionBlock:</code>，通过<code>addExecutionBlock:</code>就可以为NSBlockOperation添加额外的操作，这些额外的操作就会在其他线程并发执行。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)blockOperation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class=\"line\">        // 在主线程</span><br><span class=\"line\">        NSLog(@&quot;1------%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;];    </span><br><span class=\"line\"></span><br><span class=\"line\">    // 添加额外的任务(在子线程执行)</span><br><span class=\"line\">    [op addExecutionBlock:^&#123;</span><br><span class=\"line\">        NSLog(@&quot;2------%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    [op addExecutionBlock:^&#123;</span><br><span class=\"line\">        NSLog(@&quot;3------%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    [op addExecutionBlock:^&#123;</span><br><span class=\"line\">        NSLog(@&quot;4------%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    [op start];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果：</span><br><span class=\"line\">NSOperation[15896:2390616] 1------&lt;NSThread: 0x7ff633f03be0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">NSOperation[15896:2390825] 2------&lt;NSThread: 0x7ff633e24600&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">NSOperation[15896:2390657] 3------&lt;NSThread: 0x7ff633c411e0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">NSOperation[15896:2390656] 4------&lt;NSThread: 0x7ff633f1d3e0&gt;&#123;number = 4, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出，<code>blockOperationWithBlock:</code>方法中的操作是在主线程中执行的，而<code>addExecutionBlock:</code>方法中的操作是在其他线程中执行的。</p>\n<h6 id=\"2-1-3-定义继承自NSOperation的子类\"><a href=\"#2-1-3-定义继承自NSOperation的子类\" class=\"headerlink\" title=\"2.1.3 定义继承自NSOperation的子类\"></a>2.1.3 定义继承自NSOperation的子类</h6><p>h文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">@interface LQOperation : NSOperation</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>m文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;LQOperation.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation LQOperation</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 需要执行的任务</span><br><span class=\"line\"> */</span><br><span class=\"line\">- (void)main</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">        NSLog(@&quot;1-----%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>然后使用的时候导入头文件<code>LQOperation.h</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建YSCOperation</span><br><span class=\"line\">LQOperation *op = [[LQOperation alloc] init];</span><br><span class=\"line\">[op start];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果：</span><br><span class=\"line\">NSOperation[16566:2501606] 1-----&lt;NSThread: 0x7f8030d05150&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">NSOperation[16566:2501606] 1-----&lt;NSThread: 0x7f8030d05150&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出：在没有使用NSOperationQueue、单独使用自定义子类的情况下，是在主线程执行操作，并没有开启新线程。</p>\n<h5 id=\"2-2-创建队列\"><a href=\"#2-2-创建队列\" class=\"headerlink\" title=\"2.2 创建队列\"></a>2.2 创建队列</h5><p>和GCD中的并发队列、串行队列略有不同的是：<code>NSOperationQueue</code>一共有两种队列：主队列、其他队列。其中其他队列同时包含了串行、并发功能。下边是主队列、其他队列的基本创建方法和特点</p>\n<ul>\n<li><p>主队列</p>\n<ul>\n<li><p>凡是添加到主队列中的任务（NSOperation），都会放到主线程中执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSOperationQueue *queue = [NSOperationQueue mainQueue];</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>其他队列（非主队列）</p>\n<ul>\n<li><p>添加到这种队列中的任务（NSOperation），就会自动放到子线程中执行</p>\n</li>\n<li><p>同时包含了：串行、并发功能</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"2-3-将任务加入到队列中\"><a href=\"#2-3-将任务加入到队列中\" class=\"headerlink\" title=\"2.3 将任务加入到队列中\"></a>2.3 将任务加入到队列中</h5><p>前边说了，NSOperation需要配合NSOperationQueue来实现多线程。<br>那么我们需要将创建好的任务加入到队列中去。总共有两种方法</p>\n<h6 id=\"2-3-1-void-addOperation-NSOperation-op\"><a href=\"#2-3-1-void-addOperation-NSOperation-op\" class=\"headerlink\" title=\"2.3.1 -(void)addOperation:(NSOperation *)op;\"></a>2.3.1 <code>-(void)addOperation:(NSOperation *)op;</code></h6><ul>\n<li><p>需要先创建任务，再将创建好的任务加入到创建好的队列中去</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)addOperationToQueue</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 1.创建队列</span><br><span class=\"line\">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\">    // 2. 创建操作  </span><br><span class=\"line\">    // 创建NSInvocationOperation    </span><br><span class=\"line\">    NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];    </span><br><span class=\"line\">    // 创建NSBlockOperation    </span><br><span class=\"line\">    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;1-----%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    // 3. 添加操作到队列中：addOperation:   </span><br><span class=\"line\">    [queue addOperation:op1]; // [op1 start]    </span><br><span class=\"line\">    [queue addOperation:op2]; // [op2 start]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)run</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">        NSLog(@&quot;2-----%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果：</span><br><span class=\"line\">NSOperationQueue[16201:2452281] 1-----&lt;NSThread: 0x7fe4824080e0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">NSOperationQueue[16201:2452175] 2-----&lt;NSThread: 0x7fe482404a50&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">NSOperationQueue[16201:2452175] 2-----&lt;NSThread: 0x7fe482404a50&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">NSOperationQueue[16201:2452281] 1-----&lt;NSThread: 0x7fe4824080e0&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出：NSInvocationOperation和NSOperationQueue结合后能够开启新线程，进行并发执行，NSBlockOperation和NSOperationQueue也能够开启新线程，进行并发执行。</p>\n</li>\n</ul>\n<h6 id=\"2-3-2-void-addOperationWithBlock-void-void-block\"><a href=\"#2-3-2-void-addOperationWithBlock-void-void-block\" class=\"headerlink\" title=\"2.3.2 - (void)addOperationWithBlock:(void (^)(void))block;\"></a>2.3.2 <code>- (void)addOperationWithBlock:(void (^)(void))block;</code></h6><ul>\n<li><p>无需先创建任务，在block中添加任务，直接将任务block加入到队列中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)addOperationWithBlockToQueue</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 1. 创建队列</span><br><span class=\"line\">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\">    // 2. 添加操作到队列中：addOperationWithBlock:</span><br><span class=\"line\">    [queue addOperationWithBlock:^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;-----%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果：</span><br><span class=\"line\">NSOperationQueue[16293:2457487] -----&lt;NSThread: 0x7ffa6bc0e1e0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">NSOperationQueue[16293:2457487] -----&lt;NSThread: 0x7ffa6bc0e1e0&gt;&#123;number = 2, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出addOperationWithBlock:和NSOperationQueue能够开启新线程，进行并发执行。</p>\n</li>\n</ul>\n<h4 id=\"3-控制串行执行和并行执行的关键\"><a href=\"#3-控制串行执行和并行执行的关键\" class=\"headerlink\" title=\"3 控制串行执行和并行执行的关键\"></a>3 控制串行执行和并行执行的关键</h4><p>之前我们说过，NSOperationQueue创建的其他队列同时具有串行、并发功能，上边我们演示了并发功能，那么他的串行功能是如何实现的？</p>\n<p>这里有个关键参数<code>maxConcurrentOperationCount</code>，叫做<strong>最大并发数</strong>。</p>\n<ul>\n<li><p>最大并发数：<code>maxConcurrentOperationCount</code></p>\n<ul>\n<li><code>maxConcurrentOperationCount</code>默认情况下为-1，表示不进行限制，默认为并发执行。</li>\n<li>当<code>maxConcurrentOperationCount</code>为1时，进行串行执行。</li>\n<li>当<code>maxConcurrentOperationCount</code>大于1时，进行并发执行，当然这个值不应超过系统限制，即使自己设置一个很大的值，系统也会自动调整。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)opetationQueue</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 创建队列</span><br><span class=\"line\">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置最大并发操作数</span><br><span class=\"line\">    //    queue.maxConcurrentOperationCount = 2;</span><br><span class=\"line\">    queue.maxConcurrentOperationCount = 1; // 就变成了串行队列</span><br><span class=\"line\"></span><br><span class=\"line\">    // 添加操作</span><br><span class=\"line\">    [queue addOperationWithBlock:^&#123;</span><br><span class=\"line\">        NSLog(@&quot;1-----%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:0.01];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    [queue addOperationWithBlock:^&#123;</span><br><span class=\"line\">        NSLog(@&quot;2-----%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:0.01];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    [queue addOperationWithBlock:^&#123;</span><br><span class=\"line\">        NSLog(@&quot;3-----%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:0.01];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    [queue addOperationWithBlock:^&#123;</span><br><span class=\"line\">        NSLog(@&quot;4-----%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:0.01];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    [queue addOperationWithBlock:^&#123;</span><br><span class=\"line\">        NSLog(@&quot;5-----%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:0.01];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    [queue addOperationWithBlock:^&#123;</span><br><span class=\"line\">        NSLog(@&quot;6-----%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:0.01];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最大并发数为1输出结果：</span><br><span class=\"line\">NSOperationQueue[16320:2464630] 1-----&lt;NSThread: 0x7fc892d0b3a0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">NSOperationQueue[16320:2464631] 2-----&lt;NSThread: 0x7fc892c0a7b0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">NSOperationQueue[16320:2464630] 3-----&lt;NSThread: 0x7fc892d0b3a0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">NSOperationQueue[16320:2464631] 4-----&lt;NSThread: 0x7fc892c0a7b0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">NSOperationQueue[16320:2464631] 5-----&lt;NSThread: 0x7fc892c0a7b0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">NSOperationQueue[16320:2464630] 6-----&lt;NSThread: 0x7fc892d0b3a0&gt;&#123;number = 2, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最大并发数为2输出结果：</span><br><span class=\"line\">NSOperationQueue[16331:2466366] 2-----&lt;NSThread: 0x7fd729f0f270&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">NSOperationQueue[16331:2466491] 1-----&lt;NSThread: 0x7fd729f4e290&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">NSOperationQueue[16331:2466367] 3-----&lt;NSThread: 0x7fd729d214e0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class=\"line\">NSOperationQueue[16331:2466366] 4-----&lt;NSThread: 0x7fd729f0f270&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">NSOperationQueue[16331:2466366] 6-----&lt;NSThread: 0x7fd729f0f270&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">NSOperationQueue[16331:2466511] 5-----&lt;NSThread: 0x7fd729e056c0&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出：当最大并发数为1时，任务是按顺序串行执行的。当最大并发数为2时，任务是并发执行的。而且开启线程数量是由系统决定的，不需要我们来管理。这样看来，是不是比GCD还要简单了许多？</p>\n</li>\n</ul>\n<h4 id=\"4-操作依赖\"><a href=\"#4-操作依赖\" class=\"headerlink\" title=\"4 操作依赖\"></a>4 操作依赖</h4><p>NSOperation和NSOperationQueue最吸引人的地方是它能添加操作之间的依赖关系。比如说有A、B两个操作，其中A执行完操作，B才能执行操作，那么就需要让B依赖于A。具体如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)addDependency</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\">    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class=\"line\">        NSLog(@&quot;1-----%@&quot;, [NSThread  currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class=\"line\">        NSLog(@&quot;2-----%@&quot;, [NSThread  currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    [op1 addDependency:op2];    // 让op1 依赖于 op2，则先执行op2，再执行op1</span><br><span class=\"line\"></span><br><span class=\"line\">    [queue addOperation:op1];</span><br><span class=\"line\">    [queue addOperation:op2];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果：</span><br><span class=\"line\">操作依赖[16423:2484866] 2-----&lt;NSThread: 0x7fc138e1e7c0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">操作依赖[16423:2484866] 1-----&lt;NSThread: 0x7fc138e1e7c0&gt;&#123;number = 2, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，无论运行几次，其结果都是op2先执行，op1后执行。</p>\n<h4 id=\"5-一些其他方法\"><a href=\"#5-一些其他方法\" class=\"headerlink\" title=\"5 一些其他方法\"></a>5 一些其他方法</h4><ul>\n<li><code>- (void)cancel;</code> NSOperation提供的方法，可取消单个操作</li>\n<li><code>- (void)cancelAllOperations;</code> NSOperationQueue提供的方法，可以取消队列的所有操作</li>\n<li><code>- (void)setSuspended:(BOOL)b;</code> 可设置任务的暂停和恢复，YES代表暂停队列，NO代表恢复队列</li>\n<li><code>- (BOOL)isSuspended;</code> 判断暂停状态</li>\n</ul>\n<p><strong>注意：</strong></p>\n<ul>\n<li><p>这里的暂停和取消并不代表可以将当前的操作立即取消，而是当当前的操作执行完毕之后不再执行新的操作。</p>\n</li>\n<li><p>暂停和取消的区别就在于：暂停操作之后还可以恢复操作，继续向下执行；而取消操作之后，所有的操作就清空了，无法再接着执行剩下的操作。</p>\n<p>​</p>\n</li>\n</ul>\n<p>转载自<a href=\"http://www.jianshu.com/p/4b1d77054b35\" target=\"_blank\" rel=\"noopener\">iOS多线程–彻底学会多线程</a></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"1-NSOperation简介\"><a href=\"#1-NSOperation简介\" class=\"headerlink\" title=\"1 NSOperation简介\"></a>1 NSOperation简介</h4><p>NSOperation是苹果提供给我们的一套多线程解决方案。实际上NSOperation是基于GCD更高一层的封装，但是比GCD更简单易用、代码可读性也更高。</p>\n<p>NSOperation需要配合NSOperationQueue来实现多线程。<strong>因为默认情况下，NSOperation单独使用时系统同步执行操作，并没有开辟新线程的能力，只有配合NSOperationQueue才能实现异步执行。</strong></p>\n<p>因为NSOperation是基于GCD的，那么使用起来也和GCD差不多，其中，NSOperation相当于GCD中的任务，而NSOperationQueue则相当于GCD中的队列。NSOperation实现多线程的使用步骤分为三步：</p>\n<ul>\n<li><p>1 创建任务：先将需要执行的操作封装到一个NSOperation对象中。</p>\n</li>\n<li><p>2 创建队列：创建NSOperationQueue对象。</p>\n</li>\n<li><p>3 将任务加入到队列中：然后将NSOperation对象添加到NSOperationQueue中。</p>\n</li>\n</ul>\n<p>之后呢，系统就会自动将NSOperationQueue中的NSOperation取出来，在新线程中执行操作。</p>\n<p>下面我们来学习下NSOperation和NSOperationQueue的基本使用。</p>","more":"<h4 id=\"2-NSOperation和NSOperationQueue的基本使用\"><a href=\"#2-NSOperation和NSOperationQueue的基本使用\" class=\"headerlink\" title=\"2 NSOperation和NSOperationQueue的基本使用\"></a>2 NSOperation和NSOperationQueue的基本使用</h4><h5 id=\"2-1-创建任务\"><a href=\"#2-1-创建任务\" class=\"headerlink\" title=\"2.1 创建任务\"></a>2.1 创建任务</h5><p>NSOperation是个抽象类，并不能封装任务。我们只有使用它的子类来封装任务。我们有三种方式来封装任务。</p>\n<ul>\n<li>1 使用子类NSInvocationOperation</li>\n<li>2 使用子类NSBlockOperation</li>\n<li>3 定义继承自NSOperation的子类，通过实现内部相应的方法来封装任务。</li>\n</ul>\n<p>在不使用NSOperationQueue，单独使用NSOperation的情况下系统同步执行操作，下面我们学习以下任务的三种创建方式。</p>\n<h6 id=\"2-1-1-使用子类-NSInvocationOperation\"><a href=\"#2-1-1-使用子类-NSInvocationOperation\" class=\"headerlink\" title=\"2.1.1 使用子类- NSInvocationOperation:\"></a>2.1.1 使用子类<code>- NSInvocationOperation:</code></h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1.创建NSInvocationOperation对象</span><br><span class=\"line\">NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];</span><br><span class=\"line\"></span><br><span class=\"line\">// 2.调用start方法开始执行操作</span><br><span class=\"line\">[op start];</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)run</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;------%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果：</span><br><span class=\"line\">NSOperation[15834:2384555] ------&lt;NSThread: 0x7fa3e2e05410&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>从中可以看到，在没有使用NSOperationQueue、单独使用NSInvocationOperation的情况下，NSInvocationOperation在主线程执行操作，并没有开启新线程。</p>\n<h6 id=\"2-1-2-使用子类-NSBlockOperation\"><a href=\"#2-1-2-使用子类-NSBlockOperation\" class=\"headerlink\" title=\"2.1.2 使用子类- NSBlockOperation\"></a>2.1.2 使用子类<code>- NSBlockOperation</code></h6><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class=\"line\">    // 在主线程</span><br><span class=\"line\">    NSLog(@&quot;------%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">[op start];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果：</span><br><span class=\"line\">NSOperation[15884:2387780] ------&lt;NSThread: 0x7fb2196012c0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>我们同样可以看到，在没有使用NSOperationQueue、单独使用NSBlockOperation的情况下，NSBlockOperation也是在主线程执行操作，并没有开启新线程。</p>\n<p><strong>但是，NSBlockOperation还提供了一个方法<code>addExecutionBlock:</code>，通过<code>addExecutionBlock:</code>就可以为NSBlockOperation添加额外的操作，这些额外的操作就会在其他线程并发执行。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)blockOperation</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class=\"line\">        // 在主线程</span><br><span class=\"line\">        NSLog(@&quot;1------%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;];    </span><br><span class=\"line\"></span><br><span class=\"line\">    // 添加额外的任务(在子线程执行)</span><br><span class=\"line\">    [op addExecutionBlock:^&#123;</span><br><span class=\"line\">        NSLog(@&quot;2------%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    [op addExecutionBlock:^&#123;</span><br><span class=\"line\">        NSLog(@&quot;3------%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    [op addExecutionBlock:^&#123;</span><br><span class=\"line\">        NSLog(@&quot;4------%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    [op start];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果：</span><br><span class=\"line\">NSOperation[15896:2390616] 1------&lt;NSThread: 0x7ff633f03be0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">NSOperation[15896:2390825] 2------&lt;NSThread: 0x7ff633e24600&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">NSOperation[15896:2390657] 3------&lt;NSThread: 0x7ff633c411e0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">NSOperation[15896:2390656] 4------&lt;NSThread: 0x7ff633f1d3e0&gt;&#123;number = 4, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出，<code>blockOperationWithBlock:</code>方法中的操作是在主线程中执行的，而<code>addExecutionBlock:</code>方法中的操作是在其他线程中执行的。</p>\n<h6 id=\"2-1-3-定义继承自NSOperation的子类\"><a href=\"#2-1-3-定义继承自NSOperation的子类\" class=\"headerlink\" title=\"2.1.3 定义继承自NSOperation的子类\"></a>2.1.3 定义继承自NSOperation的子类</h6><p>h文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">@interface LQOperation : NSOperation</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>m文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;LQOperation.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation LQOperation</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 需要执行的任务</span><br><span class=\"line\"> */</span><br><span class=\"line\">- (void)main</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">        NSLog(@&quot;1-----%@&quot;,[NSThread currentThread]);</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>然后使用的时候导入头文件<code>LQOperation.h</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建YSCOperation</span><br><span class=\"line\">LQOperation *op = [[LQOperation alloc] init];</span><br><span class=\"line\">[op start];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果：</span><br><span class=\"line\">NSOperation[16566:2501606] 1-----&lt;NSThread: 0x7f8030d05150&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">NSOperation[16566:2501606] 1-----&lt;NSThread: 0x7f8030d05150&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出：在没有使用NSOperationQueue、单独使用自定义子类的情况下，是在主线程执行操作，并没有开启新线程。</p>\n<h5 id=\"2-2-创建队列\"><a href=\"#2-2-创建队列\" class=\"headerlink\" title=\"2.2 创建队列\"></a>2.2 创建队列</h5><p>和GCD中的并发队列、串行队列略有不同的是：<code>NSOperationQueue</code>一共有两种队列：主队列、其他队列。其中其他队列同时包含了串行、并发功能。下边是主队列、其他队列的基本创建方法和特点</p>\n<ul>\n<li><p>主队列</p>\n<ul>\n<li><p>凡是添加到主队列中的任务（NSOperation），都会放到主线程中执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSOperationQueue *queue = [NSOperationQueue mainQueue];</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>其他队列（非主队列）</p>\n<ul>\n<li><p>添加到这种队列中的任务（NSOperation），就会自动放到子线程中执行</p>\n</li>\n<li><p>同时包含了：串行、并发功能</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"2-3-将任务加入到队列中\"><a href=\"#2-3-将任务加入到队列中\" class=\"headerlink\" title=\"2.3 将任务加入到队列中\"></a>2.3 将任务加入到队列中</h5><p>前边说了，NSOperation需要配合NSOperationQueue来实现多线程。<br>那么我们需要将创建好的任务加入到队列中去。总共有两种方法</p>\n<h6 id=\"2-3-1-void-addOperation-NSOperation-op\"><a href=\"#2-3-1-void-addOperation-NSOperation-op\" class=\"headerlink\" title=\"2.3.1 -(void)addOperation:(NSOperation *)op;\"></a>2.3.1 <code>-(void)addOperation:(NSOperation *)op;</code></h6><ul>\n<li><p>需要先创建任务，再将创建好的任务加入到创建好的队列中去</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)addOperationToQueue</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 1.创建队列</span><br><span class=\"line\">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\">    // 2. 创建操作  </span><br><span class=\"line\">    // 创建NSInvocationOperation    </span><br><span class=\"line\">    NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];    </span><br><span class=\"line\">    // 创建NSBlockOperation    </span><br><span class=\"line\">    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;1-----%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    // 3. 添加操作到队列中：addOperation:   </span><br><span class=\"line\">    [queue addOperation:op1]; // [op1 start]    </span><br><span class=\"line\">    [queue addOperation:op2]; // [op2 start]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)run</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">        NSLog(@&quot;2-----%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果：</span><br><span class=\"line\">NSOperationQueue[16201:2452281] 1-----&lt;NSThread: 0x7fe4824080e0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">NSOperationQueue[16201:2452175] 2-----&lt;NSThread: 0x7fe482404a50&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">NSOperationQueue[16201:2452175] 2-----&lt;NSThread: 0x7fe482404a50&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">NSOperationQueue[16201:2452281] 1-----&lt;NSThread: 0x7fe4824080e0&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出：NSInvocationOperation和NSOperationQueue结合后能够开启新线程，进行并发执行，NSBlockOperation和NSOperationQueue也能够开启新线程，进行并发执行。</p>\n</li>\n</ul>\n<h6 id=\"2-3-2-void-addOperationWithBlock-void-void-block\"><a href=\"#2-3-2-void-addOperationWithBlock-void-void-block\" class=\"headerlink\" title=\"2.3.2 - (void)addOperationWithBlock:(void (^)(void))block;\"></a>2.3.2 <code>- (void)addOperationWithBlock:(void (^)(void))block;</code></h6><ul>\n<li><p>无需先创建任务，在block中添加任务，直接将任务block加入到队列中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)addOperationWithBlockToQueue</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 1. 创建队列</span><br><span class=\"line\">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\">    // 2. 添加操作到队列中：addOperationWithBlock:</span><br><span class=\"line\">    [queue addOperationWithBlock:^&#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class=\"line\">            NSLog(@&quot;-----%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果：</span><br><span class=\"line\">NSOperationQueue[16293:2457487] -----&lt;NSThread: 0x7ffa6bc0e1e0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">NSOperationQueue[16293:2457487] -----&lt;NSThread: 0x7ffa6bc0e1e0&gt;&#123;number = 2, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出addOperationWithBlock:和NSOperationQueue能够开启新线程，进行并发执行。</p>\n</li>\n</ul>\n<h4 id=\"3-控制串行执行和并行执行的关键\"><a href=\"#3-控制串行执行和并行执行的关键\" class=\"headerlink\" title=\"3 控制串行执行和并行执行的关键\"></a>3 控制串行执行和并行执行的关键</h4><p>之前我们说过，NSOperationQueue创建的其他队列同时具有串行、并发功能，上边我们演示了并发功能，那么他的串行功能是如何实现的？</p>\n<p>这里有个关键参数<code>maxConcurrentOperationCount</code>，叫做<strong>最大并发数</strong>。</p>\n<ul>\n<li><p>最大并发数：<code>maxConcurrentOperationCount</code></p>\n<ul>\n<li><code>maxConcurrentOperationCount</code>默认情况下为-1，表示不进行限制，默认为并发执行。</li>\n<li>当<code>maxConcurrentOperationCount</code>为1时，进行串行执行。</li>\n<li>当<code>maxConcurrentOperationCount</code>大于1时，进行并发执行，当然这个值不应超过系统限制，即使自己设置一个很大的值，系统也会自动调整。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)opetationQueue</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 创建队列</span><br><span class=\"line\">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\">    // 设置最大并发操作数</span><br><span class=\"line\">    //    queue.maxConcurrentOperationCount = 2;</span><br><span class=\"line\">    queue.maxConcurrentOperationCount = 1; // 就变成了串行队列</span><br><span class=\"line\"></span><br><span class=\"line\">    // 添加操作</span><br><span class=\"line\">    [queue addOperationWithBlock:^&#123;</span><br><span class=\"line\">        NSLog(@&quot;1-----%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:0.01];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    [queue addOperationWithBlock:^&#123;</span><br><span class=\"line\">        NSLog(@&quot;2-----%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:0.01];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    [queue addOperationWithBlock:^&#123;</span><br><span class=\"line\">        NSLog(@&quot;3-----%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:0.01];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    [queue addOperationWithBlock:^&#123;</span><br><span class=\"line\">        NSLog(@&quot;4-----%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:0.01];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    [queue addOperationWithBlock:^&#123;</span><br><span class=\"line\">        NSLog(@&quot;5-----%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:0.01];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    [queue addOperationWithBlock:^&#123;</span><br><span class=\"line\">        NSLog(@&quot;6-----%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:0.01];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最大并发数为1输出结果：</span><br><span class=\"line\">NSOperationQueue[16320:2464630] 1-----&lt;NSThread: 0x7fc892d0b3a0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">NSOperationQueue[16320:2464631] 2-----&lt;NSThread: 0x7fc892c0a7b0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">NSOperationQueue[16320:2464630] 3-----&lt;NSThread: 0x7fc892d0b3a0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">NSOperationQueue[16320:2464631] 4-----&lt;NSThread: 0x7fc892c0a7b0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">NSOperationQueue[16320:2464631] 5-----&lt;NSThread: 0x7fc892c0a7b0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">NSOperationQueue[16320:2464630] 6-----&lt;NSThread: 0x7fc892d0b3a0&gt;&#123;number = 2, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最大并发数为2输出结果：</span><br><span class=\"line\">NSOperationQueue[16331:2466366] 2-----&lt;NSThread: 0x7fd729f0f270&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">NSOperationQueue[16331:2466491] 1-----&lt;NSThread: 0x7fd729f4e290&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">NSOperationQueue[16331:2466367] 3-----&lt;NSThread: 0x7fd729d214e0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class=\"line\">NSOperationQueue[16331:2466366] 4-----&lt;NSThread: 0x7fd729f0f270&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">NSOperationQueue[16331:2466366] 6-----&lt;NSThread: 0x7fd729f0f270&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">NSOperationQueue[16331:2466511] 5-----&lt;NSThread: 0x7fd729e056c0&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出：当最大并发数为1时，任务是按顺序串行执行的。当最大并发数为2时，任务是并发执行的。而且开启线程数量是由系统决定的，不需要我们来管理。这样看来，是不是比GCD还要简单了许多？</p>\n</li>\n</ul>\n<h4 id=\"4-操作依赖\"><a href=\"#4-操作依赖\" class=\"headerlink\" title=\"4 操作依赖\"></a>4 操作依赖</h4><p>NSOperation和NSOperationQueue最吸引人的地方是它能添加操作之间的依赖关系。比如说有A、B两个操作，其中A执行完操作，B才能执行操作，那么就需要让B依赖于A。具体如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)addDependency</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\">    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class=\"line\">        NSLog(@&quot;1-----%@&quot;, [NSThread  currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class=\"line\">        NSLog(@&quot;2-----%@&quot;, [NSThread  currentThread]);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    [op1 addDependency:op2];    // 让op1 依赖于 op2，则先执行op2，再执行op1</span><br><span class=\"line\"></span><br><span class=\"line\">    [queue addOperation:op1];</span><br><span class=\"line\">    [queue addOperation:op2];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输出结果：</span><br><span class=\"line\">操作依赖[16423:2484866] 2-----&lt;NSThread: 0x7fc138e1e7c0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">操作依赖[16423:2484866] 1-----&lt;NSThread: 0x7fc138e1e7c0&gt;&#123;number = 2, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，无论运行几次，其结果都是op2先执行，op1后执行。</p>\n<h4 id=\"5-一些其他方法\"><a href=\"#5-一些其他方法\" class=\"headerlink\" title=\"5 一些其他方法\"></a>5 一些其他方法</h4><ul>\n<li><code>- (void)cancel;</code> NSOperation提供的方法，可取消单个操作</li>\n<li><code>- (void)cancelAllOperations;</code> NSOperationQueue提供的方法，可以取消队列的所有操作</li>\n<li><code>- (void)setSuspended:(BOOL)b;</code> 可设置任务的暂停和恢复，YES代表暂停队列，NO代表恢复队列</li>\n<li><code>- (BOOL)isSuspended;</code> 判断暂停状态</li>\n</ul>\n<p><strong>注意：</strong></p>\n<ul>\n<li><p>这里的暂停和取消并不代表可以将当前的操作立即取消，而是当当前的操作执行完毕之后不再执行新的操作。</p>\n</li>\n<li><p>暂停和取消的区别就在于：暂停操作之后还可以恢复操作，继续向下执行；而取消操作之后，所有的操作就清空了，无法再接着执行剩下的操作。</p>\n<p>​</p>\n</li>\n</ul>\n<p>转载自<a href=\"http://www.jianshu.com/p/4b1d77054b35\" target=\"_blank\" rel=\"noopener\">iOS多线程–彻底学会多线程</a></p>"},{"title":"NSRunLoop简介","date":"2017-12-08T07:33:34.000Z","_content":"\n#### 1 RunLoop简介\n\n##### 1.1 什么是RunLoop？\n\n可以理解为字面意思：Run表示运行，Loop表示循环。结合在一起就是运行的循环的意思。\n\nRunLoop实际上是一个对象，这个对象在循环中用来处理程序运行过程中出现的各种事件（比如说触摸事件、UI刷新事件、定时器事件、Selector事件），从而保持程序的持续运行；而且在没有事件处理的时候，会进入睡眠模式，从而节省CPU资源，提高程序性能。\n\n<!-- more -->\n\n##### 1.2 RunLoop和线程\n\nRunLoop和线程是息息相关的，我们知道线程的作用是用来执行特定的一个或多个任务，但是在默认情况下，线程执行完之后就会退出，就不能再执行任务了。这时我们就需要采用一种方式来让线程能够处理任务，并不退出。所以，我们就有了RunLoop。\n\n- 1 一条线程对应一个RunLoop对象，每条线程都有唯一一个与之对应的RunLoop对象。\n- 2 我们只能在当前线程中操作当前线程的RunLoop，而不能去操作其他线程的RunLoop。\n- 3 RunLoop对象在第一次获取RunLoop时创建，销毁则是在线程结束的时候。\n- 4 主线程的RunLoop对象系统自动帮助我们创建好了(原理如下)，而子线程的RunLoop对象需要我们主动创建。\n\n##### 1.3 默认情况下主线程的RunLoop原理\n\n我们在启动一个iOS程序的时候，系统会调用创建项目时自动生成的main.m的文件。main.m文件如下所示：\n\n```objective-c\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}\n```\n\n其中`UIApplicationMain`函数内部帮我们开启了主线程的RunLoop，`UIApplicationMain`内部拥有一个无线循环的代码。上边的代码中开启RunLoop的过程可以简单的理解为如下代码：\n\n```objective-c\nint main(int argc, char * argv[]) {        \n    BOOL running = YES;\n    do {\n        // 执行各种任务，处理各种事件\n        // ......\n    } while (running);\n\n    return 0;\n}\n```\n\n从上边可看出，程序一直在do-while循环中执行，所以UIApplicationMain函数一直没有返回，我们在运行程序之后程序不会马上退出，会保持持续运行状态。\n\n下图是苹果官方给出的RunLoop模型图。\n\n![1](NSRunLoop简介/2017_12_08RunLoop_1.jpg)\n\n从上图中可以看出，RunLoop就是线程中的一个循环，RunLoop在循环中会不断检测，通过Input sources（输入源）和Timer sources（定时源）两种来源等待接受事件；然后对接受到的事件通知线程进行处理，并在没有事件的时候进行休息。\n\n#### 2 RunLoop相关类\n\n下面我们来了解一下Core Foundation框架下关于RunLoop的5个类，只有弄懂这几个类的含义，我们才能深入了解RunLoop运行机制。\n\n- 1 CFRunLoopRef：代表RunLoop的对象\n- 2 CFRunLoopModeRef：RunLoop的运行模式\n- 3 CFRunLoopSourceRef：就是RunLoop模型图中提到的输入源/事件源\n- 4 CFRunLoopTimerRef：就是RunLoop模型图中提到的定时源\n- 5 CFRunLoopObserverRef：观察者，能够监听RunLoop的状态改变\n\n下边详细讲解下几种类的具体含义和关系。\n\n![1](NSRunLoop简介/2017_12_08RunLoop_2.png)\n\n一个RunLoop对象（CFRunLoopRef）中包含若干个运行模式（CFRunLoopModeRef）。而每一个运行模式下又包含若干个输入源（CFRunLoopSourceRef）、定时源（CFRunLoopTimerRef）、观察者（CFRunLoopObserverRef）。\n\n- 每次RunLoop启动时，只能指定其中一个运行模式（CFRunLoopModeRef），这个运行模式（CFRunLoopModeRef）被称作CurrentMode。\n- 如果需要切换运行模式（CFRunLoopModeRef），只能退出Loop，再重新指定一个运行模式（CFRunLoopModeRef）进入。\n- 这样做主要是为了分隔开不同组的输入源（CFRunLoopSourceRef）、定时源（CFRunLoopTimerRef）、观察者（CFRunLoopObserverRef），让其互不影响 。\n\n##### 2.1 CFRunLoopRef\n\nCFRunLoopRef就是Core Foundation框架下RunLoop对象类。我们可通过以下方式来获取RunLoop对象：\n\n- Core Foundation\n  - `CFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象`\n  - `CFRunLoopGetMain(); // 获得主线程的RunLoop对象`\n\n当然，在Foundation框架下获取RunLoop对象类的方法如下：\n\n- Foundation\n  - `[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象`\n  - `[NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象`\n\n##### 2.2 CFRunLoopModeRef\n\n系统默认定义了多种运行模式（CFRunLoopModeRef），如下：\n\n- 1 **kCFRunLoopDefaultMode**：App的默认运行模式，通常主线程是在这个运行模式下运行\n- 2 **UITrackingRunLoopMode**：跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响）\n- 3 **UIInitializationRunLoopMode**：在刚启动App时第进入的第一个 Mode，启动完成后就不再使用\n- 4 **GSEventReceiveRunLoopMode**：接受系统内部事件，通常用不到\n- 5 **kCFRunLoopCommonModes**：伪模式，不是一种真正的运行模式（后边会用到）\n\n其中**kCFRunLoopDefaultMode**、**UITrackingRunLoopMode**、**kCFRunLoopCommonModes**是我们开发中需要用到的模式，具体使用方法我们在 **CFRunLoopTimerRef** 中结合CFRunLoopTimerRef来演示说明。\n\n##### 2.3 CFRunLoopTimerRef\n\nCFRunLoopTimerRef是定时源（RunLoop模型图中提到过），理解为基于时间的触发器，基本上就是NSTimer。\n\n下面我们来演示下CFRunLoopModeRef和CFRunLoopTimerRef结合的使用用法:\n\n- 1 首先我们新建一个iOS项目，在Main.storyboard中拖入一个Text View。\n\n- 2 在ViewController.m文件中加入以下代码\n\n  ```objective-c\n  // 定义一个定时器，约定两秒之后调用self的run方法\n  NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];\n\n  // 将定时器添加到当前RunLoop的NSDefaultRunLoopMode下\n  [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];\n\n  - (void)run\n  {\n      NSLog(@\"---run\");\n  }\n  ```\n\n- 3 然后运行，这时候我们发现如果我们不对模拟器进行任何操作的话，定时器会稳定的每隔2秒调用run方法打印。\n\n- 4 但是当我们拖动Text View滚动时，我们发现：run方法不打印了，也就是说NSTimer不工作了。而当我们松开鼠标的时候，NSTimer就又开始正常工作了。\n\n  原因：\n\n  - 当我们不做任何操作的时候，RunLoop处于NSDefaultRunLoopMode下。\n  - 而当我们拖动Text View的时候，RunLoop就结束NSDefaultRunLoopMode，切换到了UITrackingRunLoopMode模式下，这个模式下没有添加NSTimer，所以我们的NSTimer就不工作了。\n  - 但当我们松开鼠标的时候，RunLoop就结束UITrackingRunLoopMode模式，又切换回NSDefaultRunLoopMode模式，所以NSTimer就又开始正常工作了。\n\n你可以试着将上述代码中的`[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];`语句换为`[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];`，也就是将定时器添加到当前RunLoop的UITrackingRunLoopMode下，你就会发现定时器只会在拖动Text View的模式下工作，而不做操作的时候定时器就不工作。\n\n那难道我们就不能在这两种模式下让NSTimer都能正常工作吗？\n\n当然可以，这就用到了我们之前说过的**伪模式（kCFRunLoopCommonModes）**，这其实不是一种真实的模式，而是一种标记模式，意思就是可以在打上Common Modes标记的模式下运行。\n\n那么哪些模式被标记上了Common Modes呢？\n\n**NSDefaultRunLoopMode** 和 **UITrackingRunLoopMode**。\n\n所以我们只要我们将NSTimer添加到当前RunLoop的kCFRunLoopCommonModes（Foundation框架下为NSRunLoopCommonModes）下，我们就可以让NSTimer在不做操作和拖动Text View两种情况下愉快的正常工作了。\n\n具体做法就是讲添加语句改为`[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];`\n\n既然讲到了NSTimer，这里顺便讲下NSTimer中的`scheduledTimerWithTimeInterval`方法和RunLoop的关系。添加下面的代码：\n\n```objective-c\n[NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];\n```\n\n这句代码调用了scheduledTimer返回的定时器，NSTimer会自动被加入到了RunLoop的NSDefaultRunLoopMode模式下。这句代码相当于下面两句代码：\n\n```objective-c\nNSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];\n[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];\n```\n\n##### 2.4 CFRunLoopSourceRef\n\nCFRunLoopSourceRef是事件源（RunLoop模型图中提到过），CFRunLoopSourceRef有两种分类方法。\n\n- 第一种按照官方文档来分类（就像RunLoop模型图中那样）：\n  - Port-Based Sources（基于端口）\n  - Custom Input Sources（自定义）\n  - Cocoa Perform Selector Sources\n- 第二种按照函数调用栈来分类：\n  - Source0 ：非基于Port\n  - Source1：基于Port，通过内核和其他线程通信，接收、分发系统事件\n\n这两种分类方式其实没有区别，只不过第一种是通过官方理论来分类，第二种是在实际应用中通过调用函数来分类。\n\n下边我们举个例子大致来了解一下函数调用栈和Source。\n\n- 1 在我们的项目中的Main.storyboard中添加一个Button按钮，并添加点击动作。\n\n- 2 然后在点击动作的代码中加入一句输出语句，并打上断点，如下图所示：\n\n  ![1](NSRunLoop简介/2017_12_08RunLoop_3.png)\n\n- 3 然后运行程序，并点击按钮。\n\n- 4 然后在项目中单击下下图红色部分。\n\n  ![1](NSRunLoop简介/2017_12_08RunLoop_4.png)\n\n- 5 可以看到如下图所示就是点击事件产生的函数调用栈。\n\n  ![1](NSRunLoop简介/2017_12_08RunLoop_5.png)\n\n所以点击事件是这样来的：\n\n1. 首先程序启动，调用16行的main函数，main函数调用15行UIApplicationMain函数，然后一直往上调用函数，最终调用到0行的BtnClick函数，即点击函数。\n2. 同时我们可以看到11行中有Sources0，也就是说我们点击事件是属于Sources0函数的，点击事件就是在Sources0中处理的。\n3. 而至于Sources1，则是用来接收、分发系统事件，然后再分发到Sources0中处理的。\n\n##### 2.5 CFRunLoopObserverRef\n\nCFRunLoopObserverRef是观察者，用来监听RunLoop的状态改变\n\nCFRunLoopObserverRef可以监听的状态改变有以下几种：\n\n```objective-c\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry = (1UL << 0),               // 即将进入Loop：1\n    kCFRunLoopBeforeTimers = (1UL << 1),        // 即将处理Timer：2    \n    kCFRunLoopBeforeSources = (1UL << 2),       // 即将处理Source：4\n    kCFRunLoopBeforeWaiting = (1UL << 5),       // 即将进入休眠：32\n    kCFRunLoopAfterWaiting = (1UL << 6),        // 即将从休眠中唤醒：64\n    kCFRunLoopExit = (1UL << 7),                // 即将从Loop中退出：128\n    kCFRunLoopAllActivities = 0x0FFFFFFFU       // 监听全部状态改变  \n};\n```\n\n下边我们通过代码来监听下RunLoop中的状态改变。\n\n1. 在ViewController.m中添加如下代码\n\n   ```objective-c\n   // 创建观察者\n   CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {\n       NSLog(@\"监听到RunLoop发生改变---%zd\",activity);\n   });\n\n   // 添加观察者到当前RunLoop中\n   CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);\n\n   // 释放observer，最后添加完需要释放掉\n   CFRelease(observer);\n   ```\n\n2. 然后运行，看下打印结果，如下图。\n\n   ![1](NSRunLoop简介/2017_12_08RunLoop_6.png)\n\n   可以看到RunLoop的状态在不断的改变，最终变成了状态 32，也就是即将进入睡眠状态，说明RunLoop之后就会进入睡眠状态。\n\n#### 3  RunLoop原理\n\n下面我们就可以来理解RunLoop的运行逻辑了。\n\n![1](NSRunLoop简介/2017_12_08RunLoop_7.png)\n\n在每次运行开启RunLoop的时候，所在线程的RunLoop会自动处理之前未处理的事件，并且通知相关的观察者。\n\n具体的顺序如下：\n\n1. 通知观察者RunLoop已经启动\n2. 通知观察者即将要开始的定时器\n3. 通知观察者任何即将启动的非基于端口的源\n4. 启动任何准备好的非基于端口的源\n5. 如果基于端口的源准备好并处于等待状态，立即启动；并进入步骤9\n6. 通知观察者线程进入休眠状态\n7. 将线程置于休眠知道任一下面的事件发生：\n   - 某一事件到达基于端口的源\n   - 定时器启动\n   - RunLoop设置的时间已经超时\n   - RunLoop被显示唤醒\n8. 通知观察者线程将被唤醒\n9. 处理未处理的事件\n   - 如果用户定义的定时器启动，处理定时器事件并重启RunLoop。进入步骤2\n   - 如果输入源启动，传递相应的消息\n   - 如果RunLoop被显示唤醒而且时间还没超时，重启RunLoop。进入步骤2\n10. 通知观察者RunLoop结束。\n\n#### 4 RunLoop应用\n\n##### 4.1  NSTimer的使用\n\nNSTimer的使用方法在讲解`CFRunLoopTimerRef`类的时候详细讲解过，具体参考上边 **2.3 CFRunLoopTimerRef**。\n\n##### 4.2 ImageView推迟显示\n\n有时候，我们会遇到这种情况：\n当界面中含有UITableView，而且每个UITableViewCell里边都有图片。这时候当我们滚动UITableView的时候，如果有一堆的图片需要显示，那么可能会出现卡顿的现象。这时候，我们应该推迟图片的显示，也就是ImageView推迟显示图片。有两种方法：\n\n- 监听UIScrollView的滚动\n\n  因为UITableView继承自UIScrollView，所以我们可以通过监听UIScrollView的滚动，实现UIScrollView相关delegate即可。\n\n-  利用PerformSelector设置当前线程的RunLoop的运行模式\n\n  利用`performSelector`方法为UIImageView调用`setImage:`方法，并利用`inModes`将其设置为RunLoop下NSDefaultRunLoopMode运行模式。代码如下：\n\n  ```objective-c\n  [self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@\"tupian\"] afterDelay:4.0 inModes:NSDefaultRunLoopMode];\n  ```\n\n##### 4.3 后台常驻线程（很常用）\n\n我们在开发应用程序的过程中，如果后台操作特别频繁，经常会在子线程做一些耗时操作（下载文件、后台播放音乐等），我们最好能让这条线程永远常驻内存。\n\n添加一条用于常驻内存的强引用的子线程，在该线程的RunLoop下添加一个Sources，开启RunLoop。\n\n```\n// 创建线程，并调用run1方法执行任务\nself.thread = [[NSThread alloc] initWithTarget:self selector:@selector(run1) object:nil];\n// 开启线程\n[self.thread start];    \n\n- (void) run1\n{\n    // 这里写任务\n    NSLog(@\"----run1-----\");\n    // 添加下边两句代码，就可以开启RunLoop，之后self.thread就变成了常驻线程，可随时添加任务，并交于RunLoop处理\n    [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];\n    [[NSRunLoop currentRunLoop] run];\n    // 测试是否开启了RunLoop，如果开启RunLoop，则来不了这里，因为RunLoop开启了循环。\n    NSLog(@\"未开启RunLoop\");\n}\n```\n\n运行之后发现打印了**----run1-----**，而**未开启RunLoop**则未打印。","source":"_posts/NSRunLoop简介.md","raw":"---\ntitle: NSRunLoop简介\ndate: 2017-12-08 15:33:34\ntags: iOS\ncategories: iOS Tips\n---\n\n#### 1 RunLoop简介\n\n##### 1.1 什么是RunLoop？\n\n可以理解为字面意思：Run表示运行，Loop表示循环。结合在一起就是运行的循环的意思。\n\nRunLoop实际上是一个对象，这个对象在循环中用来处理程序运行过程中出现的各种事件（比如说触摸事件、UI刷新事件、定时器事件、Selector事件），从而保持程序的持续运行；而且在没有事件处理的时候，会进入睡眠模式，从而节省CPU资源，提高程序性能。\n\n<!-- more -->\n\n##### 1.2 RunLoop和线程\n\nRunLoop和线程是息息相关的，我们知道线程的作用是用来执行特定的一个或多个任务，但是在默认情况下，线程执行完之后就会退出，就不能再执行任务了。这时我们就需要采用一种方式来让线程能够处理任务，并不退出。所以，我们就有了RunLoop。\n\n- 1 一条线程对应一个RunLoop对象，每条线程都有唯一一个与之对应的RunLoop对象。\n- 2 我们只能在当前线程中操作当前线程的RunLoop，而不能去操作其他线程的RunLoop。\n- 3 RunLoop对象在第一次获取RunLoop时创建，销毁则是在线程结束的时候。\n- 4 主线程的RunLoop对象系统自动帮助我们创建好了(原理如下)，而子线程的RunLoop对象需要我们主动创建。\n\n##### 1.3 默认情况下主线程的RunLoop原理\n\n我们在启动一个iOS程序的时候，系统会调用创建项目时自动生成的main.m的文件。main.m文件如下所示：\n\n```objective-c\nint main(int argc, char * argv[]) {\n    @autoreleasepool {\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}\n```\n\n其中`UIApplicationMain`函数内部帮我们开启了主线程的RunLoop，`UIApplicationMain`内部拥有一个无线循环的代码。上边的代码中开启RunLoop的过程可以简单的理解为如下代码：\n\n```objective-c\nint main(int argc, char * argv[]) {        \n    BOOL running = YES;\n    do {\n        // 执行各种任务，处理各种事件\n        // ......\n    } while (running);\n\n    return 0;\n}\n```\n\n从上边可看出，程序一直在do-while循环中执行，所以UIApplicationMain函数一直没有返回，我们在运行程序之后程序不会马上退出，会保持持续运行状态。\n\n下图是苹果官方给出的RunLoop模型图。\n\n![1](NSRunLoop简介/2017_12_08RunLoop_1.jpg)\n\n从上图中可以看出，RunLoop就是线程中的一个循环，RunLoop在循环中会不断检测，通过Input sources（输入源）和Timer sources（定时源）两种来源等待接受事件；然后对接受到的事件通知线程进行处理，并在没有事件的时候进行休息。\n\n#### 2 RunLoop相关类\n\n下面我们来了解一下Core Foundation框架下关于RunLoop的5个类，只有弄懂这几个类的含义，我们才能深入了解RunLoop运行机制。\n\n- 1 CFRunLoopRef：代表RunLoop的对象\n- 2 CFRunLoopModeRef：RunLoop的运行模式\n- 3 CFRunLoopSourceRef：就是RunLoop模型图中提到的输入源/事件源\n- 4 CFRunLoopTimerRef：就是RunLoop模型图中提到的定时源\n- 5 CFRunLoopObserverRef：观察者，能够监听RunLoop的状态改变\n\n下边详细讲解下几种类的具体含义和关系。\n\n![1](NSRunLoop简介/2017_12_08RunLoop_2.png)\n\n一个RunLoop对象（CFRunLoopRef）中包含若干个运行模式（CFRunLoopModeRef）。而每一个运行模式下又包含若干个输入源（CFRunLoopSourceRef）、定时源（CFRunLoopTimerRef）、观察者（CFRunLoopObserverRef）。\n\n- 每次RunLoop启动时，只能指定其中一个运行模式（CFRunLoopModeRef），这个运行模式（CFRunLoopModeRef）被称作CurrentMode。\n- 如果需要切换运行模式（CFRunLoopModeRef），只能退出Loop，再重新指定一个运行模式（CFRunLoopModeRef）进入。\n- 这样做主要是为了分隔开不同组的输入源（CFRunLoopSourceRef）、定时源（CFRunLoopTimerRef）、观察者（CFRunLoopObserverRef），让其互不影响 。\n\n##### 2.1 CFRunLoopRef\n\nCFRunLoopRef就是Core Foundation框架下RunLoop对象类。我们可通过以下方式来获取RunLoop对象：\n\n- Core Foundation\n  - `CFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象`\n  - `CFRunLoopGetMain(); // 获得主线程的RunLoop对象`\n\n当然，在Foundation框架下获取RunLoop对象类的方法如下：\n\n- Foundation\n  - `[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象`\n  - `[NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象`\n\n##### 2.2 CFRunLoopModeRef\n\n系统默认定义了多种运行模式（CFRunLoopModeRef），如下：\n\n- 1 **kCFRunLoopDefaultMode**：App的默认运行模式，通常主线程是在这个运行模式下运行\n- 2 **UITrackingRunLoopMode**：跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响）\n- 3 **UIInitializationRunLoopMode**：在刚启动App时第进入的第一个 Mode，启动完成后就不再使用\n- 4 **GSEventReceiveRunLoopMode**：接受系统内部事件，通常用不到\n- 5 **kCFRunLoopCommonModes**：伪模式，不是一种真正的运行模式（后边会用到）\n\n其中**kCFRunLoopDefaultMode**、**UITrackingRunLoopMode**、**kCFRunLoopCommonModes**是我们开发中需要用到的模式，具体使用方法我们在 **CFRunLoopTimerRef** 中结合CFRunLoopTimerRef来演示说明。\n\n##### 2.3 CFRunLoopTimerRef\n\nCFRunLoopTimerRef是定时源（RunLoop模型图中提到过），理解为基于时间的触发器，基本上就是NSTimer。\n\n下面我们来演示下CFRunLoopModeRef和CFRunLoopTimerRef结合的使用用法:\n\n- 1 首先我们新建一个iOS项目，在Main.storyboard中拖入一个Text View。\n\n- 2 在ViewController.m文件中加入以下代码\n\n  ```objective-c\n  // 定义一个定时器，约定两秒之后调用self的run方法\n  NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];\n\n  // 将定时器添加到当前RunLoop的NSDefaultRunLoopMode下\n  [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];\n\n  - (void)run\n  {\n      NSLog(@\"---run\");\n  }\n  ```\n\n- 3 然后运行，这时候我们发现如果我们不对模拟器进行任何操作的话，定时器会稳定的每隔2秒调用run方法打印。\n\n- 4 但是当我们拖动Text View滚动时，我们发现：run方法不打印了，也就是说NSTimer不工作了。而当我们松开鼠标的时候，NSTimer就又开始正常工作了。\n\n  原因：\n\n  - 当我们不做任何操作的时候，RunLoop处于NSDefaultRunLoopMode下。\n  - 而当我们拖动Text View的时候，RunLoop就结束NSDefaultRunLoopMode，切换到了UITrackingRunLoopMode模式下，这个模式下没有添加NSTimer，所以我们的NSTimer就不工作了。\n  - 但当我们松开鼠标的时候，RunLoop就结束UITrackingRunLoopMode模式，又切换回NSDefaultRunLoopMode模式，所以NSTimer就又开始正常工作了。\n\n你可以试着将上述代码中的`[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];`语句换为`[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];`，也就是将定时器添加到当前RunLoop的UITrackingRunLoopMode下，你就会发现定时器只会在拖动Text View的模式下工作，而不做操作的时候定时器就不工作。\n\n那难道我们就不能在这两种模式下让NSTimer都能正常工作吗？\n\n当然可以，这就用到了我们之前说过的**伪模式（kCFRunLoopCommonModes）**，这其实不是一种真实的模式，而是一种标记模式，意思就是可以在打上Common Modes标记的模式下运行。\n\n那么哪些模式被标记上了Common Modes呢？\n\n**NSDefaultRunLoopMode** 和 **UITrackingRunLoopMode**。\n\n所以我们只要我们将NSTimer添加到当前RunLoop的kCFRunLoopCommonModes（Foundation框架下为NSRunLoopCommonModes）下，我们就可以让NSTimer在不做操作和拖动Text View两种情况下愉快的正常工作了。\n\n具体做法就是讲添加语句改为`[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];`\n\n既然讲到了NSTimer，这里顺便讲下NSTimer中的`scheduledTimerWithTimeInterval`方法和RunLoop的关系。添加下面的代码：\n\n```objective-c\n[NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];\n```\n\n这句代码调用了scheduledTimer返回的定时器，NSTimer会自动被加入到了RunLoop的NSDefaultRunLoopMode模式下。这句代码相当于下面两句代码：\n\n```objective-c\nNSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];\n[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];\n```\n\n##### 2.4 CFRunLoopSourceRef\n\nCFRunLoopSourceRef是事件源（RunLoop模型图中提到过），CFRunLoopSourceRef有两种分类方法。\n\n- 第一种按照官方文档来分类（就像RunLoop模型图中那样）：\n  - Port-Based Sources（基于端口）\n  - Custom Input Sources（自定义）\n  - Cocoa Perform Selector Sources\n- 第二种按照函数调用栈来分类：\n  - Source0 ：非基于Port\n  - Source1：基于Port，通过内核和其他线程通信，接收、分发系统事件\n\n这两种分类方式其实没有区别，只不过第一种是通过官方理论来分类，第二种是在实际应用中通过调用函数来分类。\n\n下边我们举个例子大致来了解一下函数调用栈和Source。\n\n- 1 在我们的项目中的Main.storyboard中添加一个Button按钮，并添加点击动作。\n\n- 2 然后在点击动作的代码中加入一句输出语句，并打上断点，如下图所示：\n\n  ![1](NSRunLoop简介/2017_12_08RunLoop_3.png)\n\n- 3 然后运行程序，并点击按钮。\n\n- 4 然后在项目中单击下下图红色部分。\n\n  ![1](NSRunLoop简介/2017_12_08RunLoop_4.png)\n\n- 5 可以看到如下图所示就是点击事件产生的函数调用栈。\n\n  ![1](NSRunLoop简介/2017_12_08RunLoop_5.png)\n\n所以点击事件是这样来的：\n\n1. 首先程序启动，调用16行的main函数，main函数调用15行UIApplicationMain函数，然后一直往上调用函数，最终调用到0行的BtnClick函数，即点击函数。\n2. 同时我们可以看到11行中有Sources0，也就是说我们点击事件是属于Sources0函数的，点击事件就是在Sources0中处理的。\n3. 而至于Sources1，则是用来接收、分发系统事件，然后再分发到Sources0中处理的。\n\n##### 2.5 CFRunLoopObserverRef\n\nCFRunLoopObserverRef是观察者，用来监听RunLoop的状态改变\n\nCFRunLoopObserverRef可以监听的状态改变有以下几种：\n\n```objective-c\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry = (1UL << 0),               // 即将进入Loop：1\n    kCFRunLoopBeforeTimers = (1UL << 1),        // 即将处理Timer：2    \n    kCFRunLoopBeforeSources = (1UL << 2),       // 即将处理Source：4\n    kCFRunLoopBeforeWaiting = (1UL << 5),       // 即将进入休眠：32\n    kCFRunLoopAfterWaiting = (1UL << 6),        // 即将从休眠中唤醒：64\n    kCFRunLoopExit = (1UL << 7),                // 即将从Loop中退出：128\n    kCFRunLoopAllActivities = 0x0FFFFFFFU       // 监听全部状态改变  \n};\n```\n\n下边我们通过代码来监听下RunLoop中的状态改变。\n\n1. 在ViewController.m中添加如下代码\n\n   ```objective-c\n   // 创建观察者\n   CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {\n       NSLog(@\"监听到RunLoop发生改变---%zd\",activity);\n   });\n\n   // 添加观察者到当前RunLoop中\n   CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);\n\n   // 释放observer，最后添加完需要释放掉\n   CFRelease(observer);\n   ```\n\n2. 然后运行，看下打印结果，如下图。\n\n   ![1](NSRunLoop简介/2017_12_08RunLoop_6.png)\n\n   可以看到RunLoop的状态在不断的改变，最终变成了状态 32，也就是即将进入睡眠状态，说明RunLoop之后就会进入睡眠状态。\n\n#### 3  RunLoop原理\n\n下面我们就可以来理解RunLoop的运行逻辑了。\n\n![1](NSRunLoop简介/2017_12_08RunLoop_7.png)\n\n在每次运行开启RunLoop的时候，所在线程的RunLoop会自动处理之前未处理的事件，并且通知相关的观察者。\n\n具体的顺序如下：\n\n1. 通知观察者RunLoop已经启动\n2. 通知观察者即将要开始的定时器\n3. 通知观察者任何即将启动的非基于端口的源\n4. 启动任何准备好的非基于端口的源\n5. 如果基于端口的源准备好并处于等待状态，立即启动；并进入步骤9\n6. 通知观察者线程进入休眠状态\n7. 将线程置于休眠知道任一下面的事件发生：\n   - 某一事件到达基于端口的源\n   - 定时器启动\n   - RunLoop设置的时间已经超时\n   - RunLoop被显示唤醒\n8. 通知观察者线程将被唤醒\n9. 处理未处理的事件\n   - 如果用户定义的定时器启动，处理定时器事件并重启RunLoop。进入步骤2\n   - 如果输入源启动，传递相应的消息\n   - 如果RunLoop被显示唤醒而且时间还没超时，重启RunLoop。进入步骤2\n10. 通知观察者RunLoop结束。\n\n#### 4 RunLoop应用\n\n##### 4.1  NSTimer的使用\n\nNSTimer的使用方法在讲解`CFRunLoopTimerRef`类的时候详细讲解过，具体参考上边 **2.3 CFRunLoopTimerRef**。\n\n##### 4.2 ImageView推迟显示\n\n有时候，我们会遇到这种情况：\n当界面中含有UITableView，而且每个UITableViewCell里边都有图片。这时候当我们滚动UITableView的时候，如果有一堆的图片需要显示，那么可能会出现卡顿的现象。这时候，我们应该推迟图片的显示，也就是ImageView推迟显示图片。有两种方法：\n\n- 监听UIScrollView的滚动\n\n  因为UITableView继承自UIScrollView，所以我们可以通过监听UIScrollView的滚动，实现UIScrollView相关delegate即可。\n\n-  利用PerformSelector设置当前线程的RunLoop的运行模式\n\n  利用`performSelector`方法为UIImageView调用`setImage:`方法，并利用`inModes`将其设置为RunLoop下NSDefaultRunLoopMode运行模式。代码如下：\n\n  ```objective-c\n  [self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@\"tupian\"] afterDelay:4.0 inModes:NSDefaultRunLoopMode];\n  ```\n\n##### 4.3 后台常驻线程（很常用）\n\n我们在开发应用程序的过程中，如果后台操作特别频繁，经常会在子线程做一些耗时操作（下载文件、后台播放音乐等），我们最好能让这条线程永远常驻内存。\n\n添加一条用于常驻内存的强引用的子线程，在该线程的RunLoop下添加一个Sources，开启RunLoop。\n\n```\n// 创建线程，并调用run1方法执行任务\nself.thread = [[NSThread alloc] initWithTarget:self selector:@selector(run1) object:nil];\n// 开启线程\n[self.thread start];    \n\n- (void) run1\n{\n    // 这里写任务\n    NSLog(@\"----run1-----\");\n    // 添加下边两句代码，就可以开启RunLoop，之后self.thread就变成了常驻线程，可随时添加任务，并交于RunLoop处理\n    [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];\n    [[NSRunLoop currentRunLoop] run];\n    // 测试是否开启了RunLoop，如果开启RunLoop，则来不了这里，因为RunLoop开启了循环。\n    NSLog(@\"未开启RunLoop\");\n}\n```\n\n运行之后发现打印了**----run1-----**，而**未开启RunLoop**则未打印。","slug":"NSRunLoop简介","published":1,"updated":"2017-12-08T09:02:47.877Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb1u1v83000s1us0wrsfv685","content":"<h4 id=\"1-RunLoop简介\"><a href=\"#1-RunLoop简介\" class=\"headerlink\" title=\"1 RunLoop简介\"></a>1 RunLoop简介</h4><h5 id=\"1-1-什么是RunLoop？\"><a href=\"#1-1-什么是RunLoop？\" class=\"headerlink\" title=\"1.1 什么是RunLoop？\"></a>1.1 什么是RunLoop？</h5><p>可以理解为字面意思：Run表示运行，Loop表示循环。结合在一起就是运行的循环的意思。</p>\n<p>RunLoop实际上是一个对象，这个对象在循环中用来处理程序运行过程中出现的各种事件（比如说触摸事件、UI刷新事件、定时器事件、Selector事件），从而保持程序的持续运行；而且在没有事件处理的时候，会进入睡眠模式，从而节省CPU资源，提高程序性能。</p>\n<a id=\"more\"></a>\n<h5 id=\"1-2-RunLoop和线程\"><a href=\"#1-2-RunLoop和线程\" class=\"headerlink\" title=\"1.2 RunLoop和线程\"></a>1.2 RunLoop和线程</h5><p>RunLoop和线程是息息相关的，我们知道线程的作用是用来执行特定的一个或多个任务，但是在默认情况下，线程执行完之后就会退出，就不能再执行任务了。这时我们就需要采用一种方式来让线程能够处理任务，并不退出。所以，我们就有了RunLoop。</p>\n<ul>\n<li>1 一条线程对应一个RunLoop对象，每条线程都有唯一一个与之对应的RunLoop对象。</li>\n<li>2 我们只能在当前线程中操作当前线程的RunLoop，而不能去操作其他线程的RunLoop。</li>\n<li>3 RunLoop对象在第一次获取RunLoop时创建，销毁则是在线程结束的时候。</li>\n<li>4 主线程的RunLoop对象系统自动帮助我们创建好了(原理如下)，而子线程的RunLoop对象需要我们主动创建。</li>\n</ul>\n<h5 id=\"1-3-默认情况下主线程的RunLoop原理\"><a href=\"#1-3-默认情况下主线程的RunLoop原理\" class=\"headerlink\" title=\"1.3 默认情况下主线程的RunLoop原理\"></a>1.3 默认情况下主线程的RunLoop原理</h5><p>我们在启动一个iOS程序的时候，系统会调用创建项目时自动生成的main.m的文件。main.m文件如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main(int argc, char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中<code>UIApplicationMain</code>函数内部帮我们开启了主线程的RunLoop，<code>UIApplicationMain</code>内部拥有一个无线循环的代码。上边的代码中开启RunLoop的过程可以简单的理解为如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main(int argc, char * argv[]) &#123;        </span><br><span class=\"line\">    BOOL running = YES;</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">        // 执行各种任务，处理各种事件</span><br><span class=\"line\">        // ......</span><br><span class=\"line\">    &#125; while (running);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上边可看出，程序一直在do-while循环中执行，所以UIApplicationMain函数一直没有返回，我们在运行程序之后程序不会马上退出，会保持持续运行状态。</p>\n<p>下图是苹果官方给出的RunLoop模型图。</p>\n<p><img src=\"/2017/12/08/NSRunLoop简介/2017_12_08RunLoop_1.jpg\" alt=\"1\"></p>\n<p>从上图中可以看出，RunLoop就是线程中的一个循环，RunLoop在循环中会不断检测，通过Input sources（输入源）和Timer sources（定时源）两种来源等待接受事件；然后对接受到的事件通知线程进行处理，并在没有事件的时候进行休息。</p>\n<h4 id=\"2-RunLoop相关类\"><a href=\"#2-RunLoop相关类\" class=\"headerlink\" title=\"2 RunLoop相关类\"></a>2 RunLoop相关类</h4><p>下面我们来了解一下Core Foundation框架下关于RunLoop的5个类，只有弄懂这几个类的含义，我们才能深入了解RunLoop运行机制。</p>\n<ul>\n<li>1 CFRunLoopRef：代表RunLoop的对象</li>\n<li>2 CFRunLoopModeRef：RunLoop的运行模式</li>\n<li>3 CFRunLoopSourceRef：就是RunLoop模型图中提到的输入源/事件源</li>\n<li>4 CFRunLoopTimerRef：就是RunLoop模型图中提到的定时源</li>\n<li>5 CFRunLoopObserverRef：观察者，能够监听RunLoop的状态改变</li>\n</ul>\n<p>下边详细讲解下几种类的具体含义和关系。</p>\n<p><img src=\"/2017/12/08/NSRunLoop简介/2017_12_08RunLoop_2.png\" alt=\"1\"></p>\n<p>一个RunLoop对象（CFRunLoopRef）中包含若干个运行模式（CFRunLoopModeRef）。而每一个运行模式下又包含若干个输入源（CFRunLoopSourceRef）、定时源（CFRunLoopTimerRef）、观察者（CFRunLoopObserverRef）。</p>\n<ul>\n<li>每次RunLoop启动时，只能指定其中一个运行模式（CFRunLoopModeRef），这个运行模式（CFRunLoopModeRef）被称作CurrentMode。</li>\n<li>如果需要切换运行模式（CFRunLoopModeRef），只能退出Loop，再重新指定一个运行模式（CFRunLoopModeRef）进入。</li>\n<li>这样做主要是为了分隔开不同组的输入源（CFRunLoopSourceRef）、定时源（CFRunLoopTimerRef）、观察者（CFRunLoopObserverRef），让其互不影响 。</li>\n</ul>\n<h5 id=\"2-1-CFRunLoopRef\"><a href=\"#2-1-CFRunLoopRef\" class=\"headerlink\" title=\"2.1 CFRunLoopRef\"></a>2.1 CFRunLoopRef</h5><p>CFRunLoopRef就是Core Foundation框架下RunLoop对象类。我们可通过以下方式来获取RunLoop对象：</p>\n<ul>\n<li>Core Foundation<ul>\n<li><code>CFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象</code></li>\n<li><code>CFRunLoopGetMain(); // 获得主线程的RunLoop对象</code></li>\n</ul>\n</li>\n</ul>\n<p>当然，在Foundation框架下获取RunLoop对象类的方法如下：</p>\n<ul>\n<li>Foundation<ul>\n<li><code>[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象</code></li>\n<li><code>[NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象</code></li>\n</ul>\n</li>\n</ul>\n<h5 id=\"2-2-CFRunLoopModeRef\"><a href=\"#2-2-CFRunLoopModeRef\" class=\"headerlink\" title=\"2.2 CFRunLoopModeRef\"></a>2.2 CFRunLoopModeRef</h5><p>系统默认定义了多种运行模式（CFRunLoopModeRef），如下：</p>\n<ul>\n<li>1 <strong>kCFRunLoopDefaultMode</strong>：App的默认运行模式，通常主线程是在这个运行模式下运行</li>\n<li>2 <strong>UITrackingRunLoopMode</strong>：跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响）</li>\n<li>3 <strong>UIInitializationRunLoopMode</strong>：在刚启动App时第进入的第一个 Mode，启动完成后就不再使用</li>\n<li>4 <strong>GSEventReceiveRunLoopMode</strong>：接受系统内部事件，通常用不到</li>\n<li>5 <strong>kCFRunLoopCommonModes</strong>：伪模式，不是一种真正的运行模式（后边会用到）</li>\n</ul>\n<p>其中<strong>kCFRunLoopDefaultMode</strong>、<strong>UITrackingRunLoopMode</strong>、<strong>kCFRunLoopCommonModes</strong>是我们开发中需要用到的模式，具体使用方法我们在 <strong>CFRunLoopTimerRef</strong> 中结合CFRunLoopTimerRef来演示说明。</p>\n<h5 id=\"2-3-CFRunLoopTimerRef\"><a href=\"#2-3-CFRunLoopTimerRef\" class=\"headerlink\" title=\"2.3 CFRunLoopTimerRef\"></a>2.3 CFRunLoopTimerRef</h5><p>CFRunLoopTimerRef是定时源（RunLoop模型图中提到过），理解为基于时间的触发器，基本上就是NSTimer。</p>\n<p>下面我们来演示下CFRunLoopModeRef和CFRunLoopTimerRef结合的使用用法:</p>\n<ul>\n<li><p>1 首先我们新建一个iOS项目，在Main.storyboard中拖入一个Text View。</p>\n</li>\n<li><p>2 在ViewController.m文件中加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个定时器，约定两秒之后调用self的run方法</span><br><span class=\"line\">NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];</span><br><span class=\"line\"></span><br><span class=\"line\">// 将定时器添加到当前RunLoop的NSDefaultRunLoopMode下</span><br><span class=\"line\">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)run</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;---run&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3 然后运行，这时候我们发现如果我们不对模拟器进行任何操作的话，定时器会稳定的每隔2秒调用run方法打印。</p>\n</li>\n<li><p>4 但是当我们拖动Text View滚动时，我们发现：run方法不打印了，也就是说NSTimer不工作了。而当我们松开鼠标的时候，NSTimer就又开始正常工作了。</p>\n<p>原因：</p>\n<ul>\n<li>当我们不做任何操作的时候，RunLoop处于NSDefaultRunLoopMode下。</li>\n<li>而当我们拖动Text View的时候，RunLoop就结束NSDefaultRunLoopMode，切换到了UITrackingRunLoopMode模式下，这个模式下没有添加NSTimer，所以我们的NSTimer就不工作了。</li>\n<li>但当我们松开鼠标的时候，RunLoop就结束UITrackingRunLoopMode模式，又切换回NSDefaultRunLoopMode模式，所以NSTimer就又开始正常工作了。</li>\n</ul>\n</li>\n</ul>\n<p>你可以试着将上述代码中的<code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</code>语句换为<code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];</code>，也就是将定时器添加到当前RunLoop的UITrackingRunLoopMode下，你就会发现定时器只会在拖动Text View的模式下工作，而不做操作的时候定时器就不工作。</p>\n<p>那难道我们就不能在这两种模式下让NSTimer都能正常工作吗？</p>\n<p>当然可以，这就用到了我们之前说过的<strong>伪模式（kCFRunLoopCommonModes）</strong>，这其实不是一种真实的模式，而是一种标记模式，意思就是可以在打上Common Modes标记的模式下运行。</p>\n<p>那么哪些模式被标记上了Common Modes呢？</p>\n<p><strong>NSDefaultRunLoopMode</strong> 和 <strong>UITrackingRunLoopMode</strong>。</p>\n<p>所以我们只要我们将NSTimer添加到当前RunLoop的kCFRunLoopCommonModes（Foundation框架下为NSRunLoopCommonModes）下，我们就可以让NSTimer在不做操作和拖动Text View两种情况下愉快的正常工作了。</p>\n<p>具体做法就是讲添加语句改为<code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</code></p>\n<p>既然讲到了NSTimer，这里顺便讲下NSTimer中的<code>scheduledTimerWithTimeInterval</code>方法和RunLoop的关系。添加下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];</span><br></pre></td></tr></table></figure>\n<p>这句代码调用了scheduledTimer返回的定时器，NSTimer会自动被加入到了RunLoop的NSDefaultRunLoopMode模式下。这句代码相当于下面两句代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];</span><br><span class=\"line\">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-4-CFRunLoopSourceRef\"><a href=\"#2-4-CFRunLoopSourceRef\" class=\"headerlink\" title=\"2.4 CFRunLoopSourceRef\"></a>2.4 CFRunLoopSourceRef</h5><p>CFRunLoopSourceRef是事件源（RunLoop模型图中提到过），CFRunLoopSourceRef有两种分类方法。</p>\n<ul>\n<li>第一种按照官方文档来分类（就像RunLoop模型图中那样）：<ul>\n<li>Port-Based Sources（基于端口）</li>\n<li>Custom Input Sources（自定义）</li>\n<li>Cocoa Perform Selector Sources</li>\n</ul>\n</li>\n<li>第二种按照函数调用栈来分类：<ul>\n<li>Source0 ：非基于Port</li>\n<li>Source1：基于Port，通过内核和其他线程通信，接收、分发系统事件</li>\n</ul>\n</li>\n</ul>\n<p>这两种分类方式其实没有区别，只不过第一种是通过官方理论来分类，第二种是在实际应用中通过调用函数来分类。</p>\n<p>下边我们举个例子大致来了解一下函数调用栈和Source。</p>\n<ul>\n<li><p>1 在我们的项目中的Main.storyboard中添加一个Button按钮，并添加点击动作。</p>\n</li>\n<li><p>2 然后在点击动作的代码中加入一句输出语句，并打上断点，如下图所示：</p>\n<p><img src=\"/2017/12/08/NSRunLoop简介/2017_12_08RunLoop_3.png\" alt=\"1\"></p>\n</li>\n<li><p>3 然后运行程序，并点击按钮。</p>\n</li>\n<li><p>4 然后在项目中单击下下图红色部分。</p>\n<p><img src=\"/2017/12/08/NSRunLoop简介/2017_12_08RunLoop_4.png\" alt=\"1\"></p>\n</li>\n<li><p>5 可以看到如下图所示就是点击事件产生的函数调用栈。</p>\n<p><img src=\"/2017/12/08/NSRunLoop简介/2017_12_08RunLoop_5.png\" alt=\"1\"></p>\n</li>\n</ul>\n<p>所以点击事件是这样来的：</p>\n<ol>\n<li>首先程序启动，调用16行的main函数，main函数调用15行UIApplicationMain函数，然后一直往上调用函数，最终调用到0行的BtnClick函数，即点击函数。</li>\n<li>同时我们可以看到11行中有Sources0，也就是说我们点击事件是属于Sources0函数的，点击事件就是在Sources0中处理的。</li>\n<li>而至于Sources1，则是用来接收、分发系统事件，然后再分发到Sources0中处理的。</li>\n</ol>\n<h5 id=\"2-5-CFRunLoopObserverRef\"><a href=\"#2-5-CFRunLoopObserverRef\" class=\"headerlink\" title=\"2.5 CFRunLoopObserverRef\"></a>2.5 CFRunLoopObserverRef</h5><p>CFRunLoopObserverRef是观察者，用来监听RunLoop的状态改变</p>\n<p>CFRunLoopObserverRef可以监听的状态改变有以下几种：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class=\"line\">    kCFRunLoopEntry = (1UL &lt;&lt; 0),               // 即将进入Loop：1</span><br><span class=\"line\">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),        // 即将处理Timer：2    </span><br><span class=\"line\">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),       // 即将处理Source：4</span><br><span class=\"line\">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),       // 即将进入休眠：32</span><br><span class=\"line\">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),        // 即将从休眠中唤醒：64</span><br><span class=\"line\">    kCFRunLoopExit = (1UL &lt;&lt; 7),                // 即将从Loop中退出：128</span><br><span class=\"line\">    kCFRunLoopAllActivities = 0x0FFFFFFFU       // 监听全部状态改变  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>下边我们通过代码来监听下RunLoop中的状态改变。</p>\n<ol>\n<li><p>在ViewController.m中添加如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建观察者</span><br><span class=\"line\">CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class=\"line\">    NSLog(@&quot;监听到RunLoop发生改变---%zd&quot;,activity);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 添加观察者到当前RunLoop中</span><br><span class=\"line\">CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);</span><br><span class=\"line\"></span><br><span class=\"line\">// 释放observer，最后添加完需要释放掉</span><br><span class=\"line\">CFRelease(observer);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然后运行，看下打印结果，如下图。</p>\n<p><img src=\"/2017/12/08/NSRunLoop简介/2017_12_08RunLoop_6.png\" alt=\"1\"></p>\n<p>可以看到RunLoop的状态在不断的改变，最终变成了状态 32，也就是即将进入睡眠状态，说明RunLoop之后就会进入睡眠状态。</p>\n</li>\n</ol>\n<h4 id=\"3-RunLoop原理\"><a href=\"#3-RunLoop原理\" class=\"headerlink\" title=\"3  RunLoop原理\"></a>3  RunLoop原理</h4><p>下面我们就可以来理解RunLoop的运行逻辑了。</p>\n<p><img src=\"/2017/12/08/NSRunLoop简介/2017_12_08RunLoop_7.png\" alt=\"1\"></p>\n<p>在每次运行开启RunLoop的时候，所在线程的RunLoop会自动处理之前未处理的事件，并且通知相关的观察者。</p>\n<p>具体的顺序如下：</p>\n<ol>\n<li>通知观察者RunLoop已经启动</li>\n<li>通知观察者即将要开始的定时器</li>\n<li>通知观察者任何即将启动的非基于端口的源</li>\n<li>启动任何准备好的非基于端口的源</li>\n<li>如果基于端口的源准备好并处于等待状态，立即启动；并进入步骤9</li>\n<li>通知观察者线程进入休眠状态</li>\n<li>将线程置于休眠知道任一下面的事件发生：<ul>\n<li>某一事件到达基于端口的源</li>\n<li>定时器启动</li>\n<li>RunLoop设置的时间已经超时</li>\n<li>RunLoop被显示唤醒</li>\n</ul>\n</li>\n<li>通知观察者线程将被唤醒</li>\n<li>处理未处理的事件<ul>\n<li>如果用户定义的定时器启动，处理定时器事件并重启RunLoop。进入步骤2</li>\n<li>如果输入源启动，传递相应的消息</li>\n<li>如果RunLoop被显示唤醒而且时间还没超时，重启RunLoop。进入步骤2</li>\n</ul>\n</li>\n<li>通知观察者RunLoop结束。</li>\n</ol>\n<h4 id=\"4-RunLoop应用\"><a href=\"#4-RunLoop应用\" class=\"headerlink\" title=\"4 RunLoop应用\"></a>4 RunLoop应用</h4><h5 id=\"4-1-NSTimer的使用\"><a href=\"#4-1-NSTimer的使用\" class=\"headerlink\" title=\"4.1  NSTimer的使用\"></a>4.1  NSTimer的使用</h5><p>NSTimer的使用方法在讲解<code>CFRunLoopTimerRef</code>类的时候详细讲解过，具体参考上边 <strong>2.3 CFRunLoopTimerRef</strong>。</p>\n<h5 id=\"4-2-ImageView推迟显示\"><a href=\"#4-2-ImageView推迟显示\" class=\"headerlink\" title=\"4.2 ImageView推迟显示\"></a>4.2 ImageView推迟显示</h5><p>有时候，我们会遇到这种情况：<br>当界面中含有UITableView，而且每个UITableViewCell里边都有图片。这时候当我们滚动UITableView的时候，如果有一堆的图片需要显示，那么可能会出现卡顿的现象。这时候，我们应该推迟图片的显示，也就是ImageView推迟显示图片。有两种方法：</p>\n<ul>\n<li><p>监听UIScrollView的滚动</p>\n<p>因为UITableView继承自UIScrollView，所以我们可以通过监听UIScrollView的滚动，实现UIScrollView相关delegate即可。</p>\n</li>\n<li><p>利用PerformSelector设置当前线程的RunLoop的运行模式</p>\n<p>利用<code>performSelector</code>方法为UIImageView调用<code>setImage:</code>方法，并利用<code>inModes</code>将其设置为RunLoop下NSDefaultRunLoopMode运行模式。代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@&quot;tupian&quot;] afterDelay:4.0 inModes:NSDefaultRunLoopMode];</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"4-3-后台常驻线程（很常用）\"><a href=\"#4-3-后台常驻线程（很常用）\" class=\"headerlink\" title=\"4.3 后台常驻线程（很常用）\"></a>4.3 后台常驻线程（很常用）</h5><p>我们在开发应用程序的过程中，如果后台操作特别频繁，经常会在子线程做一些耗时操作（下载文件、后台播放音乐等），我们最好能让这条线程永远常驻内存。</p>\n<p>添加一条用于常驻内存的强引用的子线程，在该线程的RunLoop下添加一个Sources，开启RunLoop。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建线程，并调用run1方法执行任务</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.thread = [[<span class=\"built_in\">NSThread</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(run1) object:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"><span class=\"comment\">// 开启线程</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.thread start];    </span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>) run1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里写任务</span></span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"----run1-----\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 添加下边两句代码，就可以开启RunLoop，之后self.thread就变成了常驻线程，可随时添加任务，并交于RunLoop处理</span></span><br><span class=\"line\">    [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addPort:[<span class=\"built_in\">NSPort</span> port] forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</span><br><span class=\"line\">    [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] run];</span><br><span class=\"line\">    <span class=\"comment\">// 测试是否开启了RunLoop，如果开启RunLoop，则来不了这里，因为RunLoop开启了循环。</span></span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"未开启RunLoop\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行之后发现打印了<strong>—-run1—–</strong>，而<strong>未开启RunLoop</strong>则未打印。</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"1-RunLoop简介\"><a href=\"#1-RunLoop简介\" class=\"headerlink\" title=\"1 RunLoop简介\"></a>1 RunLoop简介</h4><h5 id=\"1-1-什么是RunLoop？\"><a href=\"#1-1-什么是RunLoop？\" class=\"headerlink\" title=\"1.1 什么是RunLoop？\"></a>1.1 什么是RunLoop？</h5><p>可以理解为字面意思：Run表示运行，Loop表示循环。结合在一起就是运行的循环的意思。</p>\n<p>RunLoop实际上是一个对象，这个对象在循环中用来处理程序运行过程中出现的各种事件（比如说触摸事件、UI刷新事件、定时器事件、Selector事件），从而保持程序的持续运行；而且在没有事件处理的时候，会进入睡眠模式，从而节省CPU资源，提高程序性能。</p>","more":"<h5 id=\"1-2-RunLoop和线程\"><a href=\"#1-2-RunLoop和线程\" class=\"headerlink\" title=\"1.2 RunLoop和线程\"></a>1.2 RunLoop和线程</h5><p>RunLoop和线程是息息相关的，我们知道线程的作用是用来执行特定的一个或多个任务，但是在默认情况下，线程执行完之后就会退出，就不能再执行任务了。这时我们就需要采用一种方式来让线程能够处理任务，并不退出。所以，我们就有了RunLoop。</p>\n<ul>\n<li>1 一条线程对应一个RunLoop对象，每条线程都有唯一一个与之对应的RunLoop对象。</li>\n<li>2 我们只能在当前线程中操作当前线程的RunLoop，而不能去操作其他线程的RunLoop。</li>\n<li>3 RunLoop对象在第一次获取RunLoop时创建，销毁则是在线程结束的时候。</li>\n<li>4 主线程的RunLoop对象系统自动帮助我们创建好了(原理如下)，而子线程的RunLoop对象需要我们主动创建。</li>\n</ul>\n<h5 id=\"1-3-默认情况下主线程的RunLoop原理\"><a href=\"#1-3-默认情况下主线程的RunLoop原理\" class=\"headerlink\" title=\"1.3 默认情况下主线程的RunLoop原理\"></a>1.3 默认情况下主线程的RunLoop原理</h5><p>我们在启动一个iOS程序的时候，系统会调用创建项目时自动生成的main.m的文件。main.m文件如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main(int argc, char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中<code>UIApplicationMain</code>函数内部帮我们开启了主线程的RunLoop，<code>UIApplicationMain</code>内部拥有一个无线循环的代码。上边的代码中开启RunLoop的过程可以简单的理解为如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main(int argc, char * argv[]) &#123;        </span><br><span class=\"line\">    BOOL running = YES;</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">        // 执行各种任务，处理各种事件</span><br><span class=\"line\">        // ......</span><br><span class=\"line\">    &#125; while (running);</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上边可看出，程序一直在do-while循环中执行，所以UIApplicationMain函数一直没有返回，我们在运行程序之后程序不会马上退出，会保持持续运行状态。</p>\n<p>下图是苹果官方给出的RunLoop模型图。</p>\n<p><img src=\"/2017/12/08/NSRunLoop简介/2017_12_08RunLoop_1.jpg\" alt=\"1\"></p>\n<p>从上图中可以看出，RunLoop就是线程中的一个循环，RunLoop在循环中会不断检测，通过Input sources（输入源）和Timer sources（定时源）两种来源等待接受事件；然后对接受到的事件通知线程进行处理，并在没有事件的时候进行休息。</p>\n<h4 id=\"2-RunLoop相关类\"><a href=\"#2-RunLoop相关类\" class=\"headerlink\" title=\"2 RunLoop相关类\"></a>2 RunLoop相关类</h4><p>下面我们来了解一下Core Foundation框架下关于RunLoop的5个类，只有弄懂这几个类的含义，我们才能深入了解RunLoop运行机制。</p>\n<ul>\n<li>1 CFRunLoopRef：代表RunLoop的对象</li>\n<li>2 CFRunLoopModeRef：RunLoop的运行模式</li>\n<li>3 CFRunLoopSourceRef：就是RunLoop模型图中提到的输入源/事件源</li>\n<li>4 CFRunLoopTimerRef：就是RunLoop模型图中提到的定时源</li>\n<li>5 CFRunLoopObserverRef：观察者，能够监听RunLoop的状态改变</li>\n</ul>\n<p>下边详细讲解下几种类的具体含义和关系。</p>\n<p><img src=\"/2017/12/08/NSRunLoop简介/2017_12_08RunLoop_2.png\" alt=\"1\"></p>\n<p>一个RunLoop对象（CFRunLoopRef）中包含若干个运行模式（CFRunLoopModeRef）。而每一个运行模式下又包含若干个输入源（CFRunLoopSourceRef）、定时源（CFRunLoopTimerRef）、观察者（CFRunLoopObserverRef）。</p>\n<ul>\n<li>每次RunLoop启动时，只能指定其中一个运行模式（CFRunLoopModeRef），这个运行模式（CFRunLoopModeRef）被称作CurrentMode。</li>\n<li>如果需要切换运行模式（CFRunLoopModeRef），只能退出Loop，再重新指定一个运行模式（CFRunLoopModeRef）进入。</li>\n<li>这样做主要是为了分隔开不同组的输入源（CFRunLoopSourceRef）、定时源（CFRunLoopTimerRef）、观察者（CFRunLoopObserverRef），让其互不影响 。</li>\n</ul>\n<h5 id=\"2-1-CFRunLoopRef\"><a href=\"#2-1-CFRunLoopRef\" class=\"headerlink\" title=\"2.1 CFRunLoopRef\"></a>2.1 CFRunLoopRef</h5><p>CFRunLoopRef就是Core Foundation框架下RunLoop对象类。我们可通过以下方式来获取RunLoop对象：</p>\n<ul>\n<li>Core Foundation<ul>\n<li><code>CFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象</code></li>\n<li><code>CFRunLoopGetMain(); // 获得主线程的RunLoop对象</code></li>\n</ul>\n</li>\n</ul>\n<p>当然，在Foundation框架下获取RunLoop对象类的方法如下：</p>\n<ul>\n<li>Foundation<ul>\n<li><code>[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象</code></li>\n<li><code>[NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象</code></li>\n</ul>\n</li>\n</ul>\n<h5 id=\"2-2-CFRunLoopModeRef\"><a href=\"#2-2-CFRunLoopModeRef\" class=\"headerlink\" title=\"2.2 CFRunLoopModeRef\"></a>2.2 CFRunLoopModeRef</h5><p>系统默认定义了多种运行模式（CFRunLoopModeRef），如下：</p>\n<ul>\n<li>1 <strong>kCFRunLoopDefaultMode</strong>：App的默认运行模式，通常主线程是在这个运行模式下运行</li>\n<li>2 <strong>UITrackingRunLoopMode</strong>：跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响）</li>\n<li>3 <strong>UIInitializationRunLoopMode</strong>：在刚启动App时第进入的第一个 Mode，启动完成后就不再使用</li>\n<li>4 <strong>GSEventReceiveRunLoopMode</strong>：接受系统内部事件，通常用不到</li>\n<li>5 <strong>kCFRunLoopCommonModes</strong>：伪模式，不是一种真正的运行模式（后边会用到）</li>\n</ul>\n<p>其中<strong>kCFRunLoopDefaultMode</strong>、<strong>UITrackingRunLoopMode</strong>、<strong>kCFRunLoopCommonModes</strong>是我们开发中需要用到的模式，具体使用方法我们在 <strong>CFRunLoopTimerRef</strong> 中结合CFRunLoopTimerRef来演示说明。</p>\n<h5 id=\"2-3-CFRunLoopTimerRef\"><a href=\"#2-3-CFRunLoopTimerRef\" class=\"headerlink\" title=\"2.3 CFRunLoopTimerRef\"></a>2.3 CFRunLoopTimerRef</h5><p>CFRunLoopTimerRef是定时源（RunLoop模型图中提到过），理解为基于时间的触发器，基本上就是NSTimer。</p>\n<p>下面我们来演示下CFRunLoopModeRef和CFRunLoopTimerRef结合的使用用法:</p>\n<ul>\n<li><p>1 首先我们新建一个iOS项目，在Main.storyboard中拖入一个Text View。</p>\n</li>\n<li><p>2 在ViewController.m文件中加入以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个定时器，约定两秒之后调用self的run方法</span><br><span class=\"line\">NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];</span><br><span class=\"line\"></span><br><span class=\"line\">// 将定时器添加到当前RunLoop的NSDefaultRunLoopMode下</span><br><span class=\"line\">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)run</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;---run&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>3 然后运行，这时候我们发现如果我们不对模拟器进行任何操作的话，定时器会稳定的每隔2秒调用run方法打印。</p>\n</li>\n<li><p>4 但是当我们拖动Text View滚动时，我们发现：run方法不打印了，也就是说NSTimer不工作了。而当我们松开鼠标的时候，NSTimer就又开始正常工作了。</p>\n<p>原因：</p>\n<ul>\n<li>当我们不做任何操作的时候，RunLoop处于NSDefaultRunLoopMode下。</li>\n<li>而当我们拖动Text View的时候，RunLoop就结束NSDefaultRunLoopMode，切换到了UITrackingRunLoopMode模式下，这个模式下没有添加NSTimer，所以我们的NSTimer就不工作了。</li>\n<li>但当我们松开鼠标的时候，RunLoop就结束UITrackingRunLoopMode模式，又切换回NSDefaultRunLoopMode模式，所以NSTimer就又开始正常工作了。</li>\n</ul>\n</li>\n</ul>\n<p>你可以试着将上述代码中的<code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</code>语句换为<code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];</code>，也就是将定时器添加到当前RunLoop的UITrackingRunLoopMode下，你就会发现定时器只会在拖动Text View的模式下工作，而不做操作的时候定时器就不工作。</p>\n<p>那难道我们就不能在这两种模式下让NSTimer都能正常工作吗？</p>\n<p>当然可以，这就用到了我们之前说过的<strong>伪模式（kCFRunLoopCommonModes）</strong>，这其实不是一种真实的模式，而是一种标记模式，意思就是可以在打上Common Modes标记的模式下运行。</p>\n<p>那么哪些模式被标记上了Common Modes呢？</p>\n<p><strong>NSDefaultRunLoopMode</strong> 和 <strong>UITrackingRunLoopMode</strong>。</p>\n<p>所以我们只要我们将NSTimer添加到当前RunLoop的kCFRunLoopCommonModes（Foundation框架下为NSRunLoopCommonModes）下，我们就可以让NSTimer在不做操作和拖动Text View两种情况下愉快的正常工作了。</p>\n<p>具体做法就是讲添加语句改为<code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</code></p>\n<p>既然讲到了NSTimer，这里顺便讲下NSTimer中的<code>scheduledTimerWithTimeInterval</code>方法和RunLoop的关系。添加下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];</span><br></pre></td></tr></table></figure>\n<p>这句代码调用了scheduledTimer返回的定时器，NSTimer会自动被加入到了RunLoop的NSDefaultRunLoopMode模式下。这句代码相当于下面两句代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];</span><br><span class=\"line\">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-4-CFRunLoopSourceRef\"><a href=\"#2-4-CFRunLoopSourceRef\" class=\"headerlink\" title=\"2.4 CFRunLoopSourceRef\"></a>2.4 CFRunLoopSourceRef</h5><p>CFRunLoopSourceRef是事件源（RunLoop模型图中提到过），CFRunLoopSourceRef有两种分类方法。</p>\n<ul>\n<li>第一种按照官方文档来分类（就像RunLoop模型图中那样）：<ul>\n<li>Port-Based Sources（基于端口）</li>\n<li>Custom Input Sources（自定义）</li>\n<li>Cocoa Perform Selector Sources</li>\n</ul>\n</li>\n<li>第二种按照函数调用栈来分类：<ul>\n<li>Source0 ：非基于Port</li>\n<li>Source1：基于Port，通过内核和其他线程通信，接收、分发系统事件</li>\n</ul>\n</li>\n</ul>\n<p>这两种分类方式其实没有区别，只不过第一种是通过官方理论来分类，第二种是在实际应用中通过调用函数来分类。</p>\n<p>下边我们举个例子大致来了解一下函数调用栈和Source。</p>\n<ul>\n<li><p>1 在我们的项目中的Main.storyboard中添加一个Button按钮，并添加点击动作。</p>\n</li>\n<li><p>2 然后在点击动作的代码中加入一句输出语句，并打上断点，如下图所示：</p>\n<p><img src=\"/2017/12/08/NSRunLoop简介/2017_12_08RunLoop_3.png\" alt=\"1\"></p>\n</li>\n<li><p>3 然后运行程序，并点击按钮。</p>\n</li>\n<li><p>4 然后在项目中单击下下图红色部分。</p>\n<p><img src=\"/2017/12/08/NSRunLoop简介/2017_12_08RunLoop_4.png\" alt=\"1\"></p>\n</li>\n<li><p>5 可以看到如下图所示就是点击事件产生的函数调用栈。</p>\n<p><img src=\"/2017/12/08/NSRunLoop简介/2017_12_08RunLoop_5.png\" alt=\"1\"></p>\n</li>\n</ul>\n<p>所以点击事件是这样来的：</p>\n<ol>\n<li>首先程序启动，调用16行的main函数，main函数调用15行UIApplicationMain函数，然后一直往上调用函数，最终调用到0行的BtnClick函数，即点击函数。</li>\n<li>同时我们可以看到11行中有Sources0，也就是说我们点击事件是属于Sources0函数的，点击事件就是在Sources0中处理的。</li>\n<li>而至于Sources1，则是用来接收、分发系统事件，然后再分发到Sources0中处理的。</li>\n</ol>\n<h5 id=\"2-5-CFRunLoopObserverRef\"><a href=\"#2-5-CFRunLoopObserverRef\" class=\"headerlink\" title=\"2.5 CFRunLoopObserverRef\"></a>2.5 CFRunLoopObserverRef</h5><p>CFRunLoopObserverRef是观察者，用来监听RunLoop的状态改变</p>\n<p>CFRunLoopObserverRef可以监听的状态改变有以下几种：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class=\"line\">    kCFRunLoopEntry = (1UL &lt;&lt; 0),               // 即将进入Loop：1</span><br><span class=\"line\">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),        // 即将处理Timer：2    </span><br><span class=\"line\">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),       // 即将处理Source：4</span><br><span class=\"line\">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),       // 即将进入休眠：32</span><br><span class=\"line\">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),        // 即将从休眠中唤醒：64</span><br><span class=\"line\">    kCFRunLoopExit = (1UL &lt;&lt; 7),                // 即将从Loop中退出：128</span><br><span class=\"line\">    kCFRunLoopAllActivities = 0x0FFFFFFFU       // 监听全部状态改变  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>下边我们通过代码来监听下RunLoop中的状态改变。</p>\n<ol>\n<li><p>在ViewController.m中添加如下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建观察者</span><br><span class=\"line\">CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class=\"line\">    NSLog(@&quot;监听到RunLoop发生改变---%zd&quot;,activity);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 添加观察者到当前RunLoop中</span><br><span class=\"line\">CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);</span><br><span class=\"line\"></span><br><span class=\"line\">// 释放observer，最后添加完需要释放掉</span><br><span class=\"line\">CFRelease(observer);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然后运行，看下打印结果，如下图。</p>\n<p><img src=\"/2017/12/08/NSRunLoop简介/2017_12_08RunLoop_6.png\" alt=\"1\"></p>\n<p>可以看到RunLoop的状态在不断的改变，最终变成了状态 32，也就是即将进入睡眠状态，说明RunLoop之后就会进入睡眠状态。</p>\n</li>\n</ol>\n<h4 id=\"3-RunLoop原理\"><a href=\"#3-RunLoop原理\" class=\"headerlink\" title=\"3  RunLoop原理\"></a>3  RunLoop原理</h4><p>下面我们就可以来理解RunLoop的运行逻辑了。</p>\n<p><img src=\"/2017/12/08/NSRunLoop简介/2017_12_08RunLoop_7.png\" alt=\"1\"></p>\n<p>在每次运行开启RunLoop的时候，所在线程的RunLoop会自动处理之前未处理的事件，并且通知相关的观察者。</p>\n<p>具体的顺序如下：</p>\n<ol>\n<li>通知观察者RunLoop已经启动</li>\n<li>通知观察者即将要开始的定时器</li>\n<li>通知观察者任何即将启动的非基于端口的源</li>\n<li>启动任何准备好的非基于端口的源</li>\n<li>如果基于端口的源准备好并处于等待状态，立即启动；并进入步骤9</li>\n<li>通知观察者线程进入休眠状态</li>\n<li>将线程置于休眠知道任一下面的事件发生：<ul>\n<li>某一事件到达基于端口的源</li>\n<li>定时器启动</li>\n<li>RunLoop设置的时间已经超时</li>\n<li>RunLoop被显示唤醒</li>\n</ul>\n</li>\n<li>通知观察者线程将被唤醒</li>\n<li>处理未处理的事件<ul>\n<li>如果用户定义的定时器启动，处理定时器事件并重启RunLoop。进入步骤2</li>\n<li>如果输入源启动，传递相应的消息</li>\n<li>如果RunLoop被显示唤醒而且时间还没超时，重启RunLoop。进入步骤2</li>\n</ul>\n</li>\n<li>通知观察者RunLoop结束。</li>\n</ol>\n<h4 id=\"4-RunLoop应用\"><a href=\"#4-RunLoop应用\" class=\"headerlink\" title=\"4 RunLoop应用\"></a>4 RunLoop应用</h4><h5 id=\"4-1-NSTimer的使用\"><a href=\"#4-1-NSTimer的使用\" class=\"headerlink\" title=\"4.1  NSTimer的使用\"></a>4.1  NSTimer的使用</h5><p>NSTimer的使用方法在讲解<code>CFRunLoopTimerRef</code>类的时候详细讲解过，具体参考上边 <strong>2.3 CFRunLoopTimerRef</strong>。</p>\n<h5 id=\"4-2-ImageView推迟显示\"><a href=\"#4-2-ImageView推迟显示\" class=\"headerlink\" title=\"4.2 ImageView推迟显示\"></a>4.2 ImageView推迟显示</h5><p>有时候，我们会遇到这种情况：<br>当界面中含有UITableView，而且每个UITableViewCell里边都有图片。这时候当我们滚动UITableView的时候，如果有一堆的图片需要显示，那么可能会出现卡顿的现象。这时候，我们应该推迟图片的显示，也就是ImageView推迟显示图片。有两种方法：</p>\n<ul>\n<li><p>监听UIScrollView的滚动</p>\n<p>因为UITableView继承自UIScrollView，所以我们可以通过监听UIScrollView的滚动，实现UIScrollView相关delegate即可。</p>\n</li>\n<li><p>利用PerformSelector设置当前线程的RunLoop的运行模式</p>\n<p>利用<code>performSelector</code>方法为UIImageView调用<code>setImage:</code>方法，并利用<code>inModes</code>将其设置为RunLoop下NSDefaultRunLoopMode运行模式。代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@&quot;tupian&quot;] afterDelay:4.0 inModes:NSDefaultRunLoopMode];</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"4-3-后台常驻线程（很常用）\"><a href=\"#4-3-后台常驻线程（很常用）\" class=\"headerlink\" title=\"4.3 后台常驻线程（很常用）\"></a>4.3 后台常驻线程（很常用）</h5><p>我们在开发应用程序的过程中，如果后台操作特别频繁，经常会在子线程做一些耗时操作（下载文件、后台播放音乐等），我们最好能让这条线程永远常驻内存。</p>\n<p>添加一条用于常驻内存的强引用的子线程，在该线程的RunLoop下添加一个Sources，开启RunLoop。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建线程，并调用run1方法执行任务</span></span><br><span class=\"line\"><span class=\"keyword\">self</span>.thread = [[<span class=\"built_in\">NSThread</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(run1) object:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"><span class=\"comment\">// 开启线程</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span>.thread start];    </span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>) run1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里写任务</span></span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"----run1-----\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 添加下边两句代码，就可以开启RunLoop，之后self.thread就变成了常驻线程，可随时添加任务，并交于RunLoop处理</span></span><br><span class=\"line\">    [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addPort:[<span class=\"built_in\">NSPort</span> port] forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</span><br><span class=\"line\">    [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] run];</span><br><span class=\"line\">    <span class=\"comment\">// 测试是否开启了RunLoop，如果开启RunLoop，则来不了这里，因为RunLoop开启了循环。</span></span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"未开启RunLoop\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行之后发现打印了<strong>—-run1—–</strong>，而<strong>未开启RunLoop</strong>则未打印。</p>"},{"title":"NSThread简介","date":"2017-12-10T06:12:00.000Z","_content":"\n#### 1 pthread\n\n​\tpthread简单介绍下，pthread是一套通用的多线程的API，可以在Unix / Linux / Windows 等系统跨平台使用，使用C语言编写，需要程序员自己管理线程的生命周期，使用难度较大，所以我们在iOS开发中几乎不使用pthread，简单了解下就可以了。\n\n>POSIX线程（英语：POSIX Threads，常被缩写为Pthreads）是POSIX的线程标准，定义了创建和操纵线程的一套API。实现POSIX 线程标准的库常被称作Pthreads，一般用于Unix-like POSIX 系统，如Linux、Solaris。但是Microsoft Windows上的实现也存在，例如直接使用Windows API实现的第三方库pthreads-w32；而利用Windows的SFU/SUA子系统，则可以使用微软提供的一部分原生POSIX API。\n\n<!-- more -->\n\n\n##### 1.1 pthread的使用方法\n\n- 首先要包含头文件`#import <pthread.h>`\n\n- 其次要创建线程，并开启线程执行任务\n\n  ```objective-c\n  // 创建线程——定义一个pthread_t类型变量\n  pthread_t thread;\n  // 开启线程——执行任务\n  pthread_create(&thread, NULL, run, NULL);\n\n  void * run(void *param)    // 新线程调用方法，里边为需要执行的任务\n  {\n      NSLog(@\"%@\", [NSThread currentThread]);\n\n      return NULL;\n  }\n  ```\n\n- `pthread_create(&thread, NULL, run, NULL);` 中各项参数含义：\n\n  - 第一个参数&thread是线程对象\n  - 第二个和第四个是线程属性，可赋值NULL\n  - 第三个run表示指向函数的指针(run对应函数里是需要在新线程中执行的任务)\n\n\n\n#### 2 NSThread\n\n​\tNSThread是苹果官方提供的，使用起来比pthread更加面向对象，简单易用，可以直接操作线程对象。不过也需要需要程序员自己管理线程的生命周期(主要是创建)，我们在开发的过程中偶尔使用NSThread。比如我们会经常调用[NSThread currentThread]来显示当前的进程信息。\n\n##### 2.1 创建、启动线程\n\n- 先创建线程，再启动线程\n\n  ```objective-c\n  NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];\n  [thread start];    // 线程一启动，就会在线程thread中执行self的run方法\n  ```\n\n- 创建线程后自动启动线程\n\n  ```objective-c\n  [NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];\n  ```\n\n- 隐式创建并启动线程\n\n  ```objective-c\n  [self performSelectorInBackground:@selector(run) withObject:nil];\n  ```\n\n##### 2.2  线程相关用法\n\n```objective-c\n// 获得主线程\n+ (NSThread *)mainThread;    \n\n// 判断是否为主线程(对象方法)\n- (BOOL)isMainThread;\n\n// 判断是否为主线程(类方法)\n+ (BOOL)isMainThread;    \n\n// 获得当前线程\nNSThread *current = [NSThread currentThread];\n\n// 线程的名字——setter方法\n- (void)setName:(NSString *)n;    \n\n// 线程的名字——getter方法\n- (NSString *)name;   \n```\n\n##### 2.3 线程状态控制方法\n\n- 启动线程方法\n\n  ```objective-c\n  // 线程进入就绪状态 -> 运行状态。当线程任务执行完毕，自动进入死亡状态\n  - (void)start;\n  ```\n\n- 阻塞（暂停）线程方法\n\n  ```objective-c\n  // 线程进入阻塞状态\n  + (void)sleepUntilDate:(NSDate *)date;\n  + (void)sleepForTimeInterval:(NSTimeInterval)ti;\n  ```\n\n- 强制停止线程\n\n  ```objective-c\n  // 线程进入死亡状态\n  + (void)exit;\n  ```\n\n##### 2.4 线程的状态转换\n\n​\t当我们新建一条线程`NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];`，在内存中的表现为：\n\n​\t![1](NSThread简介/2017_12_08_thread_one.png)\n\n​\t当调用`[thread start];`后，系统把线程对象放入可调度线程池中，线程对象进入就绪状态，如下图所示。\n\n![2](NSThread简介/2017_12_08_thread_two.png)\n\n​\t当然，可调度线程池中，会有其他的线程对象，如下图所示。在这里我们只关心左边的线程对象。\n\n![3](NSThread简介/2017_12_08_thread_three.png)\n\n**下边我们来看看当前线程的状态转换。**\n\n- 如果CPU现在调度当前线程对象，则当前线程对象进入运行状态，如果CPU调度其他线程对象，则当前线程对象回到就绪状态。\n\n\n- 如果CPU在运行当前线程对象的时候调用了sleep方法\\等待同步锁，则当前线程对象就进入了阻塞状态，等到sleep到时\\得到同步锁，则回到就绪状态。\n\n\n- 如果CPU在运行当前线程对象的时候线程任务执行完毕\\异常强制退出，则当前线程对象进入死亡状态。\n\n![4](NSThread简介/2017_12_08_thread_four.png)\n\n#### 3 线程同步\n\n##### 3.1 第一种方式@synchronized(对象)关键字\n\n```objective-c\n-(void)taskRun\n{\n    while (count>0) {\n        @synchronized(self) { // 需要锁定的代码\n            [NSThread sleepForTimeInterval:0.1];\n            count--;\n            NSLog(@\"threadName:%@ count:%d \",[NSThread currentThread].name, count);\n        }\n    }\n}\n```\n\n##### 3.2 第二种方式NSLock同步锁\n\n```objective-c\nthreadLock = [[NSLock alloc] init];\n```\n\n然后在需要加锁的代码块开始时调用 lock函数 在结束时调用unLock函数\n\n```objective-c\n-(void)taskRun\n{\n    while (count>0) {\n        [threadLock lock];\n        [NSThread sleepForTimeInterval:0.1];\n        count--;\n        NSLog(@\"threadName:%@ count:%d \",[NSThread currentThread].name, count);\n    }\n    [threadLock unlock];\n}\n```\n\n##### 3.3 第三种方式使用NSCondition同步锁和线程检查器\n\n​\t锁主要为了当检测条件时保护数据源，执行条件引发的任务；线程检查器主要是根据条件决定是否继续运行线程，即线程是否被阻塞。先创建一个NSCondition对象\n\n```objective-c\ncondition = [[NSCondition alloc] init];\n```\n\n使用同步锁的方式和NSLock相似\n\n```objective-c\n-(void)taskRun\n{\n    while (count>0) {\n        [condition lock];\n        [NSThread sleepForTimeInterval:0.1];\n        count--;\n        NSLog(@\"threadName:%@ count:%d \",[NSThread currentThread].name, count);\n        [condition unlock];\n    }\n}\n```\nNSCondition可以让线程进行等待，然后获取到CPU发信号告诉线程不用在等待，可以继续执行，上述的例子我们稍作修改，我们让线程三专门用于发送信号源\n\n```objective-c\nNSThread *thread1=[[NSThread alloc]initWithTarget:self selector:@selector(taskRun) object:nil];\nthread1.name=@\"thread-1\";\n\nNSThread *thread2=[[NSThread alloc]initWithTarget:self selector:@selector(taskRun) object:nil];\nthread2.name=@\"thread-2\";\n\nNSThread *thread3=[[NSThread alloc]initWithTarget:self selector:@selector(taskRun1) object:nil];\nthread3.name=@\"thread-3\";\n\n[thread1 start];\n[thread2 start];\n[thread3 start];\n```\n\ntaskRun1函数用于发送信号源\n\n```objective-c\n-(void)taskRun1\n{\n    while (YES) {\n        [condition lock];\n        [NSThread sleepForTimeInterval:2];\n        [condition signal];\n        [condition unlock];\n    }\n}\n```\n\ntaskRun函数 用于执行对count的操作\n\n```objective-c\n-(void)taskRun\n{\n    while (count>0) {\n        [condition lock];\n        [condition wait];\n        [NSThread sleepForTimeInterval:0.1];\n        count--;\n        NSLog(@\"threadName:%@ count:%d \",[NSThread currentThread].name, count);\n        [condition unlock];\n    }\n}\n```\n\n执行的结果会发现，只有在Thread-1、和Thread-2 收到信号源的时候才会执行count--，否则一直出于等待状态。\n\n\n\n转载自[iOS多线程--彻底学会多线程](http://www.jianshu.com/p/cbaeea5368b1)","source":"_posts/NSThread简介.md","raw":"---\ntitle: NSThread简介\ndate: 2017-12-10 14:12\ntags: iOS\ncategories: iOS Tips\n---\n\n#### 1 pthread\n\n​\tpthread简单介绍下，pthread是一套通用的多线程的API，可以在Unix / Linux / Windows 等系统跨平台使用，使用C语言编写，需要程序员自己管理线程的生命周期，使用难度较大，所以我们在iOS开发中几乎不使用pthread，简单了解下就可以了。\n\n>POSIX线程（英语：POSIX Threads，常被缩写为Pthreads）是POSIX的线程标准，定义了创建和操纵线程的一套API。实现POSIX 线程标准的库常被称作Pthreads，一般用于Unix-like POSIX 系统，如Linux、Solaris。但是Microsoft Windows上的实现也存在，例如直接使用Windows API实现的第三方库pthreads-w32；而利用Windows的SFU/SUA子系统，则可以使用微软提供的一部分原生POSIX API。\n\n<!-- more -->\n\n\n##### 1.1 pthread的使用方法\n\n- 首先要包含头文件`#import <pthread.h>`\n\n- 其次要创建线程，并开启线程执行任务\n\n  ```objective-c\n  // 创建线程——定义一个pthread_t类型变量\n  pthread_t thread;\n  // 开启线程——执行任务\n  pthread_create(&thread, NULL, run, NULL);\n\n  void * run(void *param)    // 新线程调用方法，里边为需要执行的任务\n  {\n      NSLog(@\"%@\", [NSThread currentThread]);\n\n      return NULL;\n  }\n  ```\n\n- `pthread_create(&thread, NULL, run, NULL);` 中各项参数含义：\n\n  - 第一个参数&thread是线程对象\n  - 第二个和第四个是线程属性，可赋值NULL\n  - 第三个run表示指向函数的指针(run对应函数里是需要在新线程中执行的任务)\n\n\n\n#### 2 NSThread\n\n​\tNSThread是苹果官方提供的，使用起来比pthread更加面向对象，简单易用，可以直接操作线程对象。不过也需要需要程序员自己管理线程的生命周期(主要是创建)，我们在开发的过程中偶尔使用NSThread。比如我们会经常调用[NSThread currentThread]来显示当前的进程信息。\n\n##### 2.1 创建、启动线程\n\n- 先创建线程，再启动线程\n\n  ```objective-c\n  NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];\n  [thread start];    // 线程一启动，就会在线程thread中执行self的run方法\n  ```\n\n- 创建线程后自动启动线程\n\n  ```objective-c\n  [NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];\n  ```\n\n- 隐式创建并启动线程\n\n  ```objective-c\n  [self performSelectorInBackground:@selector(run) withObject:nil];\n  ```\n\n##### 2.2  线程相关用法\n\n```objective-c\n// 获得主线程\n+ (NSThread *)mainThread;    \n\n// 判断是否为主线程(对象方法)\n- (BOOL)isMainThread;\n\n// 判断是否为主线程(类方法)\n+ (BOOL)isMainThread;    \n\n// 获得当前线程\nNSThread *current = [NSThread currentThread];\n\n// 线程的名字——setter方法\n- (void)setName:(NSString *)n;    \n\n// 线程的名字——getter方法\n- (NSString *)name;   \n```\n\n##### 2.3 线程状态控制方法\n\n- 启动线程方法\n\n  ```objective-c\n  // 线程进入就绪状态 -> 运行状态。当线程任务执行完毕，自动进入死亡状态\n  - (void)start;\n  ```\n\n- 阻塞（暂停）线程方法\n\n  ```objective-c\n  // 线程进入阻塞状态\n  + (void)sleepUntilDate:(NSDate *)date;\n  + (void)sleepForTimeInterval:(NSTimeInterval)ti;\n  ```\n\n- 强制停止线程\n\n  ```objective-c\n  // 线程进入死亡状态\n  + (void)exit;\n  ```\n\n##### 2.4 线程的状态转换\n\n​\t当我们新建一条线程`NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];`，在内存中的表现为：\n\n​\t![1](NSThread简介/2017_12_08_thread_one.png)\n\n​\t当调用`[thread start];`后，系统把线程对象放入可调度线程池中，线程对象进入就绪状态，如下图所示。\n\n![2](NSThread简介/2017_12_08_thread_two.png)\n\n​\t当然，可调度线程池中，会有其他的线程对象，如下图所示。在这里我们只关心左边的线程对象。\n\n![3](NSThread简介/2017_12_08_thread_three.png)\n\n**下边我们来看看当前线程的状态转换。**\n\n- 如果CPU现在调度当前线程对象，则当前线程对象进入运行状态，如果CPU调度其他线程对象，则当前线程对象回到就绪状态。\n\n\n- 如果CPU在运行当前线程对象的时候调用了sleep方法\\等待同步锁，则当前线程对象就进入了阻塞状态，等到sleep到时\\得到同步锁，则回到就绪状态。\n\n\n- 如果CPU在运行当前线程对象的时候线程任务执行完毕\\异常强制退出，则当前线程对象进入死亡状态。\n\n![4](NSThread简介/2017_12_08_thread_four.png)\n\n#### 3 线程同步\n\n##### 3.1 第一种方式@synchronized(对象)关键字\n\n```objective-c\n-(void)taskRun\n{\n    while (count>0) {\n        @synchronized(self) { // 需要锁定的代码\n            [NSThread sleepForTimeInterval:0.1];\n            count--;\n            NSLog(@\"threadName:%@ count:%d \",[NSThread currentThread].name, count);\n        }\n    }\n}\n```\n\n##### 3.2 第二种方式NSLock同步锁\n\n```objective-c\nthreadLock = [[NSLock alloc] init];\n```\n\n然后在需要加锁的代码块开始时调用 lock函数 在结束时调用unLock函数\n\n```objective-c\n-(void)taskRun\n{\n    while (count>0) {\n        [threadLock lock];\n        [NSThread sleepForTimeInterval:0.1];\n        count--;\n        NSLog(@\"threadName:%@ count:%d \",[NSThread currentThread].name, count);\n    }\n    [threadLock unlock];\n}\n```\n\n##### 3.3 第三种方式使用NSCondition同步锁和线程检查器\n\n​\t锁主要为了当检测条件时保护数据源，执行条件引发的任务；线程检查器主要是根据条件决定是否继续运行线程，即线程是否被阻塞。先创建一个NSCondition对象\n\n```objective-c\ncondition = [[NSCondition alloc] init];\n```\n\n使用同步锁的方式和NSLock相似\n\n```objective-c\n-(void)taskRun\n{\n    while (count>0) {\n        [condition lock];\n        [NSThread sleepForTimeInterval:0.1];\n        count--;\n        NSLog(@\"threadName:%@ count:%d \",[NSThread currentThread].name, count);\n        [condition unlock];\n    }\n}\n```\nNSCondition可以让线程进行等待，然后获取到CPU发信号告诉线程不用在等待，可以继续执行，上述的例子我们稍作修改，我们让线程三专门用于发送信号源\n\n```objective-c\nNSThread *thread1=[[NSThread alloc]initWithTarget:self selector:@selector(taskRun) object:nil];\nthread1.name=@\"thread-1\";\n\nNSThread *thread2=[[NSThread alloc]initWithTarget:self selector:@selector(taskRun) object:nil];\nthread2.name=@\"thread-2\";\n\nNSThread *thread3=[[NSThread alloc]initWithTarget:self selector:@selector(taskRun1) object:nil];\nthread3.name=@\"thread-3\";\n\n[thread1 start];\n[thread2 start];\n[thread3 start];\n```\n\ntaskRun1函数用于发送信号源\n\n```objective-c\n-(void)taskRun1\n{\n    while (YES) {\n        [condition lock];\n        [NSThread sleepForTimeInterval:2];\n        [condition signal];\n        [condition unlock];\n    }\n}\n```\n\ntaskRun函数 用于执行对count的操作\n\n```objective-c\n-(void)taskRun\n{\n    while (count>0) {\n        [condition lock];\n        [condition wait];\n        [NSThread sleepForTimeInterval:0.1];\n        count--;\n        NSLog(@\"threadName:%@ count:%d \",[NSThread currentThread].name, count);\n        [condition unlock];\n    }\n}\n```\n\n执行的结果会发现，只有在Thread-1、和Thread-2 收到信号源的时候才会执行count--，否则一直出于等待状态。\n\n\n\n转载自[iOS多线程--彻底学会多线程](http://www.jianshu.com/p/cbaeea5368b1)","slug":"NSThread简介","published":1,"updated":"2017-12-08T09:27:09.831Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb1u1v85000v1us0ozy2zpff","content":"<h4 id=\"1-pthread\"><a href=\"#1-pthread\" class=\"headerlink\" title=\"1 pthread\"></a>1 pthread</h4><p>​    pthread简单介绍下，pthread是一套通用的多线程的API，可以在Unix / Linux / Windows 等系统跨平台使用，使用C语言编写，需要程序员自己管理线程的生命周期，使用难度较大，所以我们在iOS开发中几乎不使用pthread，简单了解下就可以了。</p>\n<blockquote>\n<p>POSIX线程（英语：POSIX Threads，常被缩写为Pthreads）是POSIX的线程标准，定义了创建和操纵线程的一套API。实现POSIX 线程标准的库常被称作Pthreads，一般用于Unix-like POSIX 系统，如Linux、Solaris。但是Microsoft Windows上的实现也存在，例如直接使用Windows API实现的第三方库pthreads-w32；而利用Windows的SFU/SUA子系统，则可以使用微软提供的一部分原生POSIX API。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h5 id=\"1-1-pthread的使用方法\"><a href=\"#1-1-pthread的使用方法\" class=\"headerlink\" title=\"1.1 pthread的使用方法\"></a>1.1 pthread的使用方法</h5><ul>\n<li><p>首先要包含头文件<code>#import &lt;pthread.h&gt;</code></p>\n</li>\n<li><p>其次要创建线程，并开启线程执行任务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建线程——定义一个pthread_t类型变量</span><br><span class=\"line\">pthread_t thread;</span><br><span class=\"line\">// 开启线程——执行任务</span><br><span class=\"line\">pthread_create(&amp;thread, NULL, run, NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">void * run(void *param)    // 新线程调用方法，里边为需要执行的任务</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">    return NULL;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>pthread_create(&amp;thread, NULL, run, NULL);</code> 中各项参数含义：</p>\n<ul>\n<li>第一个参数&amp;thread是线程对象</li>\n<li>第二个和第四个是线程属性，可赋值NULL</li>\n<li>第三个run表示指向函数的指针(run对应函数里是需要在新线程中执行的任务)</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-NSThread\"><a href=\"#2-NSThread\" class=\"headerlink\" title=\"2 NSThread\"></a>2 NSThread</h4><p>​    NSThread是苹果官方提供的，使用起来比pthread更加面向对象，简单易用，可以直接操作线程对象。不过也需要需要程序员自己管理线程的生命周期(主要是创建)，我们在开发的过程中偶尔使用NSThread。比如我们会经常调用[NSThread currentThread]来显示当前的进程信息。</p>\n<h5 id=\"2-1-创建、启动线程\"><a href=\"#2-1-创建、启动线程\" class=\"headerlink\" title=\"2.1 创建、启动线程\"></a>2.1 创建、启动线程</h5><ul>\n<li><p>先创建线程，再启动线程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];</span><br><span class=\"line\">[thread start];    // 线程一启动，就会在线程thread中执行self的run方法</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建线程后自动启动线程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>隐式创建并启动线程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self performSelectorInBackground:@selector(run) withObject:nil];</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"2-2-线程相关用法\"><a href=\"#2-2-线程相关用法\" class=\"headerlink\" title=\"2.2  线程相关用法\"></a>2.2  线程相关用法</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获得主线程</span><br><span class=\"line\">+ (NSThread *)mainThread;    </span><br><span class=\"line\"></span><br><span class=\"line\">// 判断是否为主线程(对象方法)</span><br><span class=\"line\">- (BOOL)isMainThread;</span><br><span class=\"line\"></span><br><span class=\"line\">// 判断是否为主线程(类方法)</span><br><span class=\"line\">+ (BOOL)isMainThread;    </span><br><span class=\"line\"></span><br><span class=\"line\">// 获得当前线程</span><br><span class=\"line\">NSThread *current = [NSThread currentThread];</span><br><span class=\"line\"></span><br><span class=\"line\">// 线程的名字——setter方法</span><br><span class=\"line\">- (void)setName:(NSString *)n;    </span><br><span class=\"line\"></span><br><span class=\"line\">// 线程的名字——getter方法</span><br><span class=\"line\">- (NSString *)name;</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-3-线程状态控制方法\"><a href=\"#2-3-线程状态控制方法\" class=\"headerlink\" title=\"2.3 线程状态控制方法\"></a>2.3 线程状态控制方法</h5><ul>\n<li><p>启动线程方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 线程进入就绪状态 -&gt; 运行状态。当线程任务执行完毕，自动进入死亡状态</span><br><span class=\"line\">- (void)start;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>阻塞（暂停）线程方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 线程进入阻塞状态</span><br><span class=\"line\">+ (void)sleepUntilDate:(NSDate *)date;</span><br><span class=\"line\">+ (void)sleepForTimeInterval:(NSTimeInterval)ti;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>强制停止线程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 线程进入死亡状态</span><br><span class=\"line\">+ (void)exit;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"2-4-线程的状态转换\"><a href=\"#2-4-线程的状态转换\" class=\"headerlink\" title=\"2.4 线程的状态转换\"></a>2.4 线程的状态转换</h5><p>​    当我们新建一条线程<code>NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];</code>，在内存中的表现为：</p>\n<p>​    <img src=\"/2017/12/10/NSThread简介/2017_12_08_thread_one.png\" alt=\"1\"></p>\n<p>​    当调用<code>[thread start];</code>后，系统把线程对象放入可调度线程池中，线程对象进入就绪状态，如下图所示。</p>\n<p><img src=\"/2017/12/10/NSThread简介/2017_12_08_thread_two.png\" alt=\"2\"></p>\n<p>​    当然，可调度线程池中，会有其他的线程对象，如下图所示。在这里我们只关心左边的线程对象。</p>\n<p><img src=\"/2017/12/10/NSThread简介/2017_12_08_thread_three.png\" alt=\"3\"></p>\n<p><strong>下边我们来看看当前线程的状态转换。</strong></p>\n<ul>\n<li>如果CPU现在调度当前线程对象，则当前线程对象进入运行状态，如果CPU调度其他线程对象，则当前线程对象回到就绪状态。</li>\n</ul>\n<ul>\n<li>如果CPU在运行当前线程对象的时候调用了sleep方法\\等待同步锁，则当前线程对象就进入了阻塞状态，等到sleep到时\\得到同步锁，则回到就绪状态。</li>\n</ul>\n<ul>\n<li>如果CPU在运行当前线程对象的时候线程任务执行完毕\\异常强制退出，则当前线程对象进入死亡状态。</li>\n</ul>\n<p><img src=\"/2017/12/10/NSThread简介/2017_12_08_thread_four.png\" alt=\"4\"></p>\n<h4 id=\"3-线程同步\"><a href=\"#3-线程同步\" class=\"headerlink\" title=\"3 线程同步\"></a>3 线程同步</h4><h5 id=\"3-1-第一种方式-synchronized-对象-关键字\"><a href=\"#3-1-第一种方式-synchronized-对象-关键字\" class=\"headerlink\" title=\"3.1 第一种方式@synchronized(对象)关键字\"></a>3.1 第一种方式@synchronized(对象)关键字</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(void)taskRun</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    while (count&gt;0) &#123;</span><br><span class=\"line\">        @synchronized(self) &#123; // 需要锁定的代码</span><br><span class=\"line\">            [NSThread sleepForTimeInterval:0.1];</span><br><span class=\"line\">            count--;</span><br><span class=\"line\">            NSLog(@&quot;threadName:%@ count:%d &quot;,[NSThread currentThread].name, count);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"3-2-第二种方式NSLock同步锁\"><a href=\"#3-2-第二种方式NSLock同步锁\" class=\"headerlink\" title=\"3.2 第二种方式NSLock同步锁\"></a>3.2 第二种方式NSLock同步锁</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">threadLock = [[NSLock alloc] init];</span><br></pre></td></tr></table></figure>\n<p>然后在需要加锁的代码块开始时调用 lock函数 在结束时调用unLock函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(void)taskRun</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    while (count&gt;0) &#123;</span><br><span class=\"line\">        [threadLock lock];</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:0.1];</span><br><span class=\"line\">        count--;</span><br><span class=\"line\">        NSLog(@&quot;threadName:%@ count:%d &quot;,[NSThread currentThread].name, count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [threadLock unlock];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"3-3-第三种方式使用NSCondition同步锁和线程检查器\"><a href=\"#3-3-第三种方式使用NSCondition同步锁和线程检查器\" class=\"headerlink\" title=\"3.3 第三种方式使用NSCondition同步锁和线程检查器\"></a>3.3 第三种方式使用NSCondition同步锁和线程检查器</h5><p>​    锁主要为了当检测条件时保护数据源，执行条件引发的任务；线程检查器主要是根据条件决定是否继续运行线程，即线程是否被阻塞。先创建一个NSCondition对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">condition = [[NSCondition alloc] init];</span><br></pre></td></tr></table></figure>\n<p>使用同步锁的方式和NSLock相似</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(void)taskRun</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    while (count&gt;0) &#123;</span><br><span class=\"line\">        [condition lock];</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:0.1];</span><br><span class=\"line\">        count--;</span><br><span class=\"line\">        NSLog(@&quot;threadName:%@ count:%d &quot;,[NSThread currentThread].name, count);</span><br><span class=\"line\">        [condition unlock];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>NSCondition可以让线程进行等待，然后获取到CPU发信号告诉线程不用在等待，可以继续执行，上述的例子我们稍作修改，我们让线程三专门用于发送信号源</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSThread *thread1=[[NSThread alloc]initWithTarget:self selector:@selector(taskRun) object:nil];</span><br><span class=\"line\">thread1.name=@&quot;thread-1&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">NSThread *thread2=[[NSThread alloc]initWithTarget:self selector:@selector(taskRun) object:nil];</span><br><span class=\"line\">thread2.name=@&quot;thread-2&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">NSThread *thread3=[[NSThread alloc]initWithTarget:self selector:@selector(taskRun1) object:nil];</span><br><span class=\"line\">thread3.name=@&quot;thread-3&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">[thread1 start];</span><br><span class=\"line\">[thread2 start];</span><br><span class=\"line\">[thread3 start];</span><br></pre></td></tr></table></figure>\n<p>taskRun1函数用于发送信号源</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(void)taskRun1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    while (YES) &#123;</span><br><span class=\"line\">        [condition lock];</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">        [condition signal];</span><br><span class=\"line\">        [condition unlock];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>taskRun函数 用于执行对count的操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(void)taskRun</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    while (count&gt;0) &#123;</span><br><span class=\"line\">        [condition lock];</span><br><span class=\"line\">        [condition wait];</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:0.1];</span><br><span class=\"line\">        count--;</span><br><span class=\"line\">        NSLog(@&quot;threadName:%@ count:%d &quot;,[NSThread currentThread].name, count);</span><br><span class=\"line\">        [condition unlock];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行的结果会发现，只有在Thread-1、和Thread-2 收到信号源的时候才会执行count–，否则一直出于等待状态。</p>\n<p>转载自<a href=\"http://www.jianshu.com/p/cbaeea5368b1\" target=\"_blank\" rel=\"noopener\">iOS多线程–彻底学会多线程</a></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"1-pthread\"><a href=\"#1-pthread\" class=\"headerlink\" title=\"1 pthread\"></a>1 pthread</h4><p>​    pthread简单介绍下，pthread是一套通用的多线程的API，可以在Unix / Linux / Windows 等系统跨平台使用，使用C语言编写，需要程序员自己管理线程的生命周期，使用难度较大，所以我们在iOS开发中几乎不使用pthread，简单了解下就可以了。</p>\n<blockquote>\n<p>POSIX线程（英语：POSIX Threads，常被缩写为Pthreads）是POSIX的线程标准，定义了创建和操纵线程的一套API。实现POSIX 线程标准的库常被称作Pthreads，一般用于Unix-like POSIX 系统，如Linux、Solaris。但是Microsoft Windows上的实现也存在，例如直接使用Windows API实现的第三方库pthreads-w32；而利用Windows的SFU/SUA子系统，则可以使用微软提供的一部分原生POSIX API。</p>\n</blockquote>","more":"<h5 id=\"1-1-pthread的使用方法\"><a href=\"#1-1-pthread的使用方法\" class=\"headerlink\" title=\"1.1 pthread的使用方法\"></a>1.1 pthread的使用方法</h5><ul>\n<li><p>首先要包含头文件<code>#import &lt;pthread.h&gt;</code></p>\n</li>\n<li><p>其次要创建线程，并开启线程执行任务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建线程——定义一个pthread_t类型变量</span><br><span class=\"line\">pthread_t thread;</span><br><span class=\"line\">// 开启线程——执行任务</span><br><span class=\"line\">pthread_create(&amp;thread, NULL, run, NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">void * run(void *param)    // 新线程调用方法，里边为需要执行的任务</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">    return NULL;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>pthread_create(&amp;thread, NULL, run, NULL);</code> 中各项参数含义：</p>\n<ul>\n<li>第一个参数&amp;thread是线程对象</li>\n<li>第二个和第四个是线程属性，可赋值NULL</li>\n<li>第三个run表示指向函数的指针(run对应函数里是需要在新线程中执行的任务)</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-NSThread\"><a href=\"#2-NSThread\" class=\"headerlink\" title=\"2 NSThread\"></a>2 NSThread</h4><p>​    NSThread是苹果官方提供的，使用起来比pthread更加面向对象，简单易用，可以直接操作线程对象。不过也需要需要程序员自己管理线程的生命周期(主要是创建)，我们在开发的过程中偶尔使用NSThread。比如我们会经常调用[NSThread currentThread]来显示当前的进程信息。</p>\n<h5 id=\"2-1-创建、启动线程\"><a href=\"#2-1-创建、启动线程\" class=\"headerlink\" title=\"2.1 创建、启动线程\"></a>2.1 创建、启动线程</h5><ul>\n<li><p>先创建线程，再启动线程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];</span><br><span class=\"line\">[thread start];    // 线程一启动，就会在线程thread中执行self的run方法</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建线程后自动启动线程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>隐式创建并启动线程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self performSelectorInBackground:@selector(run) withObject:nil];</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"2-2-线程相关用法\"><a href=\"#2-2-线程相关用法\" class=\"headerlink\" title=\"2.2  线程相关用法\"></a>2.2  线程相关用法</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获得主线程</span><br><span class=\"line\">+ (NSThread *)mainThread;    </span><br><span class=\"line\"></span><br><span class=\"line\">// 判断是否为主线程(对象方法)</span><br><span class=\"line\">- (BOOL)isMainThread;</span><br><span class=\"line\"></span><br><span class=\"line\">// 判断是否为主线程(类方法)</span><br><span class=\"line\">+ (BOOL)isMainThread;    </span><br><span class=\"line\"></span><br><span class=\"line\">// 获得当前线程</span><br><span class=\"line\">NSThread *current = [NSThread currentThread];</span><br><span class=\"line\"></span><br><span class=\"line\">// 线程的名字——setter方法</span><br><span class=\"line\">- (void)setName:(NSString *)n;    </span><br><span class=\"line\"></span><br><span class=\"line\">// 线程的名字——getter方法</span><br><span class=\"line\">- (NSString *)name;</span><br></pre></td></tr></table></figure>\n<h5 id=\"2-3-线程状态控制方法\"><a href=\"#2-3-线程状态控制方法\" class=\"headerlink\" title=\"2.3 线程状态控制方法\"></a>2.3 线程状态控制方法</h5><ul>\n<li><p>启动线程方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 线程进入就绪状态 -&gt; 运行状态。当线程任务执行完毕，自动进入死亡状态</span><br><span class=\"line\">- (void)start;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>阻塞（暂停）线程方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 线程进入阻塞状态</span><br><span class=\"line\">+ (void)sleepUntilDate:(NSDate *)date;</span><br><span class=\"line\">+ (void)sleepForTimeInterval:(NSTimeInterval)ti;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>强制停止线程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 线程进入死亡状态</span><br><span class=\"line\">+ (void)exit;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"2-4-线程的状态转换\"><a href=\"#2-4-线程的状态转换\" class=\"headerlink\" title=\"2.4 线程的状态转换\"></a>2.4 线程的状态转换</h5><p>​    当我们新建一条线程<code>NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];</code>，在内存中的表现为：</p>\n<p>​    <img src=\"/2017/12/10/NSThread简介/2017_12_08_thread_one.png\" alt=\"1\"></p>\n<p>​    当调用<code>[thread start];</code>后，系统把线程对象放入可调度线程池中，线程对象进入就绪状态，如下图所示。</p>\n<p><img src=\"/2017/12/10/NSThread简介/2017_12_08_thread_two.png\" alt=\"2\"></p>\n<p>​    当然，可调度线程池中，会有其他的线程对象，如下图所示。在这里我们只关心左边的线程对象。</p>\n<p><img src=\"/2017/12/10/NSThread简介/2017_12_08_thread_three.png\" alt=\"3\"></p>\n<p><strong>下边我们来看看当前线程的状态转换。</strong></p>\n<ul>\n<li>如果CPU现在调度当前线程对象，则当前线程对象进入运行状态，如果CPU调度其他线程对象，则当前线程对象回到就绪状态。</li>\n</ul>\n<ul>\n<li>如果CPU在运行当前线程对象的时候调用了sleep方法\\等待同步锁，则当前线程对象就进入了阻塞状态，等到sleep到时\\得到同步锁，则回到就绪状态。</li>\n</ul>\n<ul>\n<li>如果CPU在运行当前线程对象的时候线程任务执行完毕\\异常强制退出，则当前线程对象进入死亡状态。</li>\n</ul>\n<p><img src=\"/2017/12/10/NSThread简介/2017_12_08_thread_four.png\" alt=\"4\"></p>\n<h4 id=\"3-线程同步\"><a href=\"#3-线程同步\" class=\"headerlink\" title=\"3 线程同步\"></a>3 线程同步</h4><h5 id=\"3-1-第一种方式-synchronized-对象-关键字\"><a href=\"#3-1-第一种方式-synchronized-对象-关键字\" class=\"headerlink\" title=\"3.1 第一种方式@synchronized(对象)关键字\"></a>3.1 第一种方式@synchronized(对象)关键字</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(void)taskRun</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    while (count&gt;0) &#123;</span><br><span class=\"line\">        @synchronized(self) &#123; // 需要锁定的代码</span><br><span class=\"line\">            [NSThread sleepForTimeInterval:0.1];</span><br><span class=\"line\">            count--;</span><br><span class=\"line\">            NSLog(@&quot;threadName:%@ count:%d &quot;,[NSThread currentThread].name, count);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"3-2-第二种方式NSLock同步锁\"><a href=\"#3-2-第二种方式NSLock同步锁\" class=\"headerlink\" title=\"3.2 第二种方式NSLock同步锁\"></a>3.2 第二种方式NSLock同步锁</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">threadLock = [[NSLock alloc] init];</span><br></pre></td></tr></table></figure>\n<p>然后在需要加锁的代码块开始时调用 lock函数 在结束时调用unLock函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(void)taskRun</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    while (count&gt;0) &#123;</span><br><span class=\"line\">        [threadLock lock];</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:0.1];</span><br><span class=\"line\">        count--;</span><br><span class=\"line\">        NSLog(@&quot;threadName:%@ count:%d &quot;,[NSThread currentThread].name, count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [threadLock unlock];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"3-3-第三种方式使用NSCondition同步锁和线程检查器\"><a href=\"#3-3-第三种方式使用NSCondition同步锁和线程检查器\" class=\"headerlink\" title=\"3.3 第三种方式使用NSCondition同步锁和线程检查器\"></a>3.3 第三种方式使用NSCondition同步锁和线程检查器</h5><p>​    锁主要为了当检测条件时保护数据源，执行条件引发的任务；线程检查器主要是根据条件决定是否继续运行线程，即线程是否被阻塞。先创建一个NSCondition对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">condition = [[NSCondition alloc] init];</span><br></pre></td></tr></table></figure>\n<p>使用同步锁的方式和NSLock相似</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(void)taskRun</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    while (count&gt;0) &#123;</span><br><span class=\"line\">        [condition lock];</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:0.1];</span><br><span class=\"line\">        count--;</span><br><span class=\"line\">        NSLog(@&quot;threadName:%@ count:%d &quot;,[NSThread currentThread].name, count);</span><br><span class=\"line\">        [condition unlock];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>NSCondition可以让线程进行等待，然后获取到CPU发信号告诉线程不用在等待，可以继续执行，上述的例子我们稍作修改，我们让线程三专门用于发送信号源</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSThread *thread1=[[NSThread alloc]initWithTarget:self selector:@selector(taskRun) object:nil];</span><br><span class=\"line\">thread1.name=@&quot;thread-1&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">NSThread *thread2=[[NSThread alloc]initWithTarget:self selector:@selector(taskRun) object:nil];</span><br><span class=\"line\">thread2.name=@&quot;thread-2&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">NSThread *thread3=[[NSThread alloc]initWithTarget:self selector:@selector(taskRun1) object:nil];</span><br><span class=\"line\">thread3.name=@&quot;thread-3&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">[thread1 start];</span><br><span class=\"line\">[thread2 start];</span><br><span class=\"line\">[thread3 start];</span><br></pre></td></tr></table></figure>\n<p>taskRun1函数用于发送信号源</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(void)taskRun1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    while (YES) &#123;</span><br><span class=\"line\">        [condition lock];</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">        [condition signal];</span><br><span class=\"line\">        [condition unlock];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>taskRun函数 用于执行对count的操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(void)taskRun</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    while (count&gt;0) &#123;</span><br><span class=\"line\">        [condition lock];</span><br><span class=\"line\">        [condition wait];</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:0.1];</span><br><span class=\"line\">        count--;</span><br><span class=\"line\">        NSLog(@&quot;threadName:%@ count:%d &quot;,[NSThread currentThread].name, count);</span><br><span class=\"line\">        [condition unlock];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行的结果会发现，只有在Thread-1、和Thread-2 收到信号源的时候才会执行count–，否则一直出于等待状态。</p>\n<p>转载自<a href=\"http://www.jianshu.com/p/cbaeea5368b1\" target=\"_blank\" rel=\"noopener\">iOS多线程–彻底学会多线程</a></p>"},{"title":"第七感","date":"2016-11-22T06:12:00.000Z","_content":"\n#### <center>第七感   \n\n\n<center>Oh baby oh  woo\n\n微风带走了浮云\n​\t\t\t\t\t \n浮云带走雨滴\n\n阳光在闪耀\n\n当我想到你\n\n什么烦恼都痊愈\n\n快乐不再分心\n\n笑容多甜蜜\n\n因为遇见你\n\n<!-- more -->\n\nOh baby baby\n\n这一切是不是注定\n\n只要能走到一起\n\n迟到没有关系\n\nDon‘t say maybe\n\n别说缘分你不相信\n\nOh 这就是爱\n\n有你的每一天\n\n那么的完美\n\n快乐不用刻意营造都有氛围\n\n爱在每一天\n\n顺时针蔓延\n\n像风和云永远都缠绵\n\n不会改变\n\nI feel 那么热烈\n\n闪烁迷人的光线\n\n心跳能让我感觉\n\nFree 拥抱没有时限\n\n指引着爱的世界\n\n你是我的第七感\n\n不需要形影不离\n\n只用闭上眼睛\n\n思恋会替我\n\n紧紧的抱住你\n\n不知道什么原因\n\n突然停止找寻\n\n再美的风景\n\n都不如你吸引\n\nOh baby baby\n\n幸福喜欢突然袭击\n\n没有倒数三二一\n\n这样才叫惊喜\n\nDon’t say maybe\n\n别怀疑命运的牵引\n\nOh 这就是爱\n\n有你的每一天\n\n那么的完美\n\n快乐不用刻意营造都有氛围\n\n爱在每一天\n\n顺时针蔓延\n\n像风和云永远都缠绵\n\n不会改变\n\nI feel 那么热烈\n\n闪烁迷人的光线\n\n心跳能让我感觉\n\nFree 拥抱没有时限\n\n指引着爱的世界\n\n你是我的\n\n幸福要珍惜\n\n不会一直有好运气\n\n时间已向我解答\n\n付出不怀疑\n\n越了解心就越靠近\n\n满满的温暖\n\n有你的每一天\n\n那么的完美\n\n快乐不用刻意营造都有氛围\n\n爱在每一天\n\n顺时针蔓延\n\n像风和云永远都缠绵\n\n不会改变\n\nI feel 那么热烈\n\n闪烁迷人的光线\n\n心跳能让我感觉\n\nFree 拥抱没有时限\n\n你是我的第七感</center> ","source":"_posts/Seven.md","raw":"---\ntitle: 第七感\ndate: 2016-11-22 14:12\ntags: relax\ncategories: Music\n---\n\n#### <center>第七感   \n\n\n<center>Oh baby oh  woo\n\n微风带走了浮云\n​\t\t\t\t\t \n浮云带走雨滴\n\n阳光在闪耀\n\n当我想到你\n\n什么烦恼都痊愈\n\n快乐不再分心\n\n笑容多甜蜜\n\n因为遇见你\n\n<!-- more -->\n\nOh baby baby\n\n这一切是不是注定\n\n只要能走到一起\n\n迟到没有关系\n\nDon‘t say maybe\n\n别说缘分你不相信\n\nOh 这就是爱\n\n有你的每一天\n\n那么的完美\n\n快乐不用刻意营造都有氛围\n\n爱在每一天\n\n顺时针蔓延\n\n像风和云永远都缠绵\n\n不会改变\n\nI feel 那么热烈\n\n闪烁迷人的光线\n\n心跳能让我感觉\n\nFree 拥抱没有时限\n\n指引着爱的世界\n\n你是我的第七感\n\n不需要形影不离\n\n只用闭上眼睛\n\n思恋会替我\n\n紧紧的抱住你\n\n不知道什么原因\n\n突然停止找寻\n\n再美的风景\n\n都不如你吸引\n\nOh baby baby\n\n幸福喜欢突然袭击\n\n没有倒数三二一\n\n这样才叫惊喜\n\nDon’t say maybe\n\n别怀疑命运的牵引\n\nOh 这就是爱\n\n有你的每一天\n\n那么的完美\n\n快乐不用刻意营造都有氛围\n\n爱在每一天\n\n顺时针蔓延\n\n像风和云永远都缠绵\n\n不会改变\n\nI feel 那么热烈\n\n闪烁迷人的光线\n\n心跳能让我感觉\n\nFree 拥抱没有时限\n\n指引着爱的世界\n\n你是我的\n\n幸福要珍惜\n\n不会一直有好运气\n\n时间已向我解答\n\n付出不怀疑\n\n越了解心就越靠近\n\n满满的温暖\n\n有你的每一天\n\n那么的完美\n\n快乐不用刻意营造都有氛围\n\n爱在每一天\n\n顺时针蔓延\n\n像风和云永远都缠绵\n\n不会改变\n\nI feel 那么热烈\n\n闪烁迷人的光线\n\n心跳能让我感觉\n\nFree 拥抱没有时限\n\n你是我的第七感</center> ","slug":"Seven","published":1,"updated":"2017-12-06T06:44:24.329Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb1u1v86000z1us01lw7b2re","content":"<h4 id=\"第七感\"><a href=\"#第七感\" class=\"headerlink\" title=\"第七感\"></a><center>第七感</center></h4><center>Oh baby oh  woo<br><br>微风带走了浮云<br>​<br>浮云带走雨滴<br><br>阳光在闪耀<br><br>当我想到你<br><br>什么烦恼都痊愈<br><br>快乐不再分心<br><br>笑容多甜蜜<br><br>因为遇见你<br><br><a id=\"more\"></a><br><br>Oh baby baby<br><br>这一切是不是注定<br><br>只要能走到一起<br><br>迟到没有关系<br><br>Don‘t say maybe<br><br>别说缘分你不相信<br><br>Oh 这就是爱<br><br>有你的每一天<br><br>那么的完美<br><br>快乐不用刻意营造都有氛围<br><br>爱在每一天<br><br>顺时针蔓延<br><br>像风和云永远都缠绵<br><br>不会改变<br><br>I feel 那么热烈<br><br>闪烁迷人的光线<br><br>心跳能让我感觉<br><br>Free 拥抱没有时限<br><br>指引着爱的世界<br><br>你是我的第七感<br><br>不需要形影不离<br><br>只用闭上眼睛<br><br>思恋会替我<br><br>紧紧的抱住你<br><br>不知道什么原因<br><br>突然停止找寻<br><br>再美的风景<br><br>都不如你吸引<br><br>Oh baby baby<br><br>幸福喜欢突然袭击<br><br>没有倒数三二一<br><br>这样才叫惊喜<br><br>Don’t say maybe<br><br>别怀疑命运的牵引<br><br>Oh 这就是爱<br><br>有你的每一天<br><br>那么的完美<br><br>快乐不用刻意营造都有氛围<br><br>爱在每一天<br><br>顺时针蔓延<br><br>像风和云永远都缠绵<br><br>不会改变<br><br>I feel 那么热烈<br><br>闪烁迷人的光线<br><br>心跳能让我感觉<br><br>Free 拥抱没有时限<br><br>指引着爱的世界<br><br>你是我的<br><br>幸福要珍惜<br><br>不会一直有好运气<br><br>时间已向我解答<br><br>付出不怀疑<br><br>越了解心就越靠近<br><br>满满的温暖<br><br>有你的每一天<br><br>那么的完美<br><br>快乐不用刻意营造都有氛围<br><br>爱在每一天<br><br>顺时针蔓延<br><br>像风和云永远都缠绵<br><br>不会改变<br><br>I feel 那么热烈<br><br>闪烁迷人的光线<br><br>心跳能让我感觉<br><br>Free 拥抱没有时限<br><br>你是我的第七感</center> ","site":{"data":{}},"excerpt":"<h4 id=\"第七感\"><a href=\"#第七感\" class=\"headerlink\" title=\"第七感\"></a><center>第七感</center></h4><center>Oh baby oh  woo<br><br>微风带走了浮云<br>​<br>浮云带走雨滴<br><br>阳光在闪耀<br><br>当我想到你<br><br>什么烦恼都痊愈<br><br>快乐不再分心<br><br>笑容多甜蜜<br><br>因为遇见你<br><br></center>","more":"<br><br>Oh baby baby<br><br>这一切是不是注定<br><br>只要能走到一起<br><br>迟到没有关系<br><br>Don‘t say maybe<br><br>别说缘分你不相信<br><br>Oh 这就是爱<br><br>有你的每一天<br><br>那么的完美<br><br>快乐不用刻意营造都有氛围<br><br>爱在每一天<br><br>顺时针蔓延<br><br>像风和云永远都缠绵<br><br>不会改变<br><br>I feel 那么热烈<br><br>闪烁迷人的光线<br><br>心跳能让我感觉<br><br>Free 拥抱没有时限<br><br>指引着爱的世界<br><br>你是我的第七感<br><br>不需要形影不离<br><br>只用闭上眼睛<br><br>思恋会替我<br><br>紧紧的抱住你<br><br>不知道什么原因<br><br>突然停止找寻<br><br>再美的风景<br><br>都不如你吸引<br><br>Oh baby baby<br><br>幸福喜欢突然袭击<br><br>没有倒数三二一<br><br>这样才叫惊喜<br><br>Don’t say maybe<br><br>别怀疑命运的牵引<br><br>Oh 这就是爱<br><br>有你的每一天<br><br>那么的完美<br><br>快乐不用刻意营造都有氛围<br><br>爱在每一天<br><br>顺时针蔓延<br><br>像风和云永远都缠绵<br><br>不会改变<br><br>I feel 那么热烈<br><br>闪烁迷人的光线<br><br>心跳能让我感觉<br><br>Free 拥抱没有时限<br><br>指引着爱的世界<br><br>你是我的<br><br>幸福要珍惜<br><br>不会一直有好运气<br><br>时间已向我解答<br><br>付出不怀疑<br><br>越了解心就越靠近<br><br>满满的温暖<br><br>有你的每一天<br><br>那么的完美<br><br>快乐不用刻意营造都有氛围<br><br>爱在每一天<br><br>顺时针蔓延<br><br>像风和云永远都缠绵<br><br>不会改变<br><br>I feel 那么热烈<br><br>闪烁迷人的光线<br><br>心跳能让我感觉<br><br>Free 拥抱没有时限<br><br>你是我的第七感"},{"title":"移动UITextFeild的光标","date":"2016-11-28T11:06:00.000Z","_content":"有时候如果用没有边框的UITextField的时候，自己在layer上画边框的话，UITextField的光标会直接挨着左边的边框，界面看着不友好，这里可以使用下面的代码向右移动光标的位置：\n\n    //把textField的光标向后移\n    //移动的像素\n    NSInteger m = 8;\n    UIView *paddingView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, m, 40)];\n    textF.leftView = paddingView;\n    textF.leftViewMode = UITextFieldViewModeAlways;\n","source":"_posts/UITextFeild-cursor.md","raw":"---\ntitle: 移动UITextFeild的光标\ndate: 2016-11-28 19:06\ntags: iOS\ncategories: iOS Tips\n---\n有时候如果用没有边框的UITextField的时候，自己在layer上画边框的话，UITextField的光标会直接挨着左边的边框，界面看着不友好，这里可以使用下面的代码向右移动光标的位置：\n\n    //把textField的光标向后移\n    //移动的像素\n    NSInteger m = 8;\n    UIView *paddingView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, m, 40)];\n    textF.leftView = paddingView;\n    textF.leftViewMode = UITextFieldViewModeAlways;\n","slug":"UITextFeild-cursor","published":1,"updated":"2017-12-05T10:38:24.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb1u1v8700121us0zy1fb1l8","content":"<p>有时候如果用没有边框的UITextField的时候，自己在layer上画边框的话，UITextField的光标会直接挨着左边的边框，界面看着不友好，这里可以使用下面的代码向右移动光标的位置：</p>\n<pre><code>//把textField的光标向后移\n//移动的像素\nNSInteger m = 8;\nUIView *paddingView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, m, 40)];\ntextF.leftView = paddingView;\ntextF.leftViewMode = UITextFieldViewModeAlways;\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>有时候如果用没有边框的UITextField的时候，自己在layer上画边框的话，UITextField的光标会直接挨着左边的边框，界面看着不友好，这里可以使用下面的代码向右移动光标的位置：</p>\n<pre><code>//把textField的光标向后移\n//移动的像素\nNSInteger m = 8;\nUIView *paddingView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, m, 40)];\ntextF.leftView = paddingView;\ntextF.leftViewMode = UITextFieldViewModeAlways;\n</code></pre>"},{"title":"带块的button","date":"2017-12-06T10:06:00.000Z","_content":"\n今天简单的记录一下怎么用块来实现Button的点击事件\n\n首先，我想要的做的效果是直接通过类方法来初始化Button，然后同时把点击事件的操作放在块中，最后返回创建好的Button。\n\n- 第一步，创建一个UIButton的扩展(category)\n\n- 第二步，在h文件中添加初始化Button的类方法声明\n  <!-- more -->\n\n\n```objective-c\n#import <UIKit/UIKit.h>\n\ntypedef void (^ActionBlock)(UIButton *button);\n\n@interface UIButton (Block)\n\n@property (nonatomic,copy) ActionBlock actionBlock;\n\n/**\n 通过block对Button的点击事件进行封装\n \n @param frame frame大小\n @param title 内容\n @param titleColor 内容颜色\n @param bgImgName 背景图片\n @param completion 点击事件\n @return Button\n */\n+ (UIButton *)createButtonWithFrame:(CGRect)frame\n                              title:(NSString *)title\n                         titleColor:(UIColor *)titleColor\n                        bgImageName:(NSString *)bgImgName\n                        actionBlock:(void(^)(UIButton *sender))completion;\n\n\n/**\n 通过block对Button的点击事件进行封装\n\n @return 返回初始化后的button\n */\n+ (UIButton *)button;\n\n@end\n\n```\n\n- 第三步，在m文件中实现方法\n```objective-c\n#import \"UIButton+Block.h\"\n#import <objc/runtime.h>\n\nstatic NSString *keyWithMethod = @\"keyWithMethod\"; //关联对象的key\nstatic NSString *keyWithBlock = @\"keyWithBlock\";\n\n@implementation UIButton (Block)\n\n+ (UIButton *)createButtonWithFrame:(CGRect)frame\n                              title:(NSString *)title\n                         titleColor:(UIColor *)titleColor\n                        bgImageName:(NSString *)bgImgName\n                        actionBlock:(void (^)(UIButton *sender))completion {\n    \n    UIButton *button = [UIButton buttonWithType:UIButtonTypeRoundedRect];\n    button.frame = frame;\n    [button setTitle:title forState:UIControlStateNormal];\n    [button setTitleColor:titleColor forState:UIControlStateNormal];\n    [button setBackgroundImage:[UIImage imageNamed:bgImgName] forState:UIControlStateNormal];\n    [button addTarget:button action:@selector(buttonTapAction:) forControlEvents:UIControlEventTouchUpInside];\n    \n    /*\n     *用runtime中的函数通过key关联对象\n     *\n     *objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key, id _Nullable value, objc_AssociationPolicy policy)\n     *id object                 表示关联者，是一个对象，变量名也是object\n     *const void *key           获取被关联者的索引\n     *id value                  被关联者，这里是一个block\n     *objc_AssociationPolicy    policy 关联时采用的协议，有assign，retain，copy等协议，一般使用OBJC_ASSOCIATION_RETAIN_NONATOMIC\n     */\n    objc_setAssociatedObject(button, &keyWithMethod, completion, OBJC_ASSOCIATION_COPY_NONATOMIC);\n    \n    return button;\n}\n\n+ (UIButton *)button {\n    UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];\n    [button addTarget:button action:@selector(buttonTapAction:) forControlEvents:UIControlEventTouchUpInside];\n    return button;\n}\n\n- (void)setActionBlock:(ActionBlock)actionBlock{\n    objc_setAssociatedObject(self, &keyWithBlock, actionBlock, OBJC_ASSOCIATION_COPY_NONATOMIC );\n}\n\n- (ActionBlock)actionBlock{\n    return objc_getAssociatedObject(self ,&keyWithBlock);\n}\n\n- (void)buttonTapAction:(UIButton *)button {\n    //通过key获取被关联对象\n    //objc_getAssociatedObject(id object, const void *key)\n    void (^tapBlock)(UIButton *) = objc_getAssociatedObject(button, &keyWithMethod);\n    \n    if (tapBlock) {\n        tapBlock(button);\n    }\n \n    ActionBlock block2 = (ActionBlock)objc_getAssociatedObject(button, &keyWithBlock);\n    if(block2){\n        block2(button);\n    }\n}\n\n@end\n```\n\n- 第四步，简单的使用\n```objective-c\nUIButton *button = [UIButton createButtonWithFrame:CGRectMake(20, 100, 200, 200) title:@\"带块的button\" titleColor:[UIColor redColor] bgImageName:@\"\" actionBlock:^(UIButton *button) {\n        NSString *str = [button titleForState:UIControlStateNormal];\n        NSLog(@\"%@\",str);\n}];\n[self.view addSubview:button];\n\nUIButton *btn = [UIButton button];\nbtn.frame = CGRectMake(20, 100, 200, 200);\n[btn setTitle:@\"1234\" forState:UIControlStateNormal];\nbtn.actionBlock = ^(UIButton *button) {\n    NSString *str = [button titleForState:UIControlStateNormal];\n    NSLog(@\"%@\",str);\n};\n[self.view addSubview:btn];\n```\n**注意：**由于扩展不能直接添加属性，所以要用运行时来自己添加属性的`get`、`set`方法。\n\n最后，简单的了解一下`objc_setAssociatedObject`，`objc_getAssociatedObject`方法\n\n​\tObjective-C有两个扩展机制：`Associative`和`Category`。`Category`用来扩展类方法，`Associative`用于扩展属性。`Associative`机制的原理是把两个对象关联起来，让一个对象成为另外一个对象的一部分。它可以在不修改类的定义的前提下为其对象增加存储空间，这在我们无法访问类的源码时(例如给UILable添加一个`selected`的BOOL属性)是非常有用的。`Associative`基于关键字的，因此我们可以使用不同的关键字为任何对象添加任意多的`Associative`。`Associative`可以保证被关联的对象在对象的整个生命周期都是可用的。`Associative`基于runtime，是运行时里的东西,所以头文件需要引用`#import<objc/runtime.h>`文件。\n\n`Associative`提供了3个方法\n\n```objective-c\n- objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)\n- objc_getAssociatedObject(id object, const void *key)\n- objc_removeAssociatedObjects(id object)\n```\n第一个用于给关联对象赋值：\t\n\n`objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)`注意的是返回值类型为Object类型，注意一些不是Object类型的例如：BOOL是结构类型。当碰到这种情况可以考虑通过中间类型来转换，如设置BOOL类型属性的时候可以转换为NSNumber类型，获取的时候再转换成BOOL类型即可。\n四个参数分别是：源对象、关键字、关联对象和关联策略。\n关键字是一个void类型的指针，例如`static NSString *keyWithMethod = @\"keyWithMethod\"; //关联对象的key`每一个关联的关键字必须是唯一的。\n\n关联策略是枚举类型，如下：\n\n```objective-c\n\ntypedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {\n    OBJC_ASSOCIATION_ASSIGN = 0,           /**< Specifies a weak reference to the associated object. */\n    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**< Specifies a strong reference to the associated object. \n       \t                                    *   The association is not made atomically. */\n    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**< Specifies that the associated object is copied. \n                                            *   The association is not made atomically. */\n    OBJC_ASSOCIATION_RETAIN = 01401,       /**< Specifies a strong reference to the associated object.\n                                            *   The association is made atomically. */\n    OBJC_ASSOCIATION_COPY = 01403          /**< Specifies that the associated object is copied.\n                                            *   The association is made atomically. */\n};\n```\n\n 第二个用于获取关联的对象:\n\n`objc_getAssociatedObject(id object, const void *key)`用于获取关联对象的值。这里需要注意的是返回值类型为Object类型，注意一些不是Object类型的例如：BOOL是结构类型。\n\n第三个用于断开关联的对象：\n\n` objc_removeAssociatedObjects(id object)` 是断开关联，需要注意的是他会断开所有关联，所以不推荐这种方式。需要断开关联的时候使用`objc_setAssociatedObject`函数，传入`nil`值即可。","source":"_posts/带块的Button.md","raw":"---\ntitle: 带块的button\ndate: 2017-12-06 18:06\ntags: iOS\ncategories: iOS Tips\n---\n\n今天简单的记录一下怎么用块来实现Button的点击事件\n\n首先，我想要的做的效果是直接通过类方法来初始化Button，然后同时把点击事件的操作放在块中，最后返回创建好的Button。\n\n- 第一步，创建一个UIButton的扩展(category)\n\n- 第二步，在h文件中添加初始化Button的类方法声明\n  <!-- more -->\n\n\n```objective-c\n#import <UIKit/UIKit.h>\n\ntypedef void (^ActionBlock)(UIButton *button);\n\n@interface UIButton (Block)\n\n@property (nonatomic,copy) ActionBlock actionBlock;\n\n/**\n 通过block对Button的点击事件进行封装\n \n @param frame frame大小\n @param title 内容\n @param titleColor 内容颜色\n @param bgImgName 背景图片\n @param completion 点击事件\n @return Button\n */\n+ (UIButton *)createButtonWithFrame:(CGRect)frame\n                              title:(NSString *)title\n                         titleColor:(UIColor *)titleColor\n                        bgImageName:(NSString *)bgImgName\n                        actionBlock:(void(^)(UIButton *sender))completion;\n\n\n/**\n 通过block对Button的点击事件进行封装\n\n @return 返回初始化后的button\n */\n+ (UIButton *)button;\n\n@end\n\n```\n\n- 第三步，在m文件中实现方法\n```objective-c\n#import \"UIButton+Block.h\"\n#import <objc/runtime.h>\n\nstatic NSString *keyWithMethod = @\"keyWithMethod\"; //关联对象的key\nstatic NSString *keyWithBlock = @\"keyWithBlock\";\n\n@implementation UIButton (Block)\n\n+ (UIButton *)createButtonWithFrame:(CGRect)frame\n                              title:(NSString *)title\n                         titleColor:(UIColor *)titleColor\n                        bgImageName:(NSString *)bgImgName\n                        actionBlock:(void (^)(UIButton *sender))completion {\n    \n    UIButton *button = [UIButton buttonWithType:UIButtonTypeRoundedRect];\n    button.frame = frame;\n    [button setTitle:title forState:UIControlStateNormal];\n    [button setTitleColor:titleColor forState:UIControlStateNormal];\n    [button setBackgroundImage:[UIImage imageNamed:bgImgName] forState:UIControlStateNormal];\n    [button addTarget:button action:@selector(buttonTapAction:) forControlEvents:UIControlEventTouchUpInside];\n    \n    /*\n     *用runtime中的函数通过key关联对象\n     *\n     *objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key, id _Nullable value, objc_AssociationPolicy policy)\n     *id object                 表示关联者，是一个对象，变量名也是object\n     *const void *key           获取被关联者的索引\n     *id value                  被关联者，这里是一个block\n     *objc_AssociationPolicy    policy 关联时采用的协议，有assign，retain，copy等协议，一般使用OBJC_ASSOCIATION_RETAIN_NONATOMIC\n     */\n    objc_setAssociatedObject(button, &keyWithMethod, completion, OBJC_ASSOCIATION_COPY_NONATOMIC);\n    \n    return button;\n}\n\n+ (UIButton *)button {\n    UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];\n    [button addTarget:button action:@selector(buttonTapAction:) forControlEvents:UIControlEventTouchUpInside];\n    return button;\n}\n\n- (void)setActionBlock:(ActionBlock)actionBlock{\n    objc_setAssociatedObject(self, &keyWithBlock, actionBlock, OBJC_ASSOCIATION_COPY_NONATOMIC );\n}\n\n- (ActionBlock)actionBlock{\n    return objc_getAssociatedObject(self ,&keyWithBlock);\n}\n\n- (void)buttonTapAction:(UIButton *)button {\n    //通过key获取被关联对象\n    //objc_getAssociatedObject(id object, const void *key)\n    void (^tapBlock)(UIButton *) = objc_getAssociatedObject(button, &keyWithMethod);\n    \n    if (tapBlock) {\n        tapBlock(button);\n    }\n \n    ActionBlock block2 = (ActionBlock)objc_getAssociatedObject(button, &keyWithBlock);\n    if(block2){\n        block2(button);\n    }\n}\n\n@end\n```\n\n- 第四步，简单的使用\n```objective-c\nUIButton *button = [UIButton createButtonWithFrame:CGRectMake(20, 100, 200, 200) title:@\"带块的button\" titleColor:[UIColor redColor] bgImageName:@\"\" actionBlock:^(UIButton *button) {\n        NSString *str = [button titleForState:UIControlStateNormal];\n        NSLog(@\"%@\",str);\n}];\n[self.view addSubview:button];\n\nUIButton *btn = [UIButton button];\nbtn.frame = CGRectMake(20, 100, 200, 200);\n[btn setTitle:@\"1234\" forState:UIControlStateNormal];\nbtn.actionBlock = ^(UIButton *button) {\n    NSString *str = [button titleForState:UIControlStateNormal];\n    NSLog(@\"%@\",str);\n};\n[self.view addSubview:btn];\n```\n**注意：**由于扩展不能直接添加属性，所以要用运行时来自己添加属性的`get`、`set`方法。\n\n最后，简单的了解一下`objc_setAssociatedObject`，`objc_getAssociatedObject`方法\n\n​\tObjective-C有两个扩展机制：`Associative`和`Category`。`Category`用来扩展类方法，`Associative`用于扩展属性。`Associative`机制的原理是把两个对象关联起来，让一个对象成为另外一个对象的一部分。它可以在不修改类的定义的前提下为其对象增加存储空间，这在我们无法访问类的源码时(例如给UILable添加一个`selected`的BOOL属性)是非常有用的。`Associative`基于关键字的，因此我们可以使用不同的关键字为任何对象添加任意多的`Associative`。`Associative`可以保证被关联的对象在对象的整个生命周期都是可用的。`Associative`基于runtime，是运行时里的东西,所以头文件需要引用`#import<objc/runtime.h>`文件。\n\n`Associative`提供了3个方法\n\n```objective-c\n- objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)\n- objc_getAssociatedObject(id object, const void *key)\n- objc_removeAssociatedObjects(id object)\n```\n第一个用于给关联对象赋值：\t\n\n`objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)`注意的是返回值类型为Object类型，注意一些不是Object类型的例如：BOOL是结构类型。当碰到这种情况可以考虑通过中间类型来转换，如设置BOOL类型属性的时候可以转换为NSNumber类型，获取的时候再转换成BOOL类型即可。\n四个参数分别是：源对象、关键字、关联对象和关联策略。\n关键字是一个void类型的指针，例如`static NSString *keyWithMethod = @\"keyWithMethod\"; //关联对象的key`每一个关联的关键字必须是唯一的。\n\n关联策略是枚举类型，如下：\n\n```objective-c\n\ntypedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {\n    OBJC_ASSOCIATION_ASSIGN = 0,           /**< Specifies a weak reference to the associated object. */\n    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**< Specifies a strong reference to the associated object. \n       \t                                    *   The association is not made atomically. */\n    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**< Specifies that the associated object is copied. \n                                            *   The association is not made atomically. */\n    OBJC_ASSOCIATION_RETAIN = 01401,       /**< Specifies a strong reference to the associated object.\n                                            *   The association is made atomically. */\n    OBJC_ASSOCIATION_COPY = 01403          /**< Specifies that the associated object is copied.\n                                            *   The association is made atomically. */\n};\n```\n\n 第二个用于获取关联的对象:\n\n`objc_getAssociatedObject(id object, const void *key)`用于获取关联对象的值。这里需要注意的是返回值类型为Object类型，注意一些不是Object类型的例如：BOOL是结构类型。\n\n第三个用于断开关联的对象：\n\n` objc_removeAssociatedObjects(id object)` 是断开关联，需要注意的是他会断开所有关联，所以不推荐这种方式。需要断开关联的时候使用`objc_setAssociatedObject`函数，传入`nil`值即可。","slug":"带块的Button","published":1,"updated":"2017-12-06T08:19:16.682Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb1u1v8900171us0k5mjkax9","content":"<p>今天简单的记录一下怎么用块来实现Button的点击事件</p>\n<p>首先，我想要的做的效果是直接通过类方法来初始化Button，然后同时把点击事件的操作放在块中，最后返回创建好的Button。</p>\n<ul>\n<li><p>第一步，创建一个UIButton的扩展(category)</p>\n</li>\n<li><p>第二步，在h文件中添加初始化Button的类方法声明</p>\n<a id=\"more\"></a>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;UIKit/UIKit.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef void (^ActionBlock)(UIButton *button);</span><br><span class=\"line\"></span><br><span class=\"line\">@interface UIButton (Block)</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic,copy) ActionBlock actionBlock;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> 通过block对Button的点击事件进行封装</span><br><span class=\"line\"> </span><br><span class=\"line\"> @param frame frame大小</span><br><span class=\"line\"> @param title 内容</span><br><span class=\"line\"> @param titleColor 内容颜色</span><br><span class=\"line\"> @param bgImgName 背景图片</span><br><span class=\"line\"> @param completion 点击事件</span><br><span class=\"line\"> @return Button</span><br><span class=\"line\"> */</span><br><span class=\"line\">+ (UIButton *)createButtonWithFrame:(CGRect)frame</span><br><span class=\"line\">                              title:(NSString *)title</span><br><span class=\"line\">                         titleColor:(UIColor *)titleColor</span><br><span class=\"line\">                        bgImageName:(NSString *)bgImgName</span><br><span class=\"line\">                        actionBlock:(void(^)(UIButton *sender))completion;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> 通过block对Button的点击事件进行封装</span><br><span class=\"line\"></span><br><span class=\"line\"> @return 返回初始化后的button</span><br><span class=\"line\"> */</span><br><span class=\"line\">+ (UIButton *)button;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>第三步，在m文件中实现方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;UIButton+Block.h&quot;</span><br><span class=\"line\">#import &lt;objc/runtime.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">static NSString *keyWithMethod = @&quot;keyWithMethod&quot;; //关联对象的key</span><br><span class=\"line\">static NSString *keyWithBlock = @&quot;keyWithBlock&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation UIButton (Block)</span><br><span class=\"line\"></span><br><span class=\"line\">+ (UIButton *)createButtonWithFrame:(CGRect)frame</span><br><span class=\"line\">                              title:(NSString *)title</span><br><span class=\"line\">                         titleColor:(UIColor *)titleColor</span><br><span class=\"line\">                        bgImageName:(NSString *)bgImgName</span><br><span class=\"line\">                        actionBlock:(void (^)(UIButton *sender))completion &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    UIButton *button = [UIButton buttonWithType:UIButtonTypeRoundedRect];</span><br><span class=\"line\">    button.frame = frame;</span><br><span class=\"line\">    [button setTitle:title forState:UIControlStateNormal];</span><br><span class=\"line\">    [button setTitleColor:titleColor forState:UIControlStateNormal];</span><br><span class=\"line\">    [button setBackgroundImage:[UIImage imageNamed:bgImgName] forState:UIControlStateNormal];</span><br><span class=\"line\">    [button addTarget:button action:@selector(buttonTapAction:) forControlEvents:UIControlEventTouchUpInside];</span><br><span class=\"line\">    </span><br><span class=\"line\">    /*</span><br><span class=\"line\">     *用runtime中的函数通过key关联对象</span><br><span class=\"line\">     *</span><br><span class=\"line\">     *objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key, id _Nullable value, objc_AssociationPolicy policy)</span><br><span class=\"line\">     *id object                 表示关联者，是一个对象，变量名也是object</span><br><span class=\"line\">     *const void *key           获取被关联者的索引</span><br><span class=\"line\">     *id value                  被关联者，这里是一个block</span><br><span class=\"line\">     *objc_AssociationPolicy    policy 关联时采用的协议，有assign，retain，copy等协议，一般使用OBJC_ASSOCIATION_RETAIN_NONATOMIC</span><br><span class=\"line\">     */</span><br><span class=\"line\">    objc_setAssociatedObject(button, &amp;keyWithMethod, completion, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return button;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (UIButton *)button &#123;</span><br><span class=\"line\">    UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];</span><br><span class=\"line\">    [button addTarget:button action:@selector(buttonTapAction:) forControlEvents:UIControlEventTouchUpInside];</span><br><span class=\"line\">    return button;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setActionBlock:(ActionBlock)actionBlock&#123;</span><br><span class=\"line\">    objc_setAssociatedObject(self, &amp;keyWithBlock, actionBlock, OBJC_ASSOCIATION_COPY_NONATOMIC );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (ActionBlock)actionBlock&#123;</span><br><span class=\"line\">    return objc_getAssociatedObject(self ,&amp;keyWithBlock);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)buttonTapAction:(UIButton *)button &#123;</span><br><span class=\"line\">    //通过key获取被关联对象</span><br><span class=\"line\">    //objc_getAssociatedObject(id object, const void *key)</span><br><span class=\"line\">    void (^tapBlock)(UIButton *) = objc_getAssociatedObject(button, &amp;keyWithMethod);</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (tapBlock) &#123;</span><br><span class=\"line\">        tapBlock(button);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    ActionBlock block2 = (ActionBlock)objc_getAssociatedObject(button, &amp;keyWithBlock);</span><br><span class=\"line\">    if(block2)&#123;</span><br><span class=\"line\">        block2(button);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第四步，简单的使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIButton *button = [UIButton createButtonWithFrame:CGRectMake(20, 100, 200, 200) title:@&quot;带块的button&quot; titleColor:[UIColor redColor] bgImageName:@&quot;&quot; actionBlock:^(UIButton *button) &#123;</span><br><span class=\"line\">        NSString *str = [button titleForState:UIControlStateNormal];</span><br><span class=\"line\">        NSLog(@&quot;%@&quot;,str);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">[self.view addSubview:button];</span><br><span class=\"line\"></span><br><span class=\"line\">UIButton *btn = [UIButton button];</span><br><span class=\"line\">btn.frame = CGRectMake(20, 100, 200, 200);</span><br><span class=\"line\">[btn setTitle:@&quot;1234&quot; forState:UIControlStateNormal];</span><br><span class=\"line\">btn.actionBlock = ^(UIButton *button) &#123;</span><br><span class=\"line\">    NSString *str = [button titleForState:UIControlStateNormal];</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;,str);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">[self.view addSubview:btn];</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>注意：</strong>由于扩展不能直接添加属性，所以要用运行时来自己添加属性的<code>get</code>、<code>set</code>方法。</p>\n<p>最后，简单的了解一下<code>objc_setAssociatedObject</code>，<code>objc_getAssociatedObject</code>方法</p>\n<p>​    Objective-C有两个扩展机制：<code>Associative</code>和<code>Category</code>。<code>Category</code>用来扩展类方法，<code>Associative</code>用于扩展属性。<code>Associative</code>机制的原理是把两个对象关联起来，让一个对象成为另外一个对象的一部分。它可以在不修改类的定义的前提下为其对象增加存储空间，这在我们无法访问类的源码时(例如给UILable添加一个<code>selected</code>的BOOL属性)是非常有用的。<code>Associative</code>基于关键字的，因此我们可以使用不同的关键字为任何对象添加任意多的<code>Associative</code>。<code>Associative</code>可以保证被关联的对象在对象的整个生命周期都是可用的。<code>Associative</code>基于runtime，是运行时里的东西,所以头文件需要引用<code>#import&lt;objc/runtime.h&gt;</code>文件。</p>\n<p><code>Associative</code>提供了3个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)</span><br><span class=\"line\">- objc_getAssociatedObject(id object, const void *key)</span><br><span class=\"line\">- objc_removeAssociatedObjects(id object)</span><br></pre></td></tr></table></figure>\n<p>第一个用于给关联对象赋值：    </p>\n<p><code>objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)</code>注意的是返回值类型为Object类型，注意一些不是Object类型的例如：BOOL是结构类型。当碰到这种情况可以考虑通过中间类型来转换，如设置BOOL类型属性的时候可以转换为NSNumber类型，获取的时候再转换成BOOL类型即可。<br>四个参数分别是：源对象、关键字、关联对象和关联策略。<br>关键字是一个void类型的指针，例如<code>static NSString *keyWithMethod = @&quot;keyWithMethod&quot;; //关联对象的key</code>每一个关联的关键字必须是唯一的。</p>\n<p>关联策略是枚举类型，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</span><br><span class=\"line\">    OBJC_ASSOCIATION_ASSIGN = 0,           /**&lt; Specifies a weak reference to the associated object. */</span><br><span class=\"line\">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object. </span><br><span class=\"line\">       \t                                    *   The association is not made atomically. */</span><br><span class=\"line\">    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**&lt; Specifies that the associated object is copied. </span><br><span class=\"line\">                                            *   The association is not made atomically. */</span><br><span class=\"line\">    OBJC_ASSOCIATION_RETAIN = 01401,       /**&lt; Specifies a strong reference to the associated object.</span><br><span class=\"line\">                                            *   The association is made atomically. */</span><br><span class=\"line\">    OBJC_ASSOCIATION_COPY = 01403          /**&lt; Specifies that the associated object is copied.</span><br><span class=\"line\">                                            *   The association is made atomically. */</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p> 第二个用于获取关联的对象:</p>\n<p><code>objc_getAssociatedObject(id object, const void *key)</code>用于获取关联对象的值。这里需要注意的是返回值类型为Object类型，注意一些不是Object类型的例如：BOOL是结构类型。</p>\n<p>第三个用于断开关联的对象：</p>\n<p><code>objc_removeAssociatedObjects(id object)</code> 是断开关联，需要注意的是他会断开所有关联，所以不推荐这种方式。需要断开关联的时候使用<code>objc_setAssociatedObject</code>函数，传入<code>nil</code>值即可。</p>\n","site":{"data":{}},"excerpt":"<p>今天简单的记录一下怎么用块来实现Button的点击事件</p>\n<p>首先，我想要的做的效果是直接通过类方法来初始化Button，然后同时把点击事件的操作放在块中，最后返回创建好的Button。</p>\n<ul>\n<li><p>第一步，创建一个UIButton的扩展(category)</p>\n</li>\n<li><p>第二步，在h文件中添加初始化Button的类方法声明</p></li></ul>","more":"\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;UIKit/UIKit.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef void (^ActionBlock)(UIButton *button);</span><br><span class=\"line\"></span><br><span class=\"line\">@interface UIButton (Block)</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic,copy) ActionBlock actionBlock;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> 通过block对Button的点击事件进行封装</span><br><span class=\"line\"> </span><br><span class=\"line\"> @param frame frame大小</span><br><span class=\"line\"> @param title 内容</span><br><span class=\"line\"> @param titleColor 内容颜色</span><br><span class=\"line\"> @param bgImgName 背景图片</span><br><span class=\"line\"> @param completion 点击事件</span><br><span class=\"line\"> @return Button</span><br><span class=\"line\"> */</span><br><span class=\"line\">+ (UIButton *)createButtonWithFrame:(CGRect)frame</span><br><span class=\"line\">                              title:(NSString *)title</span><br><span class=\"line\">                         titleColor:(UIColor *)titleColor</span><br><span class=\"line\">                        bgImageName:(NSString *)bgImgName</span><br><span class=\"line\">                        actionBlock:(void(^)(UIButton *sender))completion;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> 通过block对Button的点击事件进行封装</span><br><span class=\"line\"></span><br><span class=\"line\"> @return 返回初始化后的button</span><br><span class=\"line\"> */</span><br><span class=\"line\">+ (UIButton *)button;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>第三步，在m文件中实现方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;UIButton+Block.h&quot;</span><br><span class=\"line\">#import &lt;objc/runtime.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">static NSString *keyWithMethod = @&quot;keyWithMethod&quot;; //关联对象的key</span><br><span class=\"line\">static NSString *keyWithBlock = @&quot;keyWithBlock&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation UIButton (Block)</span><br><span class=\"line\"></span><br><span class=\"line\">+ (UIButton *)createButtonWithFrame:(CGRect)frame</span><br><span class=\"line\">                              title:(NSString *)title</span><br><span class=\"line\">                         titleColor:(UIColor *)titleColor</span><br><span class=\"line\">                        bgImageName:(NSString *)bgImgName</span><br><span class=\"line\">                        actionBlock:(void (^)(UIButton *sender))completion &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    UIButton *button = [UIButton buttonWithType:UIButtonTypeRoundedRect];</span><br><span class=\"line\">    button.frame = frame;</span><br><span class=\"line\">    [button setTitle:title forState:UIControlStateNormal];</span><br><span class=\"line\">    [button setTitleColor:titleColor forState:UIControlStateNormal];</span><br><span class=\"line\">    [button setBackgroundImage:[UIImage imageNamed:bgImgName] forState:UIControlStateNormal];</span><br><span class=\"line\">    [button addTarget:button action:@selector(buttonTapAction:) forControlEvents:UIControlEventTouchUpInside];</span><br><span class=\"line\">    </span><br><span class=\"line\">    /*</span><br><span class=\"line\">     *用runtime中的函数通过key关联对象</span><br><span class=\"line\">     *</span><br><span class=\"line\">     *objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key, id _Nullable value, objc_AssociationPolicy policy)</span><br><span class=\"line\">     *id object                 表示关联者，是一个对象，变量名也是object</span><br><span class=\"line\">     *const void *key           获取被关联者的索引</span><br><span class=\"line\">     *id value                  被关联者，这里是一个block</span><br><span class=\"line\">     *objc_AssociationPolicy    policy 关联时采用的协议，有assign，retain，copy等协议，一般使用OBJC_ASSOCIATION_RETAIN_NONATOMIC</span><br><span class=\"line\">     */</span><br><span class=\"line\">    objc_setAssociatedObject(button, &amp;keyWithMethod, completion, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return button;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (UIButton *)button &#123;</span><br><span class=\"line\">    UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];</span><br><span class=\"line\">    [button addTarget:button action:@selector(buttonTapAction:) forControlEvents:UIControlEventTouchUpInside];</span><br><span class=\"line\">    return button;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setActionBlock:(ActionBlock)actionBlock&#123;</span><br><span class=\"line\">    objc_setAssociatedObject(self, &amp;keyWithBlock, actionBlock, OBJC_ASSOCIATION_COPY_NONATOMIC );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (ActionBlock)actionBlock&#123;</span><br><span class=\"line\">    return objc_getAssociatedObject(self ,&amp;keyWithBlock);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)buttonTapAction:(UIButton *)button &#123;</span><br><span class=\"line\">    //通过key获取被关联对象</span><br><span class=\"line\">    //objc_getAssociatedObject(id object, const void *key)</span><br><span class=\"line\">    void (^tapBlock)(UIButton *) = objc_getAssociatedObject(button, &amp;keyWithMethod);</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (tapBlock) &#123;</span><br><span class=\"line\">        tapBlock(button);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    ActionBlock block2 = (ActionBlock)objc_getAssociatedObject(button, &amp;keyWithBlock);</span><br><span class=\"line\">    if(block2)&#123;</span><br><span class=\"line\">        block2(button);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>第四步，简单的使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIButton *button = [UIButton createButtonWithFrame:CGRectMake(20, 100, 200, 200) title:@&quot;带块的button&quot; titleColor:[UIColor redColor] bgImageName:@&quot;&quot; actionBlock:^(UIButton *button) &#123;</span><br><span class=\"line\">        NSString *str = [button titleForState:UIControlStateNormal];</span><br><span class=\"line\">        NSLog(@&quot;%@&quot;,str);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">[self.view addSubview:button];</span><br><span class=\"line\"></span><br><span class=\"line\">UIButton *btn = [UIButton button];</span><br><span class=\"line\">btn.frame = CGRectMake(20, 100, 200, 200);</span><br><span class=\"line\">[btn setTitle:@&quot;1234&quot; forState:UIControlStateNormal];</span><br><span class=\"line\">btn.actionBlock = ^(UIButton *button) &#123;</span><br><span class=\"line\">    NSString *str = [button titleForState:UIControlStateNormal];</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;,str);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">[self.view addSubview:btn];</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>注意：</strong>由于扩展不能直接添加属性，所以要用运行时来自己添加属性的<code>get</code>、<code>set</code>方法。</p>\n<p>最后，简单的了解一下<code>objc_setAssociatedObject</code>，<code>objc_getAssociatedObject</code>方法</p>\n<p>​    Objective-C有两个扩展机制：<code>Associative</code>和<code>Category</code>。<code>Category</code>用来扩展类方法，<code>Associative</code>用于扩展属性。<code>Associative</code>机制的原理是把两个对象关联起来，让一个对象成为另外一个对象的一部分。它可以在不修改类的定义的前提下为其对象增加存储空间，这在我们无法访问类的源码时(例如给UILable添加一个<code>selected</code>的BOOL属性)是非常有用的。<code>Associative</code>基于关键字的，因此我们可以使用不同的关键字为任何对象添加任意多的<code>Associative</code>。<code>Associative</code>可以保证被关联的对象在对象的整个生命周期都是可用的。<code>Associative</code>基于runtime，是运行时里的东西,所以头文件需要引用<code>#import&lt;objc/runtime.h&gt;</code>文件。</p>\n<p><code>Associative</code>提供了3个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)</span><br><span class=\"line\">- objc_getAssociatedObject(id object, const void *key)</span><br><span class=\"line\">- objc_removeAssociatedObjects(id object)</span><br></pre></td></tr></table></figure>\n<p>第一个用于给关联对象赋值：    </p>\n<p><code>objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)</code>注意的是返回值类型为Object类型，注意一些不是Object类型的例如：BOOL是结构类型。当碰到这种情况可以考虑通过中间类型来转换，如设置BOOL类型属性的时候可以转换为NSNumber类型，获取的时候再转换成BOOL类型即可。<br>四个参数分别是：源对象、关键字、关联对象和关联策略。<br>关键字是一个void类型的指针，例如<code>static NSString *keyWithMethod = @&quot;keyWithMethod&quot;; //关联对象的key</code>每一个关联的关键字必须是唯一的。</p>\n<p>关联策略是枚举类型，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</span><br><span class=\"line\">    OBJC_ASSOCIATION_ASSIGN = 0,           /**&lt; Specifies a weak reference to the associated object. */</span><br><span class=\"line\">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object. </span><br><span class=\"line\">       \t                                    *   The association is not made atomically. */</span><br><span class=\"line\">    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**&lt; Specifies that the associated object is copied. </span><br><span class=\"line\">                                            *   The association is not made atomically. */</span><br><span class=\"line\">    OBJC_ASSOCIATION_RETAIN = 01401,       /**&lt; Specifies a strong reference to the associated object.</span><br><span class=\"line\">                                            *   The association is made atomically. */</span><br><span class=\"line\">    OBJC_ASSOCIATION_COPY = 01403          /**&lt; Specifies that the associated object is copied.</span><br><span class=\"line\">                                            *   The association is made atomically. */</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p> 第二个用于获取关联的对象:</p>\n<p><code>objc_getAssociatedObject(id object, const void *key)</code>用于获取关联对象的值。这里需要注意的是返回值类型为Object类型，注意一些不是Object类型的例如：BOOL是结构类型。</p>\n<p>第三个用于断开关联的对象：</p>\n<p><code>objc_removeAssociatedObjects(id object)</code> 是断开关联，需要注意的是他会断开所有关联，所以不推荐这种方式。需要断开关联的时候使用<code>objc_setAssociatedObject</code>函数，传入<code>nil</code>值即可。</p>"},{"title":"面试体验","date":"2017-12-06T04:06:00.000Z","_content":"\n\n\n这两天，做了两回面试官，就在这小小的记录一下，放松一下我那紧张的小心肝(搞的像我自己参加面试一样)，顺便记录一下以后面试的时候要注意一些神马东西~\n\n拿到面试者的简历的时候，简单的看了一下，然后看了一下面试题做的情况，那人做的真心不怎么样，给我的感觉不怎么好，所以说如果你面试的时候有笔试题，你做的好不好是给面试官的第一印象。\n\n下面总结一下要注意的事项：\n\n<!-- more -->\n\n- 不要说废话！不要说废话！不要说废话！重要的说三遍\n\n- 自我介绍：简短点 ，把自己会什么说出来，以前工作的公司一句带过，我要知道你以前在哪工作有什么用？说说自己在工作中做的什么。(3分钟，大学到现在，不要说空洞没用的话，讲自己学的什么，实际有用到的)。\n\n- 技术点：不要说自己用过什么，大家都用过，你用过这个有啥奇怪的，说说是怎么用的，有没有什么改进方案。\n\n- 介绍自己的app的时候，不要光介绍app有什么功能，要说这些功能怎么实现的，讲技术点。最好把app拿出来演示一下。\n\n- 充分准备好每次面试~\n\n技术知识点：(我自己也要下去恶补)\n\n>- 基本知识，算法，内存管理，设计模式，库的设计，常用三方库实现原理(详细一些)\n>- 线程(GCD、NSThread、队列)、cell的优化、NSNotification和KVO、块(block)、runtime(运行时)、iOS内购、加密技术。\n>- 数据库操作、文件操作、判断条件。\n>- 新出来的SDK(最前沿，新技术)、博客。\n\n\n好了，暂时就先写这么多吧\n后面有内容再慢慢补充吧！","source":"_posts/面试.md","raw":"---\ntitle: 面试体验\ndate: 2017-12-06 12:06\ntags: iOS\ncategories: iOS Tips\n---\n\n\n\n这两天，做了两回面试官，就在这小小的记录一下，放松一下我那紧张的小心肝(搞的像我自己参加面试一样)，顺便记录一下以后面试的时候要注意一些神马东西~\n\n拿到面试者的简历的时候，简单的看了一下，然后看了一下面试题做的情况，那人做的真心不怎么样，给我的感觉不怎么好，所以说如果你面试的时候有笔试题，你做的好不好是给面试官的第一印象。\n\n下面总结一下要注意的事项：\n\n<!-- more -->\n\n- 不要说废话！不要说废话！不要说废话！重要的说三遍\n\n- 自我介绍：简短点 ，把自己会什么说出来，以前工作的公司一句带过，我要知道你以前在哪工作有什么用？说说自己在工作中做的什么。(3分钟，大学到现在，不要说空洞没用的话，讲自己学的什么，实际有用到的)。\n\n- 技术点：不要说自己用过什么，大家都用过，你用过这个有啥奇怪的，说说是怎么用的，有没有什么改进方案。\n\n- 介绍自己的app的时候，不要光介绍app有什么功能，要说这些功能怎么实现的，讲技术点。最好把app拿出来演示一下。\n\n- 充分准备好每次面试~\n\n技术知识点：(我自己也要下去恶补)\n\n>- 基本知识，算法，内存管理，设计模式，库的设计，常用三方库实现原理(详细一些)\n>- 线程(GCD、NSThread、队列)、cell的优化、NSNotification和KVO、块(block)、runtime(运行时)、iOS内购、加密技术。\n>- 数据库操作、文件操作、判断条件。\n>- 新出来的SDK(最前沿，新技术)、博客。\n\n\n好了，暂时就先写这么多吧\n后面有内容再慢慢补充吧！","slug":"面试","published":1,"updated":"2017-12-06T06:45:11.279Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb1u1v8a001a1us0fjngf74i","content":"<p>这两天，做了两回面试官，就在这小小的记录一下，放松一下我那紧张的小心肝(搞的像我自己参加面试一样)，顺便记录一下以后面试的时候要注意一些神马东西~</p>\n<p>拿到面试者的简历的时候，简单的看了一下，然后看了一下面试题做的情况，那人做的真心不怎么样，给我的感觉不怎么好，所以说如果你面试的时候有笔试题，你做的好不好是给面试官的第一印象。</p>\n<p>下面总结一下要注意的事项：</p>\n<a id=\"more\"></a>\n<ul>\n<li><p>不要说废话！不要说废话！不要说废话！重要的说三遍</p>\n</li>\n<li><p>自我介绍：简短点 ，把自己会什么说出来，以前工作的公司一句带过，我要知道你以前在哪工作有什么用？说说自己在工作中做的什么。(3分钟，大学到现在，不要说空洞没用的话，讲自己学的什么，实际有用到的)。</p>\n</li>\n<li><p>技术点：不要说自己用过什么，大家都用过，你用过这个有啥奇怪的，说说是怎么用的，有没有什么改进方案。</p>\n</li>\n<li><p>介绍自己的app的时候，不要光介绍app有什么功能，要说这些功能怎么实现的，讲技术点。最好把app拿出来演示一下。</p>\n</li>\n<li><p>充分准备好每次面试~</p>\n</li>\n</ul>\n<p>技术知识点：(我自己也要下去恶补)</p>\n<blockquote>\n<ul>\n<li>基本知识，算法，内存管理，设计模式，库的设计，常用三方库实现原理(详细一些)</li>\n<li>线程(GCD、NSThread、队列)、cell的优化、NSNotification和KVO、块(block)、runtime(运行时)、iOS内购、加密技术。</li>\n<li>数据库操作、文件操作、判断条件。</li>\n<li>新出来的SDK(最前沿，新技术)、博客。</li>\n</ul>\n</blockquote>\n<p>好了，暂时就先写这么多吧<br>后面有内容再慢慢补充吧！</p>\n","site":{"data":{}},"excerpt":"<p>这两天，做了两回面试官，就在这小小的记录一下，放松一下我那紧张的小心肝(搞的像我自己参加面试一样)，顺便记录一下以后面试的时候要注意一些神马东西~</p>\n<p>拿到面试者的简历的时候，简单的看了一下，然后看了一下面试题做的情况，那人做的真心不怎么样，给我的感觉不怎么好，所以说如果你面试的时候有笔试题，你做的好不好是给面试官的第一印象。</p>\n<p>下面总结一下要注意的事项：</p>","more":"<ul>\n<li><p>不要说废话！不要说废话！不要说废话！重要的说三遍</p>\n</li>\n<li><p>自我介绍：简短点 ，把自己会什么说出来，以前工作的公司一句带过，我要知道你以前在哪工作有什么用？说说自己在工作中做的什么。(3分钟，大学到现在，不要说空洞没用的话，讲自己学的什么，实际有用到的)。</p>\n</li>\n<li><p>技术点：不要说自己用过什么，大家都用过，你用过这个有啥奇怪的，说说是怎么用的，有没有什么改进方案。</p>\n</li>\n<li><p>介绍自己的app的时候，不要光介绍app有什么功能，要说这些功能怎么实现的，讲技术点。最好把app拿出来演示一下。</p>\n</li>\n<li><p>充分准备好每次面试~</p>\n</li>\n</ul>\n<p>技术知识点：(我自己也要下去恶补)</p>\n<blockquote>\n<ul>\n<li>基本知识，算法，内存管理，设计模式，库的设计，常用三方库实现原理(详细一些)</li>\n<li>线程(GCD、NSThread、队列)、cell的优化、NSNotification和KVO、块(block)、runtime(运行时)、iOS内购、加密技术。</li>\n<li>数据库操作、文件操作、判断条件。</li>\n<li>新出来的SDK(最前沿，新技术)、博客。</li>\n</ul>\n</blockquote>\n<p>好了，暂时就先写这么多吧<br>后面有内容再慢慢补充吧！</p>"},{"title":"iOS崩溃日志收集上传","date":"2017-12-05T10:06:00.000Z","_content":"\n需要保存到日志里面的信息有：手机号  设备标识UUID  设备类型  网络类型  是否越狱 版本号 操作系统版本   时间   崩溃原因\n\n```objective-c\n#import <Foundation/Foundation.h>\n\n/**\n 崩溃日志收集\n */\n@interface LQUncaughtExceptionHandler : NSObject\n\n+ (void)setDefaultHandler;\n\n+ (NSUncaughtExceptionHandler *)getHandler;\n\n+ (void)takeException:(NSException *)exception;\n\n@end\n```\n<!--more -->\n\n```objective-c\n#import \"LQUncaughtExceptionHandler.h\"\n#import \"LoginInfoManager.h\"\n#import \"DeviceInfo.h\"\n\n/**\n 沙盒地址\n\n @return 返回沙盒地址字符串\n */\nNSString *applicationDocumentsDirectory() {\n\n    return  [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];\n}\n\nvoid UncaughtExceptionHandler(NSException *exception) {\n    NSDate   *date = [NSDate date];\n\tNSDateFormatter *formatter = [[NSDateFormatter alloc] init];\n\t[formatter setDateStyle:NSDateFormatterMediumStyle];\n\t[formatter setTimeStyle:NSDateFormatterShortStyle];\n\t[formatter setDateFormat:@\"YYYY-MM-dd hh:mm:ss\"];\n\n\tNSString *mobile = [LoginInfoManager sharedInstance].user.mobile;\n\tNSString *uuid = [DeviceInfo getDeviceNumber];\n\tNSString *deviceString = [DeviceInfo deviceString];\n\tNSString *network = [DeviceInfo getNetWork];\n\tNSString *prisonBreak = [DeviceInfo getSystemStatus];\n\tNSString *version = APP_VERSION;\n\tNSString *phoneVersion = [[UIDevice currentDevice] systemVersion];\n\tNSString *dateTime = [formatter stringFromDate:date];\n\tNSString *name = [exception name];\n\tNSString *reason = [exception reason];   // 崩溃的原因  可以有崩溃的原因(数组越界,字典nil,调用未知方法...) 崩溃的控制器以及方法\n\tNSArray  *callStackSymbolsArray = [exception callStackSymbols];\n\n\tNSString *logInfo = [NSString stringWithFormat:@\"========异常错误报告========\\nmobile:%@\\nuuid:%@\\ndeviceString:%@\\nnet:%@\\nprisonBreak:%@\\nversion:%@\\ndateTime:%@\\nphoneVersion:%@\\nname:%@\\nreason:\\n%@\\ncallStackSymbols:\\n%@\",mobile,uuid,deviceString,network,prisonBreak,version,phoneVersion,dateTime,name,reason,[callStackSymbolsArray componentsJoinedByString:@\"\\n\"]];\n\tNSString *path = [applicationDocumentsDirectory() stringByAppendingPathComponent:@\"ExceptionLog.txt\"];\n\t[logInfo writeToFile:path atomically:YES encoding:NSUTF8StringEncoding error:nil];\n}\n```\n\n```objective-c\n@implementation LQUncaughtExceptionHandler\n\n// 沙盒地址\n- (NSString *)applicationDocumentsDirectory {\n\treturn [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];\n}\n\n+ (void)setDefaultHandler {\n  NSSetUncaughtExceptionHandler(&UncaughtExceptionHandler);\n}\n\n+ (NSUncaughtExceptionHandler *)getHandler {\n\treturn NSGetUncaughtExceptionHandler();\n}\n\n+ (void)takeException:(NSException *)exception {\n  \tNSDate   *date = [NSDate date];\n    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];\n    [formatter setDateStyle:NSDateFormatterMediumStyle];\n    [formatter setTimeStyle:NSDateFormatterShortStyle];\n    [formatter setDateFormat:@\"YYYY-MM-dd hh:mm:ss\"];\n    \n    NSString *mobile = [LoginInfoManager sharedInstance].user.mobile;\n    NSString *uuid = [DeviceInfo getDeviceNumber];\n    NSString *deviceString = [DeviceInfo deviceString];\n    NSString *network = [DeviceInfo getNetWork];\n    NSString *prisonBreak = [DeviceInfo getSystemStatus];\n    NSString *version = APP_VERSION;\n    NSString *phoneVersion = [[UIDevice currentDevice] systemVersion];\n    NSString *reason = [exception reason];   // 崩溃的原因  可以有崩溃的原因(数组越界,字典nil,调用未知方法...) 崩溃的控制器以及方法\n    NSString *name = [exception name];\n    NSString *dateTime = [formatter stringFromDate:date];\n    NSArray  *callStackSymbolsArray = [exception callStackSymbols];\n    \n    NSString *logInfo = [NSString stringWithFormat:@\"========异常错误报告========\\nmobile:%@\\nuuid:%@\\ndeviceString:%@\\nnet:%@\\nprisonBreak:%@\\nversion:%@\\ndateTime:%@\\nphoneVersion:%@\\nname:%@\\nreason:\\n%@\\ncallStackSymbols:\\n%@\",mobile,uuid,deviceString,network,prisonBreak,version,dateTime,phoneVersion,name,reason,[callStackSymbolsArray componentsJoinedByString:@\"\\n\"]];\n    NSString *path = [applicationDocumentsDirectory() stringByAppendingPathComponent:@\"ExceptionLog.txt\"];\n    [logInfo writeToFile:path atomically:YES encoding:NSUTF8StringEncoding error:nil];\n}\n\n@end\n```\n\n\n\n```objective-c\n#import <Foundation/Foundation.h>\n#import <SystemConfiguration/CaptiveNetwork.h>  //  获取wifi\n#import <CoreMotion/CoreMotion.h>  //  加速计\n#import <ifaddrs.h>    //获取Ip\n#import <arpa/inet.h>\n#import <net/if.h>\n#define IOS_CELLULAR    @\"pdp_ip0\"\n#define IOS_WIFI        @\"en0\"\n#define IOS_VPN         @\"utun0\"\n#define IP_ADDR_IPv4    @\"ipv4\"\n#define IP_ADDR_IPv6    @\"ipv6\"\n\n@interface DeviceInfo : NSObject\n#pragma mark - 获取设备当前网络IP地址\n+ (NSString *)getIPAddress:(BOOL)preferIPv4;\n+ (NSString *)getWifiName;\n\n+ (NSString *)getDeviceNumber;\n+ (NSString *)getSystemStatus;  // 0 代表没有越狱。 1 代表越狱\n+ (NSString *)getSystemVersion;\n+ (NSString *)deviceString;\n+ (NSString *)getNetWork;\n@end\n```\n\n```objective-c\n# import \"DeviceInfo.h\"\n# import \"sys/utsname.h\"\n# import <CoreTelephony/CoreTelephonyDefines.h>\n# import <CoreTelephony/CTTelephonyNetworkInfo.h>\n# import <AFNetworkReachabilityManager.h> //有用到AFNetworking\n\n# define ARRAY_SIZE(a) sizeof(a)/sizeof(a[0])    //获取是否越狱\n\nconst char* jailbreak_tool_pathes[] = {\n\t\"/Applications/Cydia.app\",\n\t\"/Library/MobileSubstrate/MobileSubstrate.dylib\",\n\t\"/bin/bash\",\n\t\"/usr/sbin/sshd\",\n\t\"/etc/apt\"\n};\n```\n\n```objective-c\n@implementation DeviceInfo\n\n+ (NSString *)getIPAddress:(BOOL)preferIPv4\n{\n    NSArray *searchArray = preferIPv4 ?\n    @[ IOS_VPN @\"/\" IP_ADDR_IPv4, IOS_VPN @\"/\" IP_ADDR_IPv6, IOS_WIFI @\"/\" IP_ADDR_IPv4, IOS_WIFI @\"/\" IP_ADDR_IPv6, IOS_CELLULAR @\"/\" IP_ADDR_IPv4, IOS_CELLULAR @\"/\" IP_ADDR_IPv6 ] :\n    @[ IOS_VPN @\"/\" IP_ADDR_IPv6, IOS_VPN @\"/\" IP_ADDR_IPv4, IOS_WIFI @\"/\" IP_ADDR_IPv6, IOS_WIFI @\"/\" IP_ADDR_IPv4, IOS_CELLULAR @\"/\" IP_ADDR_IPv6, IOS_CELLULAR @\"/\" IP_ADDR_IPv4 ] ;\n    \n    NSDictionary *addresses = [self getIPAddresses];\n    \n    \n    __block NSString *address;\n    [searchArray enumerateObjectsUsingBlock:^(NSString *key, NSUInteger idx, BOOL *stop)\n     {\n         address = addresses[key];\n         //筛选出IP地址格式\n         if([self isValidatIP:address]) *stop = YES;\n     } ];\n    return address ? address : @\"0.0.0.0\";\n}\n\n+ (BOOL)isValidatIP:(NSString *)ipAddress {\n    if (ipAddress.length == 0) {\n        return NO;\n    }\n    NSString *urlRegEx = @\"^([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.\"\n    \"([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.\"\n    \"([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.\"\n    \"([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])$\";\n    \n    NSError *error;\n    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:urlRegEx options:0 error:&error];\n    \n    if (regex != nil) {\n        NSTextCheckingResult *firstMatch=[regex firstMatchInString:ipAddress options:0 range:NSMakeRange(0, [ipAddress length])];\n        \n        if (firstMatch) {\n            NSRange resultRange = [firstMatch rangeAtIndex:0];\n            NSString *result=[ipAddress substringWithRange:resultRange];\n            //输出结果\n            NSLog(@\"%@\",result);\n            return YES;\n        }\n    }\n    return NO;\n}\n\n+ (NSDictionary *)getIPAddresses\n{\n    NSMutableDictionary *addresses = [NSMutableDictionary dictionaryWithCapacity:8];\n    \n    // retrieve the current interfaces - returns 0 on success\n    struct ifaddrs *interfaces;\n    if(!getifaddrs(&interfaces)) {\n        // Loop through linked list of interfaces\n        struct ifaddrs *interface;\n        for(interface=interfaces; interface; interface=interface->ifa_next) {\n            if(!(interface->ifa_flags & IFF_UP) /* || (interface->ifa_flags & IFF_LOOPBACK) */ ) {\n                continue; // deeply nested code harder to read\n            }\n            const struct sockaddr_in *addr = (const struct sockaddr_in*)interface->ifa_addr;\n            char addrBuf[ MAX(INET_ADDRSTRLEN, INET6_ADDRSTRLEN) ];\n            if(addr && (addr->sin_family==AF_INET || addr->sin_family==AF_INET6)) {\n                NSString *name = [NSString stringWithUTF8String:interface->ifa_name];\n                NSString *type;\n                if(addr->sin_family == AF_INET) {\n                    if(inet_ntop(AF_INET, &addr->sin_addr, addrBuf, INET_ADDRSTRLEN)) {\n                        type = IP_ADDR_IPv4;\n                    }\n                } else {\n                    const struct sockaddr_in6 *addr6 = (const struct sockaddr_in6*)interface->ifa_addr;\n                    if(inet_ntop(AF_INET6, &addr6->sin6_addr, addrBuf, INET6_ADDRSTRLEN)) {\n                        type = IP_ADDR_IPv6;\n                    }\n                }\n                if(type) {\n                    NSString *key = [NSString stringWithFormat:@\"%@/%@\", name, type];\n                    addresses[key] = [NSString stringWithUTF8String:addrBuf];\n                }\n            }\n        }\n        // Free memory\n        freeifaddrs(interfaces);\n    }\n    return [addresses count] ? addresses : nil;\n}\n\n\n+ (NSString *)getWifiName\n{\n    NSString *wifiName = @\"\";\n    \n    CFArrayRef wifiInterfaces = CNCopySupportedInterfaces();\n    \n    if (!wifiInterfaces) {\n        return @\"\";\n    }\n    \n    NSArray *interfaces = (__bridge NSArray *)wifiInterfaces;\n    \n    for (NSString *interfaceName in interfaces) {\n        CFDictionaryRef dictRef = CNCopyCurrentNetworkInfo((__bridge CFStringRef)(interfaceName));\n        \n        if (dictRef) {\n            NSDictionary *networkInfo = (__bridge NSDictionary *)dictRef;\n            NSLog(@\"network info -> %@\", networkInfo);\n            wifiName = [networkInfo objectForKey:(__bridge NSString *)kCNNetworkInfoKeySSID];\n            \n            CFRelease(dictRef);\n        }\n    }\n    \n    CFRelease(wifiInterfaces);\n    return wifiName;\n}\n\n+ (NSString *)getDeviceNumber{\n    NSString *deviceNumber = [self uuid];  //自己项目里面获取UUID的方法\n    return deviceNumber;\n}\n\n+ (NSString *)getSystemVersion{\n    NSString *systemVersion = [[UIDevice currentDevice] systemVersion];\n    return systemVersion;\n}\n\n+ (NSString *)getSystemStatus{\n    BOOL isJailBreak = [self checkIsJailBreak];\n    NSString *systemStatus = @\"\";\n    if (isJailBreak) {\n        systemStatus = @\"1\";\n    }else{\n        systemStatus = @\"0\";\n    }\n    return systemStatus;\n}\n\n+ (BOOL)checkIsJailBreak{\n    for (int i=0; i<ARRAY_SIZE(jailbreak_tool_pathes); i++) {\n        if ([[NSFileManager defaultManager] fileExistsAtPath:[NSString stringWithUTF8String:jailbreak_tool_pathes[i]]]) {\n            NSLog(@\"The device is jail broken!\");\n            return YES;\n        }\n    }\n    NSLog(@\"The device is NOT jail broken!\");\n    return NO;\n}\n\n+ (NSString *)deviceString {\n    struct utsname systemInfo;\n    uname(&systemInfo);\n    return [NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding];\n}\n\n+ (NSString *)getNetWork {\n    \n    UIApplication *app = [UIApplication sharedApplication];\n    NSArray *children;\n    if ([[app valueForKeyPath:@\"_statusBar\"] isKindOfClass:NSClassFromString(@\"UIStatusBar_Modern\")]) {\n        return [self getIphoneXNetInfo];\n    } else {\n        children = [[[app valueForKeyPath:@\"_statusBar\"] valueForKeyPath:@\"foregroundView\"] subviews];\n    }\n    int type = 0;\n    for (id child in children) {\n        if ([child isKindOfClass:[NSClassFromString(@\"UIStatusBarDataNetworkItemView\") class]]) {\n            type = [[child valueForKeyPath:@\"dataNetworkType\"] intValue];\n        }\n    }\n\n    NSString *stateString = @\"wifi\";\n    switch (type) {\n        case 0:\n            stateString = @\"\";\n            break;\n\n        case 1:\n            stateString = @\"2G\";\n            break;\n\n        case 2:\n            stateString = @\"3G\";\n            break;\n\n        case 3:\n            stateString = @\"4G\";\n            break;\n\n        case 4:\n            stateString = @\"LTE\";\n            break;\n\n        case 5:\n            stateString = @\"wifi\";\n            break;\n\n        default:\n            break;\n    }\n\n    return stateString;\n}\n\n+ (NSString *)getIphoneXNetInfo {\n    AFNetworkReachabilityStatus status = [AFNetworkReachabilityManager sharedManager].networkReachabilityStatus;\n    if(status == AFNetworkReachabilityStatusReachableViaWiFi) {\n        return @\"wifi\";\n    }else if(status == AFNetworkReachabilityStatusNotReachable) {\n        return @\"\";\n    }else {\n        NSArray *typeStrings2G = @[CTRadioAccessTechnologyEdge,\n                                   CTRadioAccessTechnologyGPRS,\n                                   CTRadioAccessTechnologyCDMA1x];\n        NSArray *typeStrings3G = @[CTRadioAccessTechnologyHSDPA,\n                                   CTRadioAccessTechnologyWCDMA,\n                                   CTRadioAccessTechnologyHSUPA,\n                                   CTRadioAccessTechnologyCDMAEVDORev0,\n                                   CTRadioAccessTechnologyCDMAEVDORevA,\n                                   CTRadioAccessTechnologyCDMAEVDORevB,\n                                   CTRadioAccessTechnologyeHRPD];\n        \n        NSArray *typeStrings4G = @[CTRadioAccessTechnologyLTE];\n        // 该 API 在 iOS7 以上系统才有效\n        if ([[[UIDevice currentDevice] systemVersion] floatValue] >= 7.0) {\n            CTTelephonyNetworkInfo *teleInfo= [[CTTelephonyNetworkInfo alloc] init];\n            NSString *accessString = teleInfo.currentRadioAccessTechnology;\n            if ([typeStrings4G containsObject:accessString]) {\n                return @\"4G\";\n            } else if ([typeStrings3G containsObject:accessString]) {\n                return @\"3G\";\n            } else if ([typeStrings2G containsObject:accessString]) {\n                return @\"2G\";\n            } else {\n                return @\"\";\n            }\n        } else {\n            return @\"\";\n        }\n    }\n}\n\n@end\n```\n\n\n\n最后一步，在项目的APPDelegate里面进行调用一下就可以了~\n\n```objective-c\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n   \n    self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];\n    self.window.backgroundColor = [UIColor whiteColor];\n    [self.window makeKeyAndVisible];\n    //收集崩溃日志\n    [self uploadExceptionLog];\n    return YES;\n}\n```\n\n\n\n```objective-c\n- (void)uploadExceptionLog {\n    [YQUncaughtExceptionHandler setDefaultHandler];\n    // 发送崩溃日志\n    NSString *path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];\n    NSString *dataPath = [path stringByAppendingPathComponent:@\"ExceptionLog.txt\"];\n    NSData *data = [NSData dataWithContentsOfFile:dataPath];\n    if (data != nil) {\n        [self sendExceptionLogWithData:data path:dataPath];\n    }\n}\n```\n\n 到这就ok了，祝工作愉快！","source":"_posts/iOS崩溃日志.md","raw":"---\ntitle: iOS崩溃日志收集上传\ndate: 2017-12-05 18:06\ntags: iOS\ncategories: iOS Tips\n---\n\n需要保存到日志里面的信息有：手机号  设备标识UUID  设备类型  网络类型  是否越狱 版本号 操作系统版本   时间   崩溃原因\n\n```objective-c\n#import <Foundation/Foundation.h>\n\n/**\n 崩溃日志收集\n */\n@interface LQUncaughtExceptionHandler : NSObject\n\n+ (void)setDefaultHandler;\n\n+ (NSUncaughtExceptionHandler *)getHandler;\n\n+ (void)takeException:(NSException *)exception;\n\n@end\n```\n<!--more -->\n\n```objective-c\n#import \"LQUncaughtExceptionHandler.h\"\n#import \"LoginInfoManager.h\"\n#import \"DeviceInfo.h\"\n\n/**\n 沙盒地址\n\n @return 返回沙盒地址字符串\n */\nNSString *applicationDocumentsDirectory() {\n\n    return  [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];\n}\n\nvoid UncaughtExceptionHandler(NSException *exception) {\n    NSDate   *date = [NSDate date];\n\tNSDateFormatter *formatter = [[NSDateFormatter alloc] init];\n\t[formatter setDateStyle:NSDateFormatterMediumStyle];\n\t[formatter setTimeStyle:NSDateFormatterShortStyle];\n\t[formatter setDateFormat:@\"YYYY-MM-dd hh:mm:ss\"];\n\n\tNSString *mobile = [LoginInfoManager sharedInstance].user.mobile;\n\tNSString *uuid = [DeviceInfo getDeviceNumber];\n\tNSString *deviceString = [DeviceInfo deviceString];\n\tNSString *network = [DeviceInfo getNetWork];\n\tNSString *prisonBreak = [DeviceInfo getSystemStatus];\n\tNSString *version = APP_VERSION;\n\tNSString *phoneVersion = [[UIDevice currentDevice] systemVersion];\n\tNSString *dateTime = [formatter stringFromDate:date];\n\tNSString *name = [exception name];\n\tNSString *reason = [exception reason];   // 崩溃的原因  可以有崩溃的原因(数组越界,字典nil,调用未知方法...) 崩溃的控制器以及方法\n\tNSArray  *callStackSymbolsArray = [exception callStackSymbols];\n\n\tNSString *logInfo = [NSString stringWithFormat:@\"========异常错误报告========\\nmobile:%@\\nuuid:%@\\ndeviceString:%@\\nnet:%@\\nprisonBreak:%@\\nversion:%@\\ndateTime:%@\\nphoneVersion:%@\\nname:%@\\nreason:\\n%@\\ncallStackSymbols:\\n%@\",mobile,uuid,deviceString,network,prisonBreak,version,phoneVersion,dateTime,name,reason,[callStackSymbolsArray componentsJoinedByString:@\"\\n\"]];\n\tNSString *path = [applicationDocumentsDirectory() stringByAppendingPathComponent:@\"ExceptionLog.txt\"];\n\t[logInfo writeToFile:path atomically:YES encoding:NSUTF8StringEncoding error:nil];\n}\n```\n\n```objective-c\n@implementation LQUncaughtExceptionHandler\n\n// 沙盒地址\n- (NSString *)applicationDocumentsDirectory {\n\treturn [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];\n}\n\n+ (void)setDefaultHandler {\n  NSSetUncaughtExceptionHandler(&UncaughtExceptionHandler);\n}\n\n+ (NSUncaughtExceptionHandler *)getHandler {\n\treturn NSGetUncaughtExceptionHandler();\n}\n\n+ (void)takeException:(NSException *)exception {\n  \tNSDate   *date = [NSDate date];\n    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];\n    [formatter setDateStyle:NSDateFormatterMediumStyle];\n    [formatter setTimeStyle:NSDateFormatterShortStyle];\n    [formatter setDateFormat:@\"YYYY-MM-dd hh:mm:ss\"];\n    \n    NSString *mobile = [LoginInfoManager sharedInstance].user.mobile;\n    NSString *uuid = [DeviceInfo getDeviceNumber];\n    NSString *deviceString = [DeviceInfo deviceString];\n    NSString *network = [DeviceInfo getNetWork];\n    NSString *prisonBreak = [DeviceInfo getSystemStatus];\n    NSString *version = APP_VERSION;\n    NSString *phoneVersion = [[UIDevice currentDevice] systemVersion];\n    NSString *reason = [exception reason];   // 崩溃的原因  可以有崩溃的原因(数组越界,字典nil,调用未知方法...) 崩溃的控制器以及方法\n    NSString *name = [exception name];\n    NSString *dateTime = [formatter stringFromDate:date];\n    NSArray  *callStackSymbolsArray = [exception callStackSymbols];\n    \n    NSString *logInfo = [NSString stringWithFormat:@\"========异常错误报告========\\nmobile:%@\\nuuid:%@\\ndeviceString:%@\\nnet:%@\\nprisonBreak:%@\\nversion:%@\\ndateTime:%@\\nphoneVersion:%@\\nname:%@\\nreason:\\n%@\\ncallStackSymbols:\\n%@\",mobile,uuid,deviceString,network,prisonBreak,version,dateTime,phoneVersion,name,reason,[callStackSymbolsArray componentsJoinedByString:@\"\\n\"]];\n    NSString *path = [applicationDocumentsDirectory() stringByAppendingPathComponent:@\"ExceptionLog.txt\"];\n    [logInfo writeToFile:path atomically:YES encoding:NSUTF8StringEncoding error:nil];\n}\n\n@end\n```\n\n\n\n```objective-c\n#import <Foundation/Foundation.h>\n#import <SystemConfiguration/CaptiveNetwork.h>  //  获取wifi\n#import <CoreMotion/CoreMotion.h>  //  加速计\n#import <ifaddrs.h>    //获取Ip\n#import <arpa/inet.h>\n#import <net/if.h>\n#define IOS_CELLULAR    @\"pdp_ip0\"\n#define IOS_WIFI        @\"en0\"\n#define IOS_VPN         @\"utun0\"\n#define IP_ADDR_IPv4    @\"ipv4\"\n#define IP_ADDR_IPv6    @\"ipv6\"\n\n@interface DeviceInfo : NSObject\n#pragma mark - 获取设备当前网络IP地址\n+ (NSString *)getIPAddress:(BOOL)preferIPv4;\n+ (NSString *)getWifiName;\n\n+ (NSString *)getDeviceNumber;\n+ (NSString *)getSystemStatus;  // 0 代表没有越狱。 1 代表越狱\n+ (NSString *)getSystemVersion;\n+ (NSString *)deviceString;\n+ (NSString *)getNetWork;\n@end\n```\n\n```objective-c\n# import \"DeviceInfo.h\"\n# import \"sys/utsname.h\"\n# import <CoreTelephony/CoreTelephonyDefines.h>\n# import <CoreTelephony/CTTelephonyNetworkInfo.h>\n# import <AFNetworkReachabilityManager.h> //有用到AFNetworking\n\n# define ARRAY_SIZE(a) sizeof(a)/sizeof(a[0])    //获取是否越狱\n\nconst char* jailbreak_tool_pathes[] = {\n\t\"/Applications/Cydia.app\",\n\t\"/Library/MobileSubstrate/MobileSubstrate.dylib\",\n\t\"/bin/bash\",\n\t\"/usr/sbin/sshd\",\n\t\"/etc/apt\"\n};\n```\n\n```objective-c\n@implementation DeviceInfo\n\n+ (NSString *)getIPAddress:(BOOL)preferIPv4\n{\n    NSArray *searchArray = preferIPv4 ?\n    @[ IOS_VPN @\"/\" IP_ADDR_IPv4, IOS_VPN @\"/\" IP_ADDR_IPv6, IOS_WIFI @\"/\" IP_ADDR_IPv4, IOS_WIFI @\"/\" IP_ADDR_IPv6, IOS_CELLULAR @\"/\" IP_ADDR_IPv4, IOS_CELLULAR @\"/\" IP_ADDR_IPv6 ] :\n    @[ IOS_VPN @\"/\" IP_ADDR_IPv6, IOS_VPN @\"/\" IP_ADDR_IPv4, IOS_WIFI @\"/\" IP_ADDR_IPv6, IOS_WIFI @\"/\" IP_ADDR_IPv4, IOS_CELLULAR @\"/\" IP_ADDR_IPv6, IOS_CELLULAR @\"/\" IP_ADDR_IPv4 ] ;\n    \n    NSDictionary *addresses = [self getIPAddresses];\n    \n    \n    __block NSString *address;\n    [searchArray enumerateObjectsUsingBlock:^(NSString *key, NSUInteger idx, BOOL *stop)\n     {\n         address = addresses[key];\n         //筛选出IP地址格式\n         if([self isValidatIP:address]) *stop = YES;\n     } ];\n    return address ? address : @\"0.0.0.0\";\n}\n\n+ (BOOL)isValidatIP:(NSString *)ipAddress {\n    if (ipAddress.length == 0) {\n        return NO;\n    }\n    NSString *urlRegEx = @\"^([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.\"\n    \"([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.\"\n    \"([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.\"\n    \"([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])$\";\n    \n    NSError *error;\n    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:urlRegEx options:0 error:&error];\n    \n    if (regex != nil) {\n        NSTextCheckingResult *firstMatch=[regex firstMatchInString:ipAddress options:0 range:NSMakeRange(0, [ipAddress length])];\n        \n        if (firstMatch) {\n            NSRange resultRange = [firstMatch rangeAtIndex:0];\n            NSString *result=[ipAddress substringWithRange:resultRange];\n            //输出结果\n            NSLog(@\"%@\",result);\n            return YES;\n        }\n    }\n    return NO;\n}\n\n+ (NSDictionary *)getIPAddresses\n{\n    NSMutableDictionary *addresses = [NSMutableDictionary dictionaryWithCapacity:8];\n    \n    // retrieve the current interfaces - returns 0 on success\n    struct ifaddrs *interfaces;\n    if(!getifaddrs(&interfaces)) {\n        // Loop through linked list of interfaces\n        struct ifaddrs *interface;\n        for(interface=interfaces; interface; interface=interface->ifa_next) {\n            if(!(interface->ifa_flags & IFF_UP) /* || (interface->ifa_flags & IFF_LOOPBACK) */ ) {\n                continue; // deeply nested code harder to read\n            }\n            const struct sockaddr_in *addr = (const struct sockaddr_in*)interface->ifa_addr;\n            char addrBuf[ MAX(INET_ADDRSTRLEN, INET6_ADDRSTRLEN) ];\n            if(addr && (addr->sin_family==AF_INET || addr->sin_family==AF_INET6)) {\n                NSString *name = [NSString stringWithUTF8String:interface->ifa_name];\n                NSString *type;\n                if(addr->sin_family == AF_INET) {\n                    if(inet_ntop(AF_INET, &addr->sin_addr, addrBuf, INET_ADDRSTRLEN)) {\n                        type = IP_ADDR_IPv4;\n                    }\n                } else {\n                    const struct sockaddr_in6 *addr6 = (const struct sockaddr_in6*)interface->ifa_addr;\n                    if(inet_ntop(AF_INET6, &addr6->sin6_addr, addrBuf, INET6_ADDRSTRLEN)) {\n                        type = IP_ADDR_IPv6;\n                    }\n                }\n                if(type) {\n                    NSString *key = [NSString stringWithFormat:@\"%@/%@\", name, type];\n                    addresses[key] = [NSString stringWithUTF8String:addrBuf];\n                }\n            }\n        }\n        // Free memory\n        freeifaddrs(interfaces);\n    }\n    return [addresses count] ? addresses : nil;\n}\n\n\n+ (NSString *)getWifiName\n{\n    NSString *wifiName = @\"\";\n    \n    CFArrayRef wifiInterfaces = CNCopySupportedInterfaces();\n    \n    if (!wifiInterfaces) {\n        return @\"\";\n    }\n    \n    NSArray *interfaces = (__bridge NSArray *)wifiInterfaces;\n    \n    for (NSString *interfaceName in interfaces) {\n        CFDictionaryRef dictRef = CNCopyCurrentNetworkInfo((__bridge CFStringRef)(interfaceName));\n        \n        if (dictRef) {\n            NSDictionary *networkInfo = (__bridge NSDictionary *)dictRef;\n            NSLog(@\"network info -> %@\", networkInfo);\n            wifiName = [networkInfo objectForKey:(__bridge NSString *)kCNNetworkInfoKeySSID];\n            \n            CFRelease(dictRef);\n        }\n    }\n    \n    CFRelease(wifiInterfaces);\n    return wifiName;\n}\n\n+ (NSString *)getDeviceNumber{\n    NSString *deviceNumber = [self uuid];  //自己项目里面获取UUID的方法\n    return deviceNumber;\n}\n\n+ (NSString *)getSystemVersion{\n    NSString *systemVersion = [[UIDevice currentDevice] systemVersion];\n    return systemVersion;\n}\n\n+ (NSString *)getSystemStatus{\n    BOOL isJailBreak = [self checkIsJailBreak];\n    NSString *systemStatus = @\"\";\n    if (isJailBreak) {\n        systemStatus = @\"1\";\n    }else{\n        systemStatus = @\"0\";\n    }\n    return systemStatus;\n}\n\n+ (BOOL)checkIsJailBreak{\n    for (int i=0; i<ARRAY_SIZE(jailbreak_tool_pathes); i++) {\n        if ([[NSFileManager defaultManager] fileExistsAtPath:[NSString stringWithUTF8String:jailbreak_tool_pathes[i]]]) {\n            NSLog(@\"The device is jail broken!\");\n            return YES;\n        }\n    }\n    NSLog(@\"The device is NOT jail broken!\");\n    return NO;\n}\n\n+ (NSString *)deviceString {\n    struct utsname systemInfo;\n    uname(&systemInfo);\n    return [NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding];\n}\n\n+ (NSString *)getNetWork {\n    \n    UIApplication *app = [UIApplication sharedApplication];\n    NSArray *children;\n    if ([[app valueForKeyPath:@\"_statusBar\"] isKindOfClass:NSClassFromString(@\"UIStatusBar_Modern\")]) {\n        return [self getIphoneXNetInfo];\n    } else {\n        children = [[[app valueForKeyPath:@\"_statusBar\"] valueForKeyPath:@\"foregroundView\"] subviews];\n    }\n    int type = 0;\n    for (id child in children) {\n        if ([child isKindOfClass:[NSClassFromString(@\"UIStatusBarDataNetworkItemView\") class]]) {\n            type = [[child valueForKeyPath:@\"dataNetworkType\"] intValue];\n        }\n    }\n\n    NSString *stateString = @\"wifi\";\n    switch (type) {\n        case 0:\n            stateString = @\"\";\n            break;\n\n        case 1:\n            stateString = @\"2G\";\n            break;\n\n        case 2:\n            stateString = @\"3G\";\n            break;\n\n        case 3:\n            stateString = @\"4G\";\n            break;\n\n        case 4:\n            stateString = @\"LTE\";\n            break;\n\n        case 5:\n            stateString = @\"wifi\";\n            break;\n\n        default:\n            break;\n    }\n\n    return stateString;\n}\n\n+ (NSString *)getIphoneXNetInfo {\n    AFNetworkReachabilityStatus status = [AFNetworkReachabilityManager sharedManager].networkReachabilityStatus;\n    if(status == AFNetworkReachabilityStatusReachableViaWiFi) {\n        return @\"wifi\";\n    }else if(status == AFNetworkReachabilityStatusNotReachable) {\n        return @\"\";\n    }else {\n        NSArray *typeStrings2G = @[CTRadioAccessTechnologyEdge,\n                                   CTRadioAccessTechnologyGPRS,\n                                   CTRadioAccessTechnologyCDMA1x];\n        NSArray *typeStrings3G = @[CTRadioAccessTechnologyHSDPA,\n                                   CTRadioAccessTechnologyWCDMA,\n                                   CTRadioAccessTechnologyHSUPA,\n                                   CTRadioAccessTechnologyCDMAEVDORev0,\n                                   CTRadioAccessTechnologyCDMAEVDORevA,\n                                   CTRadioAccessTechnologyCDMAEVDORevB,\n                                   CTRadioAccessTechnologyeHRPD];\n        \n        NSArray *typeStrings4G = @[CTRadioAccessTechnologyLTE];\n        // 该 API 在 iOS7 以上系统才有效\n        if ([[[UIDevice currentDevice] systemVersion] floatValue] >= 7.0) {\n            CTTelephonyNetworkInfo *teleInfo= [[CTTelephonyNetworkInfo alloc] init];\n            NSString *accessString = teleInfo.currentRadioAccessTechnology;\n            if ([typeStrings4G containsObject:accessString]) {\n                return @\"4G\";\n            } else if ([typeStrings3G containsObject:accessString]) {\n                return @\"3G\";\n            } else if ([typeStrings2G containsObject:accessString]) {\n                return @\"2G\";\n            } else {\n                return @\"\";\n            }\n        } else {\n            return @\"\";\n        }\n    }\n}\n\n@end\n```\n\n\n\n最后一步，在项目的APPDelegate里面进行调用一下就可以了~\n\n```objective-c\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n   \n    self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];\n    self.window.backgroundColor = [UIColor whiteColor];\n    [self.window makeKeyAndVisible];\n    //收集崩溃日志\n    [self uploadExceptionLog];\n    return YES;\n}\n```\n\n\n\n```objective-c\n- (void)uploadExceptionLog {\n    [YQUncaughtExceptionHandler setDefaultHandler];\n    // 发送崩溃日志\n    NSString *path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];\n    NSString *dataPath = [path stringByAppendingPathComponent:@\"ExceptionLog.txt\"];\n    NSData *data = [NSData dataWithContentsOfFile:dataPath];\n    if (data != nil) {\n        [self sendExceptionLogWithData:data path:dataPath];\n    }\n}\n```\n\n 到这就ok了，祝工作愉快！","slug":"iOS崩溃日志","published":1,"updated":"2017-12-07T10:10:35.277Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb1u1v8b001d1us05ctr7p4z","content":"<p>需要保存到日志里面的信息有：手机号  设备标识UUID  设备类型  网络类型  是否越狱 版本号 操作系统版本   时间   崩溃原因</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> 崩溃日志收集</span><br><span class=\"line\"> */</span><br><span class=\"line\">@interface LQUncaughtExceptionHandler : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)setDefaultHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSUncaughtExceptionHandler *)getHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)takeException:(NSException *)exception;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;LQUncaughtExceptionHandler.h&quot;</span><br><span class=\"line\">#import &quot;LoginInfoManager.h&quot;</span><br><span class=\"line\">#import &quot;DeviceInfo.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> 沙盒地址</span><br><span class=\"line\"></span><br><span class=\"line\"> @return 返回沙盒地址字符串</span><br><span class=\"line\"> */</span><br><span class=\"line\">NSString *applicationDocumentsDirectory() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    return  [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void UncaughtExceptionHandler(NSException *exception) &#123;</span><br><span class=\"line\">    NSDate   *date = [NSDate date];</span><br><span class=\"line\">\tNSDateFormatter *formatter = [[NSDateFormatter alloc] init];</span><br><span class=\"line\">\t[formatter setDateStyle:NSDateFormatterMediumStyle];</span><br><span class=\"line\">\t[formatter setTimeStyle:NSDateFormatterShortStyle];</span><br><span class=\"line\">\t[formatter setDateFormat:@&quot;YYYY-MM-dd hh:mm:ss&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">\tNSString *mobile = [LoginInfoManager sharedInstance].user.mobile;</span><br><span class=\"line\">\tNSString *uuid = [DeviceInfo getDeviceNumber];</span><br><span class=\"line\">\tNSString *deviceString = [DeviceInfo deviceString];</span><br><span class=\"line\">\tNSString *network = [DeviceInfo getNetWork];</span><br><span class=\"line\">\tNSString *prisonBreak = [DeviceInfo getSystemStatus];</span><br><span class=\"line\">\tNSString *version = APP_VERSION;</span><br><span class=\"line\">\tNSString *phoneVersion = [[UIDevice currentDevice] systemVersion];</span><br><span class=\"line\">\tNSString *dateTime = [formatter stringFromDate:date];</span><br><span class=\"line\">\tNSString *name = [exception name];</span><br><span class=\"line\">\tNSString *reason = [exception reason];   // 崩溃的原因  可以有崩溃的原因(数组越界,字典nil,调用未知方法...) 崩溃的控制器以及方法</span><br><span class=\"line\">\tNSArray  *callStackSymbolsArray = [exception callStackSymbols];</span><br><span class=\"line\"></span><br><span class=\"line\">\tNSString *logInfo = [NSString stringWithFormat:@&quot;========异常错误报告========\\nmobile:%@\\nuuid:%@\\ndeviceString:%@\\nnet:%@\\nprisonBreak:%@\\nversion:%@\\ndateTime:%@\\nphoneVersion:%@\\nname:%@\\nreason:\\n%@\\ncallStackSymbols:\\n%@&quot;,mobile,uuid,deviceString,network,prisonBreak,version,phoneVersion,dateTime,name,reason,[callStackSymbolsArray componentsJoinedByString:@&quot;\\n&quot;]];</span><br><span class=\"line\">\tNSString *path = [applicationDocumentsDirectory() stringByAppendingPathComponent:@&quot;ExceptionLog.txt&quot;];</span><br><span class=\"line\">\t[logInfo writeToFile:path atomically:YES encoding:NSUTF8StringEncoding error:nil];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation LQUncaughtExceptionHandler</span><br><span class=\"line\"></span><br><span class=\"line\">// 沙盒地址</span><br><span class=\"line\">- (NSString *)applicationDocumentsDirectory &#123;</span><br><span class=\"line\">\treturn [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)setDefaultHandler &#123;</span><br><span class=\"line\">  NSSetUncaughtExceptionHandler(&amp;UncaughtExceptionHandler);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSUncaughtExceptionHandler *)getHandler &#123;</span><br><span class=\"line\">\treturn NSGetUncaughtExceptionHandler();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)takeException:(NSException *)exception &#123;</span><br><span class=\"line\">  \tNSDate   *date = [NSDate date];</span><br><span class=\"line\">    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];</span><br><span class=\"line\">    [formatter setDateStyle:NSDateFormatterMediumStyle];</span><br><span class=\"line\">    [formatter setTimeStyle:NSDateFormatterShortStyle];</span><br><span class=\"line\">    [formatter setDateFormat:@&quot;YYYY-MM-dd hh:mm:ss&quot;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSString *mobile = [LoginInfoManager sharedInstance].user.mobile;</span><br><span class=\"line\">    NSString *uuid = [DeviceInfo getDeviceNumber];</span><br><span class=\"line\">    NSString *deviceString = [DeviceInfo deviceString];</span><br><span class=\"line\">    NSString *network = [DeviceInfo getNetWork];</span><br><span class=\"line\">    NSString *prisonBreak = [DeviceInfo getSystemStatus];</span><br><span class=\"line\">    NSString *version = APP_VERSION;</span><br><span class=\"line\">    NSString *phoneVersion = [[UIDevice currentDevice] systemVersion];</span><br><span class=\"line\">    NSString *reason = [exception reason];   // 崩溃的原因  可以有崩溃的原因(数组越界,字典nil,调用未知方法...) 崩溃的控制器以及方法</span><br><span class=\"line\">    NSString *name = [exception name];</span><br><span class=\"line\">    NSString *dateTime = [formatter stringFromDate:date];</span><br><span class=\"line\">    NSArray  *callStackSymbolsArray = [exception callStackSymbols];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSString *logInfo = [NSString stringWithFormat:@&quot;========异常错误报告========\\nmobile:%@\\nuuid:%@\\ndeviceString:%@\\nnet:%@\\nprisonBreak:%@\\nversion:%@\\ndateTime:%@\\nphoneVersion:%@\\nname:%@\\nreason:\\n%@\\ncallStackSymbols:\\n%@&quot;,mobile,uuid,deviceString,network,prisonBreak,version,dateTime,phoneVersion,name,reason,[callStackSymbolsArray componentsJoinedByString:@&quot;\\n&quot;]];</span><br><span class=\"line\">    NSString *path = [applicationDocumentsDirectory() stringByAppendingPathComponent:@&quot;ExceptionLog.txt&quot;];</span><br><span class=\"line\">    [logInfo writeToFile:path atomically:YES encoding:NSUTF8StringEncoding error:nil];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &lt;SystemConfiguration/CaptiveNetwork.h&gt;  //  获取wifi</span><br><span class=\"line\">#import &lt;CoreMotion/CoreMotion.h&gt;  //  加速计</span><br><span class=\"line\">#import &lt;ifaddrs.h&gt;    //获取Ip</span><br><span class=\"line\">#import &lt;arpa/inet.h&gt;</span><br><span class=\"line\">#import &lt;net/if.h&gt;</span><br><span class=\"line\">#define IOS_CELLULAR    @&quot;pdp_ip0&quot;</span><br><span class=\"line\">#define IOS_WIFI        @&quot;en0&quot;</span><br><span class=\"line\">#define IOS_VPN         @&quot;utun0&quot;</span><br><span class=\"line\">#define IP_ADDR_IPv4    @&quot;ipv4&quot;</span><br><span class=\"line\">#define IP_ADDR_IPv6    @&quot;ipv6&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface DeviceInfo : NSObject</span><br><span class=\"line\">#pragma mark - 获取设备当前网络IP地址</span><br><span class=\"line\">+ (NSString *)getIPAddress:(BOOL)preferIPv4;</span><br><span class=\"line\">+ (NSString *)getWifiName;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)getDeviceNumber;</span><br><span class=\"line\">+ (NSString *)getSystemStatus;  // 0 代表没有越狱。 1 代表越狱</span><br><span class=\"line\">+ (NSString *)getSystemVersion;</span><br><span class=\"line\">+ (NSString *)deviceString;</span><br><span class=\"line\">+ (NSString *)getNetWork;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># import &quot;DeviceInfo.h&quot;</span><br><span class=\"line\"># import &quot;sys/utsname.h&quot;</span><br><span class=\"line\"># import &lt;CoreTelephony/CoreTelephonyDefines.h&gt;</span><br><span class=\"line\"># import &lt;CoreTelephony/CTTelephonyNetworkInfo.h&gt;</span><br><span class=\"line\"># import &lt;AFNetworkReachabilityManager.h&gt; //有用到AFNetworking</span><br><span class=\"line\"></span><br><span class=\"line\"># define ARRAY_SIZE(a) sizeof(a)/sizeof(a[0])    //获取是否越狱</span><br><span class=\"line\"></span><br><span class=\"line\">const char* jailbreak_tool_pathes[] = &#123;</span><br><span class=\"line\">\t&quot;/Applications/Cydia.app&quot;,</span><br><span class=\"line\">\t&quot;/Library/MobileSubstrate/MobileSubstrate.dylib&quot;,</span><br><span class=\"line\">\t&quot;/bin/bash&quot;,</span><br><span class=\"line\">\t&quot;/usr/sbin/sshd&quot;,</span><br><span class=\"line\">\t&quot;/etc/apt&quot;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation DeviceInfo</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)getIPAddress:(BOOL)preferIPv4</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSArray *searchArray = preferIPv4 ?</span><br><span class=\"line\">    @[ IOS_VPN @&quot;/&quot; IP_ADDR_IPv4, IOS_VPN @&quot;/&quot; IP_ADDR_IPv6, IOS_WIFI @&quot;/&quot; IP_ADDR_IPv4, IOS_WIFI @&quot;/&quot; IP_ADDR_IPv6, IOS_CELLULAR @&quot;/&quot; IP_ADDR_IPv4, IOS_CELLULAR @&quot;/&quot; IP_ADDR_IPv6 ] :</span><br><span class=\"line\">    @[ IOS_VPN @&quot;/&quot; IP_ADDR_IPv6, IOS_VPN @&quot;/&quot; IP_ADDR_IPv4, IOS_WIFI @&quot;/&quot; IP_ADDR_IPv6, IOS_WIFI @&quot;/&quot; IP_ADDR_IPv4, IOS_CELLULAR @&quot;/&quot; IP_ADDR_IPv6, IOS_CELLULAR @&quot;/&quot; IP_ADDR_IPv4 ] ;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSDictionary *addresses = [self getIPAddresses];</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    __block NSString *address;</span><br><span class=\"line\">    [searchArray enumerateObjectsUsingBlock:^(NSString *key, NSUInteger idx, BOOL *stop)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         address = addresses[key];</span><br><span class=\"line\">         //筛选出IP地址格式</span><br><span class=\"line\">         if([self isValidatIP:address]) *stop = YES;</span><br><span class=\"line\">     &#125; ];</span><br><span class=\"line\">    return address ? address : @&quot;0.0.0.0&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (BOOL)isValidatIP:(NSString *)ipAddress &#123;</span><br><span class=\"line\">    if (ipAddress.length == 0) &#123;</span><br><span class=\"line\">        return NO;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    NSString *urlRegEx = @&quot;^([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.&quot;</span><br><span class=\"line\">    &quot;([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.&quot;</span><br><span class=\"line\">    &quot;([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.&quot;</span><br><span class=\"line\">    &quot;([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])$&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSError *error;</span><br><span class=\"line\">    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:urlRegEx options:0 error:&amp;error];</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (regex != nil) &#123;</span><br><span class=\"line\">        NSTextCheckingResult *firstMatch=[regex firstMatchInString:ipAddress options:0 range:NSMakeRange(0, [ipAddress length])];</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (firstMatch) &#123;</span><br><span class=\"line\">            NSRange resultRange = [firstMatch rangeAtIndex:0];</span><br><span class=\"line\">            NSString *result=[ipAddress substringWithRange:resultRange];</span><br><span class=\"line\">            //输出结果</span><br><span class=\"line\">            NSLog(@&quot;%@&quot;,result);</span><br><span class=\"line\">            return YES;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return NO;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSDictionary *)getIPAddresses</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSMutableDictionary *addresses = [NSMutableDictionary dictionaryWithCapacity:8];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // retrieve the current interfaces - returns 0 on success</span><br><span class=\"line\">    struct ifaddrs *interfaces;</span><br><span class=\"line\">    if(!getifaddrs(&amp;interfaces)) &#123;</span><br><span class=\"line\">        // Loop through linked list of interfaces</span><br><span class=\"line\">        struct ifaddrs *interface;</span><br><span class=\"line\">        for(interface=interfaces; interface; interface=interface-&gt;ifa_next) &#123;</span><br><span class=\"line\">            if(!(interface-&gt;ifa_flags &amp; IFF_UP) /* || (interface-&gt;ifa_flags &amp; IFF_LOOPBACK) */ ) &#123;</span><br><span class=\"line\">                continue; // deeply nested code harder to read</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            const struct sockaddr_in *addr = (const struct sockaddr_in*)interface-&gt;ifa_addr;</span><br><span class=\"line\">            char addrBuf[ MAX(INET_ADDRSTRLEN, INET6_ADDRSTRLEN) ];</span><br><span class=\"line\">            if(addr &amp;&amp; (addr-&gt;sin_family==AF_INET || addr-&gt;sin_family==AF_INET6)) &#123;</span><br><span class=\"line\">                NSString *name = [NSString stringWithUTF8String:interface-&gt;ifa_name];</span><br><span class=\"line\">                NSString *type;</span><br><span class=\"line\">                if(addr-&gt;sin_family == AF_INET) &#123;</span><br><span class=\"line\">                    if(inet_ntop(AF_INET, &amp;addr-&gt;sin_addr, addrBuf, INET_ADDRSTRLEN)) &#123;</span><br><span class=\"line\">                        type = IP_ADDR_IPv4;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    const struct sockaddr_in6 *addr6 = (const struct sockaddr_in6*)interface-&gt;ifa_addr;</span><br><span class=\"line\">                    if(inet_ntop(AF_INET6, &amp;addr6-&gt;sin6_addr, addrBuf, INET6_ADDRSTRLEN)) &#123;</span><br><span class=\"line\">                        type = IP_ADDR_IPv6;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if(type) &#123;</span><br><span class=\"line\">                    NSString *key = [NSString stringWithFormat:@&quot;%@/%@&quot;, name, type];</span><br><span class=\"line\">                    addresses[key] = [NSString stringWithUTF8String:addrBuf];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // Free memory</span><br><span class=\"line\">        freeifaddrs(interfaces);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [addresses count] ? addresses : nil;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)getWifiName</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSString *wifiName = @&quot;&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    CFArrayRef wifiInterfaces = CNCopySupportedInterfaces();</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (!wifiInterfaces) &#123;</span><br><span class=\"line\">        return @&quot;&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSArray *interfaces = (__bridge NSArray *)wifiInterfaces;</span><br><span class=\"line\">    </span><br><span class=\"line\">    for (NSString *interfaceName in interfaces) &#123;</span><br><span class=\"line\">        CFDictionaryRef dictRef = CNCopyCurrentNetworkInfo((__bridge CFStringRef)(interfaceName));</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (dictRef) &#123;</span><br><span class=\"line\">            NSDictionary *networkInfo = (__bridge NSDictionary *)dictRef;</span><br><span class=\"line\">            NSLog(@&quot;network info -&gt; %@&quot;, networkInfo);</span><br><span class=\"line\">            wifiName = [networkInfo objectForKey:(__bridge NSString *)kCNNetworkInfoKeySSID];</span><br><span class=\"line\">            </span><br><span class=\"line\">            CFRelease(dictRef);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    CFRelease(wifiInterfaces);</span><br><span class=\"line\">    return wifiName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)getDeviceNumber&#123;</span><br><span class=\"line\">    NSString *deviceNumber = [self uuid];  //自己项目里面获取UUID的方法</span><br><span class=\"line\">    return deviceNumber;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)getSystemVersion&#123;</span><br><span class=\"line\">    NSString *systemVersion = [[UIDevice currentDevice] systemVersion];</span><br><span class=\"line\">    return systemVersion;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)getSystemStatus&#123;</span><br><span class=\"line\">    BOOL isJailBreak = [self checkIsJailBreak];</span><br><span class=\"line\">    NSString *systemStatus = @&quot;&quot;;</span><br><span class=\"line\">    if (isJailBreak) &#123;</span><br><span class=\"line\">        systemStatus = @&quot;1&quot;;</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        systemStatus = @&quot;0&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return systemStatus;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (BOOL)checkIsJailBreak&#123;</span><br><span class=\"line\">    for (int i=0; i&lt;ARRAY_SIZE(jailbreak_tool_pathes); i++) &#123;</span><br><span class=\"line\">        if ([[NSFileManager defaultManager] fileExistsAtPath:[NSString stringWithUTF8String:jailbreak_tool_pathes[i]]]) &#123;</span><br><span class=\"line\">            NSLog(@&quot;The device is jail broken!&quot;);</span><br><span class=\"line\">            return YES;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    NSLog(@&quot;The device is NOT jail broken!&quot;);</span><br><span class=\"line\">    return NO;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)deviceString &#123;</span><br><span class=\"line\">    struct utsname systemInfo;</span><br><span class=\"line\">    uname(&amp;systemInfo);</span><br><span class=\"line\">    return [NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)getNetWork &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    UIApplication *app = [UIApplication sharedApplication];</span><br><span class=\"line\">    NSArray *children;</span><br><span class=\"line\">    if ([[app valueForKeyPath:@&quot;_statusBar&quot;] isKindOfClass:NSClassFromString(@&quot;UIStatusBar_Modern&quot;)]) &#123;</span><br><span class=\"line\">        return [self getIphoneXNetInfo];</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        children = [[[app valueForKeyPath:@&quot;_statusBar&quot;] valueForKeyPath:@&quot;foregroundView&quot;] subviews];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    int type = 0;</span><br><span class=\"line\">    for (id child in children) &#123;</span><br><span class=\"line\">        if ([child isKindOfClass:[NSClassFromString(@&quot;UIStatusBarDataNetworkItemView&quot;) class]]) &#123;</span><br><span class=\"line\">            type = [[child valueForKeyPath:@&quot;dataNetworkType&quot;] intValue];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSString *stateString = @&quot;wifi&quot;;</span><br><span class=\"line\">    switch (type) &#123;</span><br><span class=\"line\">        case 0:</span><br><span class=\"line\">            stateString = @&quot;&quot;;</span><br><span class=\"line\">            break;</span><br><span class=\"line\"></span><br><span class=\"line\">        case 1:</span><br><span class=\"line\">            stateString = @&quot;2G&quot;;</span><br><span class=\"line\">            break;</span><br><span class=\"line\"></span><br><span class=\"line\">        case 2:</span><br><span class=\"line\">            stateString = @&quot;3G&quot;;</span><br><span class=\"line\">            break;</span><br><span class=\"line\"></span><br><span class=\"line\">        case 3:</span><br><span class=\"line\">            stateString = @&quot;4G&quot;;</span><br><span class=\"line\">            break;</span><br><span class=\"line\"></span><br><span class=\"line\">        case 4:</span><br><span class=\"line\">            stateString = @&quot;LTE&quot;;</span><br><span class=\"line\">            break;</span><br><span class=\"line\"></span><br><span class=\"line\">        case 5:</span><br><span class=\"line\">            stateString = @&quot;wifi&quot;;</span><br><span class=\"line\">            break;</span><br><span class=\"line\"></span><br><span class=\"line\">        default:</span><br><span class=\"line\">            break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return stateString;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)getIphoneXNetInfo &#123;</span><br><span class=\"line\">    AFNetworkReachabilityStatus status = [AFNetworkReachabilityManager sharedManager].networkReachabilityStatus;</span><br><span class=\"line\">    if(status == AFNetworkReachabilityStatusReachableViaWiFi) &#123;</span><br><span class=\"line\">        return @&quot;wifi&quot;;</span><br><span class=\"line\">    &#125;else if(status == AFNetworkReachabilityStatusNotReachable) &#123;</span><br><span class=\"line\">        return @&quot;&quot;;</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        NSArray *typeStrings2G = @[CTRadioAccessTechnologyEdge,</span><br><span class=\"line\">                                   CTRadioAccessTechnologyGPRS,</span><br><span class=\"line\">                                   CTRadioAccessTechnologyCDMA1x];</span><br><span class=\"line\">        NSArray *typeStrings3G = @[CTRadioAccessTechnologyHSDPA,</span><br><span class=\"line\">                                   CTRadioAccessTechnologyWCDMA,</span><br><span class=\"line\">                                   CTRadioAccessTechnologyHSUPA,</span><br><span class=\"line\">                                   CTRadioAccessTechnologyCDMAEVDORev0,</span><br><span class=\"line\">                                   CTRadioAccessTechnologyCDMAEVDORevA,</span><br><span class=\"line\">                                   CTRadioAccessTechnologyCDMAEVDORevB,</span><br><span class=\"line\">                                   CTRadioAccessTechnologyeHRPD];</span><br><span class=\"line\">        </span><br><span class=\"line\">        NSArray *typeStrings4G = @[CTRadioAccessTechnologyLTE];</span><br><span class=\"line\">        // 该 API 在 iOS7 以上系统才有效</span><br><span class=\"line\">        if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 7.0) &#123;</span><br><span class=\"line\">            CTTelephonyNetworkInfo *teleInfo= [[CTTelephonyNetworkInfo alloc] init];</span><br><span class=\"line\">            NSString *accessString = teleInfo.currentRadioAccessTechnology;</span><br><span class=\"line\">            if ([typeStrings4G containsObject:accessString]) &#123;</span><br><span class=\"line\">                return @&quot;4G&quot;;</span><br><span class=\"line\">            &#125; else if ([typeStrings3G containsObject:accessString]) &#123;</span><br><span class=\"line\">                return @&quot;3G&quot;;</span><br><span class=\"line\">            &#125; else if ([typeStrings2G containsObject:accessString]) &#123;</span><br><span class=\"line\">                return @&quot;2G&quot;;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                return @&quot;&quot;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return @&quot;&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>最后一步，在项目的APPDelegate里面进行调用一下就可以了~</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];</span><br><span class=\"line\">    self.window.backgroundColor = [UIColor whiteColor];</span><br><span class=\"line\">    [self.window makeKeyAndVisible];</span><br><span class=\"line\">    //收集崩溃日志</span><br><span class=\"line\">    [self uploadExceptionLog];</span><br><span class=\"line\">    return YES;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)uploadExceptionLog &#123;</span><br><span class=\"line\">    [YQUncaughtExceptionHandler setDefaultHandler];</span><br><span class=\"line\">    // 发送崩溃日志</span><br><span class=\"line\">    NSString *path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class=\"line\">    NSString *dataPath = [path stringByAppendingPathComponent:@&quot;ExceptionLog.txt&quot;];</span><br><span class=\"line\">    NSData *data = [NSData dataWithContentsOfFile:dataPath];</span><br><span class=\"line\">    if (data != nil) &#123;</span><br><span class=\"line\">        [self sendExceptionLogWithData:data path:dataPath];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 到这就ok了，祝工作愉快！</p>\n","site":{"data":{}},"excerpt":"<p>需要保存到日志里面的信息有：手机号  设备标识UUID  设备类型  网络类型  是否越狱 版本号 操作系统版本   时间   崩溃原因</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> 崩溃日志收集</span><br><span class=\"line\"> */</span><br><span class=\"line\">@interface LQUncaughtExceptionHandler : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)setDefaultHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSUncaughtExceptionHandler *)getHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)takeException:(NSException *)exception;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;LQUncaughtExceptionHandler.h&quot;</span><br><span class=\"line\">#import &quot;LoginInfoManager.h&quot;</span><br><span class=\"line\">#import &quot;DeviceInfo.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> 沙盒地址</span><br><span class=\"line\"></span><br><span class=\"line\"> @return 返回沙盒地址字符串</span><br><span class=\"line\"> */</span><br><span class=\"line\">NSString *applicationDocumentsDirectory() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    return  [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void UncaughtExceptionHandler(NSException *exception) &#123;</span><br><span class=\"line\">    NSDate   *date = [NSDate date];</span><br><span class=\"line\">\tNSDateFormatter *formatter = [[NSDateFormatter alloc] init];</span><br><span class=\"line\">\t[formatter setDateStyle:NSDateFormatterMediumStyle];</span><br><span class=\"line\">\t[formatter setTimeStyle:NSDateFormatterShortStyle];</span><br><span class=\"line\">\t[formatter setDateFormat:@&quot;YYYY-MM-dd hh:mm:ss&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">\tNSString *mobile = [LoginInfoManager sharedInstance].user.mobile;</span><br><span class=\"line\">\tNSString *uuid = [DeviceInfo getDeviceNumber];</span><br><span class=\"line\">\tNSString *deviceString = [DeviceInfo deviceString];</span><br><span class=\"line\">\tNSString *network = [DeviceInfo getNetWork];</span><br><span class=\"line\">\tNSString *prisonBreak = [DeviceInfo getSystemStatus];</span><br><span class=\"line\">\tNSString *version = APP_VERSION;</span><br><span class=\"line\">\tNSString *phoneVersion = [[UIDevice currentDevice] systemVersion];</span><br><span class=\"line\">\tNSString *dateTime = [formatter stringFromDate:date];</span><br><span class=\"line\">\tNSString *name = [exception name];</span><br><span class=\"line\">\tNSString *reason = [exception reason];   // 崩溃的原因  可以有崩溃的原因(数组越界,字典nil,调用未知方法...) 崩溃的控制器以及方法</span><br><span class=\"line\">\tNSArray  *callStackSymbolsArray = [exception callStackSymbols];</span><br><span class=\"line\"></span><br><span class=\"line\">\tNSString *logInfo = [NSString stringWithFormat:@&quot;========异常错误报告========\\nmobile:%@\\nuuid:%@\\ndeviceString:%@\\nnet:%@\\nprisonBreak:%@\\nversion:%@\\ndateTime:%@\\nphoneVersion:%@\\nname:%@\\nreason:\\n%@\\ncallStackSymbols:\\n%@&quot;,mobile,uuid,deviceString,network,prisonBreak,version,phoneVersion,dateTime,name,reason,[callStackSymbolsArray componentsJoinedByString:@&quot;\\n&quot;]];</span><br><span class=\"line\">\tNSString *path = [applicationDocumentsDirectory() stringByAppendingPathComponent:@&quot;ExceptionLog.txt&quot;];</span><br><span class=\"line\">\t[logInfo writeToFile:path atomically:YES encoding:NSUTF8StringEncoding error:nil];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation LQUncaughtExceptionHandler</span><br><span class=\"line\"></span><br><span class=\"line\">// 沙盒地址</span><br><span class=\"line\">- (NSString *)applicationDocumentsDirectory &#123;</span><br><span class=\"line\">\treturn [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)setDefaultHandler &#123;</span><br><span class=\"line\">  NSSetUncaughtExceptionHandler(&amp;UncaughtExceptionHandler);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSUncaughtExceptionHandler *)getHandler &#123;</span><br><span class=\"line\">\treturn NSGetUncaughtExceptionHandler();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)takeException:(NSException *)exception &#123;</span><br><span class=\"line\">  \tNSDate   *date = [NSDate date];</span><br><span class=\"line\">    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];</span><br><span class=\"line\">    [formatter setDateStyle:NSDateFormatterMediumStyle];</span><br><span class=\"line\">    [formatter setTimeStyle:NSDateFormatterShortStyle];</span><br><span class=\"line\">    [formatter setDateFormat:@&quot;YYYY-MM-dd hh:mm:ss&quot;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSString *mobile = [LoginInfoManager sharedInstance].user.mobile;</span><br><span class=\"line\">    NSString *uuid = [DeviceInfo getDeviceNumber];</span><br><span class=\"line\">    NSString *deviceString = [DeviceInfo deviceString];</span><br><span class=\"line\">    NSString *network = [DeviceInfo getNetWork];</span><br><span class=\"line\">    NSString *prisonBreak = [DeviceInfo getSystemStatus];</span><br><span class=\"line\">    NSString *version = APP_VERSION;</span><br><span class=\"line\">    NSString *phoneVersion = [[UIDevice currentDevice] systemVersion];</span><br><span class=\"line\">    NSString *reason = [exception reason];   // 崩溃的原因  可以有崩溃的原因(数组越界,字典nil,调用未知方法...) 崩溃的控制器以及方法</span><br><span class=\"line\">    NSString *name = [exception name];</span><br><span class=\"line\">    NSString *dateTime = [formatter stringFromDate:date];</span><br><span class=\"line\">    NSArray  *callStackSymbolsArray = [exception callStackSymbols];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSString *logInfo = [NSString stringWithFormat:@&quot;========异常错误报告========\\nmobile:%@\\nuuid:%@\\ndeviceString:%@\\nnet:%@\\nprisonBreak:%@\\nversion:%@\\ndateTime:%@\\nphoneVersion:%@\\nname:%@\\nreason:\\n%@\\ncallStackSymbols:\\n%@&quot;,mobile,uuid,deviceString,network,prisonBreak,version,dateTime,phoneVersion,name,reason,[callStackSymbolsArray componentsJoinedByString:@&quot;\\n&quot;]];</span><br><span class=\"line\">    NSString *path = [applicationDocumentsDirectory() stringByAppendingPathComponent:@&quot;ExceptionLog.txt&quot;];</span><br><span class=\"line\">    [logInfo writeToFile:path atomically:YES encoding:NSUTF8StringEncoding error:nil];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &lt;SystemConfiguration/CaptiveNetwork.h&gt;  //  获取wifi</span><br><span class=\"line\">#import &lt;CoreMotion/CoreMotion.h&gt;  //  加速计</span><br><span class=\"line\">#import &lt;ifaddrs.h&gt;    //获取Ip</span><br><span class=\"line\">#import &lt;arpa/inet.h&gt;</span><br><span class=\"line\">#import &lt;net/if.h&gt;</span><br><span class=\"line\">#define IOS_CELLULAR    @&quot;pdp_ip0&quot;</span><br><span class=\"line\">#define IOS_WIFI        @&quot;en0&quot;</span><br><span class=\"line\">#define IOS_VPN         @&quot;utun0&quot;</span><br><span class=\"line\">#define IP_ADDR_IPv4    @&quot;ipv4&quot;</span><br><span class=\"line\">#define IP_ADDR_IPv6    @&quot;ipv6&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface DeviceInfo : NSObject</span><br><span class=\"line\">#pragma mark - 获取设备当前网络IP地址</span><br><span class=\"line\">+ (NSString *)getIPAddress:(BOOL)preferIPv4;</span><br><span class=\"line\">+ (NSString *)getWifiName;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)getDeviceNumber;</span><br><span class=\"line\">+ (NSString *)getSystemStatus;  // 0 代表没有越狱。 1 代表越狱</span><br><span class=\"line\">+ (NSString *)getSystemVersion;</span><br><span class=\"line\">+ (NSString *)deviceString;</span><br><span class=\"line\">+ (NSString *)getNetWork;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># import &quot;DeviceInfo.h&quot;</span><br><span class=\"line\"># import &quot;sys/utsname.h&quot;</span><br><span class=\"line\"># import &lt;CoreTelephony/CoreTelephonyDefines.h&gt;</span><br><span class=\"line\"># import &lt;CoreTelephony/CTTelephonyNetworkInfo.h&gt;</span><br><span class=\"line\"># import &lt;AFNetworkReachabilityManager.h&gt; //有用到AFNetworking</span><br><span class=\"line\"></span><br><span class=\"line\"># define ARRAY_SIZE(a) sizeof(a)/sizeof(a[0])    //获取是否越狱</span><br><span class=\"line\"></span><br><span class=\"line\">const char* jailbreak_tool_pathes[] = &#123;</span><br><span class=\"line\">\t&quot;/Applications/Cydia.app&quot;,</span><br><span class=\"line\">\t&quot;/Library/MobileSubstrate/MobileSubstrate.dylib&quot;,</span><br><span class=\"line\">\t&quot;/bin/bash&quot;,</span><br><span class=\"line\">\t&quot;/usr/sbin/sshd&quot;,</span><br><span class=\"line\">\t&quot;/etc/apt&quot;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation DeviceInfo</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)getIPAddress:(BOOL)preferIPv4</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSArray *searchArray = preferIPv4 ?</span><br><span class=\"line\">    @[ IOS_VPN @&quot;/&quot; IP_ADDR_IPv4, IOS_VPN @&quot;/&quot; IP_ADDR_IPv6, IOS_WIFI @&quot;/&quot; IP_ADDR_IPv4, IOS_WIFI @&quot;/&quot; IP_ADDR_IPv6, IOS_CELLULAR @&quot;/&quot; IP_ADDR_IPv4, IOS_CELLULAR @&quot;/&quot; IP_ADDR_IPv6 ] :</span><br><span class=\"line\">    @[ IOS_VPN @&quot;/&quot; IP_ADDR_IPv6, IOS_VPN @&quot;/&quot; IP_ADDR_IPv4, IOS_WIFI @&quot;/&quot; IP_ADDR_IPv6, IOS_WIFI @&quot;/&quot; IP_ADDR_IPv4, IOS_CELLULAR @&quot;/&quot; IP_ADDR_IPv6, IOS_CELLULAR @&quot;/&quot; IP_ADDR_IPv4 ] ;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSDictionary *addresses = [self getIPAddresses];</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    __block NSString *address;</span><br><span class=\"line\">    [searchArray enumerateObjectsUsingBlock:^(NSString *key, NSUInteger idx, BOOL *stop)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         address = addresses[key];</span><br><span class=\"line\">         //筛选出IP地址格式</span><br><span class=\"line\">         if([self isValidatIP:address]) *stop = YES;</span><br><span class=\"line\">     &#125; ];</span><br><span class=\"line\">    return address ? address : @&quot;0.0.0.0&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (BOOL)isValidatIP:(NSString *)ipAddress &#123;</span><br><span class=\"line\">    if (ipAddress.length == 0) &#123;</span><br><span class=\"line\">        return NO;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    NSString *urlRegEx = @&quot;^([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.&quot;</span><br><span class=\"line\">    &quot;([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.&quot;</span><br><span class=\"line\">    &quot;([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.&quot;</span><br><span class=\"line\">    &quot;([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])$&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSError *error;</span><br><span class=\"line\">    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:urlRegEx options:0 error:&amp;error];</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (regex != nil) &#123;</span><br><span class=\"line\">        NSTextCheckingResult *firstMatch=[regex firstMatchInString:ipAddress options:0 range:NSMakeRange(0, [ipAddress length])];</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (firstMatch) &#123;</span><br><span class=\"line\">            NSRange resultRange = [firstMatch rangeAtIndex:0];</span><br><span class=\"line\">            NSString *result=[ipAddress substringWithRange:resultRange];</span><br><span class=\"line\">            //输出结果</span><br><span class=\"line\">            NSLog(@&quot;%@&quot;,result);</span><br><span class=\"line\">            return YES;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return NO;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSDictionary *)getIPAddresses</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSMutableDictionary *addresses = [NSMutableDictionary dictionaryWithCapacity:8];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // retrieve the current interfaces - returns 0 on success</span><br><span class=\"line\">    struct ifaddrs *interfaces;</span><br><span class=\"line\">    if(!getifaddrs(&amp;interfaces)) &#123;</span><br><span class=\"line\">        // Loop through linked list of interfaces</span><br><span class=\"line\">        struct ifaddrs *interface;</span><br><span class=\"line\">        for(interface=interfaces; interface; interface=interface-&gt;ifa_next) &#123;</span><br><span class=\"line\">            if(!(interface-&gt;ifa_flags &amp; IFF_UP) /* || (interface-&gt;ifa_flags &amp; IFF_LOOPBACK) */ ) &#123;</span><br><span class=\"line\">                continue; // deeply nested code harder to read</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            const struct sockaddr_in *addr = (const struct sockaddr_in*)interface-&gt;ifa_addr;</span><br><span class=\"line\">            char addrBuf[ MAX(INET_ADDRSTRLEN, INET6_ADDRSTRLEN) ];</span><br><span class=\"line\">            if(addr &amp;&amp; (addr-&gt;sin_family==AF_INET || addr-&gt;sin_family==AF_INET6)) &#123;</span><br><span class=\"line\">                NSString *name = [NSString stringWithUTF8String:interface-&gt;ifa_name];</span><br><span class=\"line\">                NSString *type;</span><br><span class=\"line\">                if(addr-&gt;sin_family == AF_INET) &#123;</span><br><span class=\"line\">                    if(inet_ntop(AF_INET, &amp;addr-&gt;sin_addr, addrBuf, INET_ADDRSTRLEN)) &#123;</span><br><span class=\"line\">                        type = IP_ADDR_IPv4;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    const struct sockaddr_in6 *addr6 = (const struct sockaddr_in6*)interface-&gt;ifa_addr;</span><br><span class=\"line\">                    if(inet_ntop(AF_INET6, &amp;addr6-&gt;sin6_addr, addrBuf, INET6_ADDRSTRLEN)) &#123;</span><br><span class=\"line\">                        type = IP_ADDR_IPv6;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if(type) &#123;</span><br><span class=\"line\">                    NSString *key = [NSString stringWithFormat:@&quot;%@/%@&quot;, name, type];</span><br><span class=\"line\">                    addresses[key] = [NSString stringWithUTF8String:addrBuf];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // Free memory</span><br><span class=\"line\">        freeifaddrs(interfaces);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [addresses count] ? addresses : nil;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)getWifiName</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSString *wifiName = @&quot;&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    CFArrayRef wifiInterfaces = CNCopySupportedInterfaces();</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (!wifiInterfaces) &#123;</span><br><span class=\"line\">        return @&quot;&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSArray *interfaces = (__bridge NSArray *)wifiInterfaces;</span><br><span class=\"line\">    </span><br><span class=\"line\">    for (NSString *interfaceName in interfaces) &#123;</span><br><span class=\"line\">        CFDictionaryRef dictRef = CNCopyCurrentNetworkInfo((__bridge CFStringRef)(interfaceName));</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (dictRef) &#123;</span><br><span class=\"line\">            NSDictionary *networkInfo = (__bridge NSDictionary *)dictRef;</span><br><span class=\"line\">            NSLog(@&quot;network info -&gt; %@&quot;, networkInfo);</span><br><span class=\"line\">            wifiName = [networkInfo objectForKey:(__bridge NSString *)kCNNetworkInfoKeySSID];</span><br><span class=\"line\">            </span><br><span class=\"line\">            CFRelease(dictRef);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    CFRelease(wifiInterfaces);</span><br><span class=\"line\">    return wifiName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)getDeviceNumber&#123;</span><br><span class=\"line\">    NSString *deviceNumber = [self uuid];  //自己项目里面获取UUID的方法</span><br><span class=\"line\">    return deviceNumber;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)getSystemVersion&#123;</span><br><span class=\"line\">    NSString *systemVersion = [[UIDevice currentDevice] systemVersion];</span><br><span class=\"line\">    return systemVersion;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)getSystemStatus&#123;</span><br><span class=\"line\">    BOOL isJailBreak = [self checkIsJailBreak];</span><br><span class=\"line\">    NSString *systemStatus = @&quot;&quot;;</span><br><span class=\"line\">    if (isJailBreak) &#123;</span><br><span class=\"line\">        systemStatus = @&quot;1&quot;;</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        systemStatus = @&quot;0&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return systemStatus;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (BOOL)checkIsJailBreak&#123;</span><br><span class=\"line\">    for (int i=0; i&lt;ARRAY_SIZE(jailbreak_tool_pathes); i++) &#123;</span><br><span class=\"line\">        if ([[NSFileManager defaultManager] fileExistsAtPath:[NSString stringWithUTF8String:jailbreak_tool_pathes[i]]]) &#123;</span><br><span class=\"line\">            NSLog(@&quot;The device is jail broken!&quot;);</span><br><span class=\"line\">            return YES;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    NSLog(@&quot;The device is NOT jail broken!&quot;);</span><br><span class=\"line\">    return NO;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)deviceString &#123;</span><br><span class=\"line\">    struct utsname systemInfo;</span><br><span class=\"line\">    uname(&amp;systemInfo);</span><br><span class=\"line\">    return [NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)getNetWork &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    UIApplication *app = [UIApplication sharedApplication];</span><br><span class=\"line\">    NSArray *children;</span><br><span class=\"line\">    if ([[app valueForKeyPath:@&quot;_statusBar&quot;] isKindOfClass:NSClassFromString(@&quot;UIStatusBar_Modern&quot;)]) &#123;</span><br><span class=\"line\">        return [self getIphoneXNetInfo];</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        children = [[[app valueForKeyPath:@&quot;_statusBar&quot;] valueForKeyPath:@&quot;foregroundView&quot;] subviews];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    int type = 0;</span><br><span class=\"line\">    for (id child in children) &#123;</span><br><span class=\"line\">        if ([child isKindOfClass:[NSClassFromString(@&quot;UIStatusBarDataNetworkItemView&quot;) class]]) &#123;</span><br><span class=\"line\">            type = [[child valueForKeyPath:@&quot;dataNetworkType&quot;] intValue];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSString *stateString = @&quot;wifi&quot;;</span><br><span class=\"line\">    switch (type) &#123;</span><br><span class=\"line\">        case 0:</span><br><span class=\"line\">            stateString = @&quot;&quot;;</span><br><span class=\"line\">            break;</span><br><span class=\"line\"></span><br><span class=\"line\">        case 1:</span><br><span class=\"line\">            stateString = @&quot;2G&quot;;</span><br><span class=\"line\">            break;</span><br><span class=\"line\"></span><br><span class=\"line\">        case 2:</span><br><span class=\"line\">            stateString = @&quot;3G&quot;;</span><br><span class=\"line\">            break;</span><br><span class=\"line\"></span><br><span class=\"line\">        case 3:</span><br><span class=\"line\">            stateString = @&quot;4G&quot;;</span><br><span class=\"line\">            break;</span><br><span class=\"line\"></span><br><span class=\"line\">        case 4:</span><br><span class=\"line\">            stateString = @&quot;LTE&quot;;</span><br><span class=\"line\">            break;</span><br><span class=\"line\"></span><br><span class=\"line\">        case 5:</span><br><span class=\"line\">            stateString = @&quot;wifi&quot;;</span><br><span class=\"line\">            break;</span><br><span class=\"line\"></span><br><span class=\"line\">        default:</span><br><span class=\"line\">            break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return stateString;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (NSString *)getIphoneXNetInfo &#123;</span><br><span class=\"line\">    AFNetworkReachabilityStatus status = [AFNetworkReachabilityManager sharedManager].networkReachabilityStatus;</span><br><span class=\"line\">    if(status == AFNetworkReachabilityStatusReachableViaWiFi) &#123;</span><br><span class=\"line\">        return @&quot;wifi&quot;;</span><br><span class=\"line\">    &#125;else if(status == AFNetworkReachabilityStatusNotReachable) &#123;</span><br><span class=\"line\">        return @&quot;&quot;;</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        NSArray *typeStrings2G = @[CTRadioAccessTechnologyEdge,</span><br><span class=\"line\">                                   CTRadioAccessTechnologyGPRS,</span><br><span class=\"line\">                                   CTRadioAccessTechnologyCDMA1x];</span><br><span class=\"line\">        NSArray *typeStrings3G = @[CTRadioAccessTechnologyHSDPA,</span><br><span class=\"line\">                                   CTRadioAccessTechnologyWCDMA,</span><br><span class=\"line\">                                   CTRadioAccessTechnologyHSUPA,</span><br><span class=\"line\">                                   CTRadioAccessTechnologyCDMAEVDORev0,</span><br><span class=\"line\">                                   CTRadioAccessTechnologyCDMAEVDORevA,</span><br><span class=\"line\">                                   CTRadioAccessTechnologyCDMAEVDORevB,</span><br><span class=\"line\">                                   CTRadioAccessTechnologyeHRPD];</span><br><span class=\"line\">        </span><br><span class=\"line\">        NSArray *typeStrings4G = @[CTRadioAccessTechnologyLTE];</span><br><span class=\"line\">        // 该 API 在 iOS7 以上系统才有效</span><br><span class=\"line\">        if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 7.0) &#123;</span><br><span class=\"line\">            CTTelephonyNetworkInfo *teleInfo= [[CTTelephonyNetworkInfo alloc] init];</span><br><span class=\"line\">            NSString *accessString = teleInfo.currentRadioAccessTechnology;</span><br><span class=\"line\">            if ([typeStrings4G containsObject:accessString]) &#123;</span><br><span class=\"line\">                return @&quot;4G&quot;;</span><br><span class=\"line\">            &#125; else if ([typeStrings3G containsObject:accessString]) &#123;</span><br><span class=\"line\">                return @&quot;3G&quot;;</span><br><span class=\"line\">            &#125; else if ([typeStrings2G containsObject:accessString]) &#123;</span><br><span class=\"line\">                return @&quot;2G&quot;;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                return @&quot;&quot;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return @&quot;&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>最后一步，在项目的APPDelegate里面进行调用一下就可以了~</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];</span><br><span class=\"line\">    self.window.backgroundColor = [UIColor whiteColor];</span><br><span class=\"line\">    [self.window makeKeyAndVisible];</span><br><span class=\"line\">    //收集崩溃日志</span><br><span class=\"line\">    [self uploadExceptionLog];</span><br><span class=\"line\">    return YES;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)uploadExceptionLog &#123;</span><br><span class=\"line\">    [YQUncaughtExceptionHandler setDefaultHandler];</span><br><span class=\"line\">    // 发送崩溃日志</span><br><span class=\"line\">    NSString *path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class=\"line\">    NSString *dataPath = [path stringByAppendingPathComponent:@&quot;ExceptionLog.txt&quot;];</span><br><span class=\"line\">    NSData *data = [NSData dataWithContentsOfFile:dataPath];</span><br><span class=\"line\">    if (data != nil) &#123;</span><br><span class=\"line\">        [self sendExceptionLogWithData:data path:dataPath];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 到这就ok了，祝工作愉快！</p>"}],"PostAsset":[{"_id":"source/_posts/NSThread简介/2017_12_08_thread_one.png","slug":"2017_12_08_thread_one.png","post":"cjb1u1v85000v1us0ozy2zpff","modified":1,"renderable":0},{"_id":"source/_posts/NSThread简介/2017_12_08_thread_four.png","post":"cjb1u1v85000v1us0ozy2zpff","slug":"2017_12_08_thread_four.png","modified":1,"renderable":1},{"_id":"source/_posts/NSThread简介/2017_12_08_thread_three.png","post":"cjb1u1v85000v1us0ozy2zpff","slug":"2017_12_08_thread_three.png","modified":1,"renderable":1},{"_id":"source/_posts/NSThread简介/2017_12_08_thread_two.png","post":"cjb1u1v85000v1us0ozy2zpff","slug":"2017_12_08_thread_two.png","modified":1,"renderable":1},{"_id":"source/_posts/NSRunLoop简介/2017_12_08RunLoop_1.jpg","post":"cjb1u1v83000s1us0wrsfv685","slug":"2017_12_08RunLoop_1.jpg","modified":1,"renderable":1},{"_id":"source/_posts/NSRunLoop简介/2017_12_08RunLoop_2.png","post":"cjb1u1v83000s1us0wrsfv685","slug":"2017_12_08RunLoop_2.png","modified":1,"renderable":1},{"_id":"source/_posts/NSRunLoop简介/2017_12_08RunLoop_3.png","post":"cjb1u1v83000s1us0wrsfv685","slug":"2017_12_08RunLoop_3.png","modified":1,"renderable":1},{"_id":"source/_posts/NSRunLoop简介/2017_12_08RunLoop_4.png","post":"cjb1u1v83000s1us0wrsfv685","slug":"2017_12_08RunLoop_4.png","modified":1,"renderable":1},{"_id":"source/_posts/NSRunLoop简介/2017_12_08RunLoop_5.png","post":"cjb1u1v83000s1us0wrsfv685","slug":"2017_12_08RunLoop_5.png","modified":1,"renderable":1},{"_id":"source/_posts/NSRunLoop简介/2017_12_08RunLoop_6.png","slug":"2017_12_08RunLoop_6.png","post":"cjb1u1v83000s1us0wrsfv685","modified":1,"renderable":0},{"_id":"source/_posts/NSRunLoop简介/2017_12_08RunLoop_7.png","post":"cjb1u1v83000s1us0wrsfv685","slug":"2017_12_08RunLoop_7.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cjb1u1v7p00081us0gcd8fadi","category_id":"cjb1u1v7l00041us0kd158ja7","_id":"cjb1u1v7w000g1us0gfw5k0cn"},{"post_id":"cjb1u1v7g00011us0geytvzmx","category_id":"cjb1u1v7l00041us0kd158ja7","_id":"cjb1u1v80000l1us0oao2202o"},{"post_id":"cjb1u1v7s00091us0t3s70n6h","category_id":"cjb1u1v7l00041us0kd158ja7","_id":"cjb1u1v81000o1us0o4y9jcc9"},{"post_id":"cjb1u1v7j00031us0iwff964o","category_id":"cjb1u1v7t000a1us0r4wqo59l","_id":"cjb1u1v83000t1us03x24vh3r"},{"post_id":"cjb1u1v7w000f1us0t1trz0iw","category_id":"cjb1u1v7l00041us0kd158ja7","_id":"cjb1u1v85000w1us03jz5wuds"},{"post_id":"cjb1u1v7n00071us0m6xeyvj1","category_id":"cjb1u1v7l00041us0kd158ja7","_id":"cjb1u1v8600101us0i4h83zvw"},{"post_id":"cjb1u1v81000n1us07hwg5sp6","category_id":"cjb1u1v7l00041us0kd158ja7","_id":"cjb1u1v8800131us0iyl5yoi6"},{"post_id":"cjb1u1v83000s1us0wrsfv685","category_id":"cjb1u1v7l00041us0kd158ja7","_id":"cjb1u1v8900181us0l6zxydo5"},{"post_id":"cjb1u1v85000v1us0ozy2zpff","category_id":"cjb1u1v7l00041us0kd158ja7","_id":"cjb1u1v8a001b1us0wxim7rt7"},{"post_id":"cjb1u1v7z000k1us035vh3hqp","category_id":"cjb1u1v82000q1us0j783pc4v","_id":"cjb1u1v8b001e1us0vaxuhadp"},{"post_id":"cjb1u1v8700121us0zy1fb1l8","category_id":"cjb1u1v7l00041us0kd158ja7","_id":"cjb1u1v8c001g1us0asdo0oiv"},{"post_id":"cjb1u1v8900171us0k5mjkax9","category_id":"cjb1u1v7l00041us0kd158ja7","_id":"cjb1u1v8d001i1us0hbrssegp"},{"post_id":"cjb1u1v8a001a1us0fjngf74i","category_id":"cjb1u1v7l00041us0kd158ja7","_id":"cjb1u1v8d001k1us0k9cugwcf"},{"post_id":"cjb1u1v86000z1us01lw7b2re","category_id":"cjb1u1v8800141us0yjfuxfgt","_id":"cjb1u1v8f001m1us0qdy280gc"},{"post_id":"cjb1u1v8b001d1us05ctr7p4z","category_id":"cjb1u1v7l00041us0kd158ja7","_id":"cjb1u1v8g001o1us0mhffw654"}],"PostTag":[{"post_id":"cjb1u1v7p00081us0gcd8fadi","tag_id":"cjb1u1v7m00051us02jm2rrmz","_id":"cjb1u1v7u000c1us0aah0sirr"},{"post_id":"cjb1u1v7g00011us0geytvzmx","tag_id":"cjb1u1v7m00051us02jm2rrmz","_id":"cjb1u1v7v000e1us0loi3c466"},{"post_id":"cjb1u1v7s00091us0t3s70n6h","tag_id":"cjb1u1v7m00051us02jm2rrmz","_id":"cjb1u1v7z000j1us0hyb488fb"},{"post_id":"cjb1u1v7j00031us0iwff964o","tag_id":"cjb1u1v7t000b1us0yfiirbvk","_id":"cjb1u1v80000m1us01z2x4cox"},{"post_id":"cjb1u1v7w000f1us0t1trz0iw","tag_id":"cjb1u1v7m00051us02jm2rrmz","_id":"cjb1u1v82000r1us0bqhdbg5b"},{"post_id":"cjb1u1v7n00071us0m6xeyvj1","tag_id":"cjb1u1v7m00051us02jm2rrmz","_id":"cjb1u1v84000u1us04ab71oec"},{"post_id":"cjb1u1v81000n1us07hwg5sp6","tag_id":"cjb1u1v7m00051us02jm2rrmz","_id":"cjb1u1v86000y1us08jznen17"},{"post_id":"cjb1u1v83000s1us0wrsfv685","tag_id":"cjb1u1v7m00051us02jm2rrmz","_id":"cjb1u1v8700111us0higqx66w"},{"post_id":"cjb1u1v7u000d1us0s5m4y2br","tag_id":"cjb1u1v82000p1us0ro0j2ky6","_id":"cjb1u1v8900151us0t2io4q29"},{"post_id":"cjb1u1v85000v1us0ozy2zpff","tag_id":"cjb1u1v7m00051us02jm2rrmz","_id":"cjb1u1v8a00191us0w62p4a21"},{"post_id":"cjb1u1v7z000k1us035vh3hqp","tag_id":"cjb1u1v86000x1us0z63plldq","_id":"cjb1u1v8b001c1us09gjekwpa"},{"post_id":"cjb1u1v8700121us0zy1fb1l8","tag_id":"cjb1u1v7m00051us02jm2rrmz","_id":"cjb1u1v8c001f1us0wkvnf9ko"},{"post_id":"cjb1u1v8900171us0k5mjkax9","tag_id":"cjb1u1v7m00051us02jm2rrmz","_id":"cjb1u1v8c001h1us0pvaenh87"},{"post_id":"cjb1u1v8a001a1us0fjngf74i","tag_id":"cjb1u1v7m00051us02jm2rrmz","_id":"cjb1u1v8d001j1us0ncrn9r55"},{"post_id":"cjb1u1v86000z1us01lw7b2re","tag_id":"cjb1u1v8900161us0jmjmag7f","_id":"cjb1u1v8f001l1us07popagts"},{"post_id":"cjb1u1v8b001d1us05ctr7p4z","tag_id":"cjb1u1v7m00051us02jm2rrmz","_id":"cjb1u1v8f001n1us0yv88q7hr"}],"Tag":[{"name":"iOS","_id":"cjb1u1v7m00051us02jm2rrmz"},{"name":"Android","_id":"cjb1u1v7t000b1us0yfiirbvk"},{"name":"Hexo","_id":"cjb1u1v82000p1us0ro0j2ky6"},{"name":"开开心心每一天！feel小记录","_id":"cjb1u1v86000x1us0z63plldq"},{"name":"relax","_id":"cjb1u1v8900161us0jmjmag7f"}]}}